CCS PCH C Compiler, Version 4.099, 49659               12-feb-11 00:17

               Filename: D:\CURSO2011\PROGRAMA3\VDriveProbasico1.lst

               ROM used: 6560 bytes (27%)
                         Largest free fragment is 9820
               RAM used: 866 (42%) at main() level
                         908 (44%) worst case
               Stack:    14 worst case (6 in main + 8 for interrupts)

*
2000:  GOTO   349E
*
2008:  MOVWF  05
200A:  MOVFF  FD8,06
200E:  MOVFF  FE0,07
2012:  MOVLB  0
2014:  MOVFF  FE9,0D
2018:  MOVFF  FEA,08
201C:  MOVFF  FE1,09
2020:  MOVFF  FE2,0A
2024:  MOVFF  FD9,0B
2028:  MOVFF  FDA,0C
202C:  MOVFF  FF3,14
2030:  MOVFF  FF4,15
2034:  MOVFF  FFA,16
2038:  MOVFF  00,0F
203C:  MOVFF  01,10
2040:  MOVFF  02,11
2044:  MOVFF  03,12
2048:  MOVFF  04,13
204C:  BTFSS  FA0.5
204E:  GOTO   2058
2052:  BTFSC  FA1.5
2054:  GOTO   303C
2058:  MOVFF  0F,00
205C:  MOVFF  10,01
2060:  MOVFF  11,02
2064:  MOVFF  12,03
2068:  MOVFF  13,04
206C:  MOVFF  0D,FE9
2070:  MOVFF  08,FEA
2074:  BSF    08.7
2076:  MOVFF  09,FE1
207A:  MOVFF  0A,FE2
207E:  MOVFF  0B,FD9
2082:  MOVFF  0C,FDA
2086:  MOVFF  14,FF3
208A:  MOVFF  15,FF4
208E:  MOVFF  16,FFA
2092:  MOVF   05,W
2094:  MOVFF  07,FE0
2098:  MOVFF  06,FD8
209C:  RETFIE 0
.................... /* PROGRAMA PARA EJEMPLO DEMOSTRATIVO DE LA COMUNICACION DEL MODULO 
....................    VDRIVE CON LA TARJETA ALUX 1.1 Y LA PC 
.................... PROGRAMADO: DEPTO. INSTRUMENTACION 
....................            ING. GAMALIEL TORRES SÁNCHEZ         gtorres@cicy.mx        
....................            ING. GABRIEL JESÚS POOL BALAM        gabriel.pool@cicy.mx   
....................            ING. JULIO ALEJANDRO LUGO JIMENEZ    jalugo@cicy.mx         
....................            ING. JUAN MANUEL MOLINA AMARO        jmolina@cicy.mx   
....................            LUGAR: MERIDA, YUCATÁN. 
.................... */           
.................... /*SE MODIFICA LA LIBRERIA LCD.C Y SE RENOMBRA UNA COPIA LCD1.C 
.................... DONDE SE AGREGA UNA RUTINA PARA DESPLEGAR LOS DATOS ALMACENADOS EN UN BUFER DE 250 BYTES 
.................... LA RUTINA ES "DISPLAY_DATO(parametro1, parametro2)" variable es el nombre o puntero 
.................... donde se encuentran alojados los datos. el segundo parametro es la pausa para poder leer el display 
.................... antes de ser sobre escrito.*/ 
....................  
.................... //SI UTILIZAMOS UN PIC18F4550 SUSTITUIR #include <18F2455.h> POR #include<18F4550> 
....................    #include <18F2455.h>  //DIRECTIVA PARA ESPECIFICAR EL CHIP A UTILIZAR 
.................... //////// Standard Header file for the PIC18F2455 device //////////////// 
.................... #device PIC18F2455 
.................... #list 
....................  
....................    
....................  
....................   #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL2,CPUDIV1,VREGEN,NOPBADEN   //FUSIBLES   USBDIV 
....................     
.................... //DEFINIMOS LA CANTIDAD DE BITS UTILIZADOS POR EL ADC 
.................... // #device ADC=8 //descomentar esta fila si usa el ADC 
....................     
.................... //FRECUENCIA A CONSIDERAR EN LOS COMANDOS DE RETARDO                                                    
....................    #use delay(clock=48000000) 
*
30C4:  MOVLW  02
30C6:  MOVWF  FEA
30C8:  MOVLW  BF
30CA:  MOVWF  FE9
30CC:  MOVF   FEF,W
30CE:  BZ    30EC
30D0:  MOVLW  0F
30D2:  MOVWF  01
30D4:  CLRF   00
30D6:  DECFSZ 00,F
30D8:  BRA    30D6
30DA:  DECFSZ 01,F
30DC:  BRA    30D4
30DE:  MOVLW  8F
30E0:  MOVWF  00
30E2:  DECFSZ 00,F
30E4:  BRA    30E2
30E6:  NOP   
30E8:  DECFSZ FEF,F
30EA:  BRA    30D0
30EC:  RETLW  00
....................  
.................... //DIRECTIVAS  
....................    #include <usb_bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... //#if defined(__DEBUG) 
.................... #define LOADER_SIZE        (0x1FFF) 
.................... //#else 
.................... //#define LOADER_SIZE        (0x17FF) 
.................... //#endif 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif  
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define  USB_CONFIG_PID       0x0034 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             8, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................       //string 2 - product 
....................             30, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'D',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'B',0, 
....................             'o',0, 
....................             'o',0, 
....................             't',0, 
....................             'l',0, 
....................             'o',0, 
....................             'a',0, 
....................             'd',0, 
....................             'e',0, 
....................             'r',0 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
....................    #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
3382:  MOVFF  2BD,2BF
3386:  MOVFF  2BC,2BE
338A:  MOVFF  2BF,03
338E:  MOVLB  2
3390:  MOVFF  2BE,FE9
3394:  MOVFF  2BF,FEA
3398:  MOVF   FEF,F
339A:  BZ    33A8
339C:  INCF   xBE,F
339E:  BTFSC  FD8.2
33A0:  INCF   xBF,F
33A2:  MOVLB  0
33A4:  BRA    338A
33A6:  MOVLB  2
....................    return(sc - s); 
33A8:  MOVF   xBC,W
33AA:  SUBWF  xBE,W
33AC:  MOVWF  00
33AE:  MOVF   xBD,W
33B0:  SUBWFB xBF,W
33B2:  MOVWF  03
33B4:  MOVFF  00,01
.................... } 
33B8:  MOVLB  0
33BA:  GOTO   33D0 (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................    #include <lcd1.c>//RUTINAS PARA USO DEL LCD DEL CCS 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////   LCD.C MODIFICADO POR ING MOLINA  A LCD1.C                                   //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  char new_car[8]={0,16,8,4,2,1,0,0};    //escribe caracter '\' 
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
311E:  MOVLW  0F
3120:  ANDWF  F93,W
3122:  IORLW  F0
3124:  MOVWF  F93
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
3126:  BSF    F8A.2
....................    delay_cycles(1); 
3128:  NOP   
....................    lcd_output_enable(1); 
312A:  BSF    F8A.0
....................    delay_cycles(1); 
312C:  NOP   
....................    high = lcd_read_nibble(); 
312E:  RCALL  3112
3130:  MOVFF  01,2C6
....................        
....................    lcd_output_enable(0); 
3134:  BCF    F8A.0
....................    delay_cycles(1); 
3136:  NOP   
....................    lcd_output_enable(1); 
3138:  BSF    F8A.0
....................    delay_us(1); 
313A:  MOVLW  03
313C:  MOVWF  00
313E:  DECFSZ 00,F
3140:  BRA    313E
3142:  BRA    3144
....................    low = lcd_read_nibble(); 
3144:  RCALL  3112
3146:  MOVFF  01,2C5
....................        
....................    lcd_output_enable(0); 
314A:  BCF    F8A.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
314C:  MOVLW  0F
314E:  ANDWF  F93,W
3150:  MOVWF  F93
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
3152:  MOVLB  2
3154:  SWAPF  xC6,W
3156:  MOVWF  00
3158:  MOVLW  F0
315A:  ANDWF  00,F
315C:  MOVF   00,W
315E:  IORWF  xC5,W
3160:  MOVWF  01
.................... } 
3162:  MOVLB  0
3164:  GOTO   3172 (RETURN)
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
3112:  MOVF   F81,W
3114:  MOVWF  00
3116:  SWAPF  00,W
3118:  ANDLW  0F
311A:  MOVWF  01
....................   #endif 
.................... } 
311C:  RETLW  00
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
30EE:  MOVLB  2
30F0:  SWAPF  xC6,W
30F2:  ANDLW  F0
30F4:  MOVWF  00
30F6:  MOVLW  0F
30F8:  ANDWF  F8A,W
30FA:  IORWF  00,W
30FC:  MOVWF  F8A
....................   #endif 
....................        
....................    delay_cycles(1); 
30FE:  NOP   
....................    lcd_output_enable(1); 
3100:  BSF    F8A.0
....................    delay_us(2); 
3102:  MOVLW  07
3104:  MOVWF  00
3106:  DECFSZ 00,F
3108:  BRA    3106
310A:  BRA    310C
....................    lcd_output_enable(0); 
310C:  BCF    F8A.0
.................... } 
310E:  MOVLB  0
3110:  RETLW  00
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
3168:  BCF    F93.0
....................    lcd_rs_tris(); 
316A:  BCF    F93.1
....................    lcd_rw_tris(); 
316C:  BCF    F93.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
316E:  BCF    F8A.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
3170:  BRA    311E
3172:  MOVFF  01,2C5
3176:  MOVLB  2
3178:  BTFSS  01.7
317A:  BRA    3180
317C:  MOVLB  0
317E:  BRA    3170
....................    lcd_output_rs(address); 
3180:  BCF    F8A.1
3182:  BTFSC  xC3.0
3184:  BSF    F8A.1
....................    delay_cycles(1); 
3186:  NOP   
....................    lcd_output_rw(0); 
3188:  BCF    F8A.2
....................    delay_cycles(1); 
318A:  NOP   
....................    lcd_output_enable(0); 
318C:  BCF    F8A.0
....................    lcd_send_nibble(n >> 4); 
318E:  SWAPF  xC4,W
3190:  MOVWF  xC5
3192:  MOVLW  0F
3194:  ANDWF  xC5,F
3196:  MOVFF  2C5,2C6
319A:  MOVLB  0
319C:  RCALL  30EE
....................    lcd_send_nibble(n & 0xf); 
319E:  MOVLB  2
31A0:  MOVF   xC4,W
31A2:  ANDLW  0F
31A4:  MOVWF  xC5
31A6:  MOVWF  xC6
31A8:  MOVLB  0
31AA:  RCALL  30EE
.................... } 
31AC:  RETLW  00
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
31AE:  MOVLW  0F
31B0:  ANDWF  F93,W
31B2:  MOVWF  F93
....................   #endif 
....................    lcd_enable_tris(); 
31B4:  BCF    F93.0
....................    lcd_rs_tris(); 
31B6:  BCF    F93.1
....................    lcd_rw_tris(); 
31B8:  BCF    F93.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
31BA:  BCF    F8A.1
....................    lcd_output_rw(0); 
31BC:  BCF    F8A.2
....................    lcd_output_enable(0); 
31BE:  BCF    F8A.0
....................      
....................    delay_ms(15); 
31C0:  MOVLW  0F
31C2:  MOVLB  2
31C4:  MOVWF  xBF
31C6:  MOVLB  0
31C8:  RCALL  30C4
....................    for(i=1;i<=3;++i) 
31CA:  MOVLW  01
31CC:  MOVLB  2
31CE:  MOVWF  xB1
31D0:  MOVF   xB1,W
31D2:  SUBLW  03
31D4:  BNC   31EE
....................    { 
....................        lcd_send_nibble(3); 
31D6:  MOVLW  03
31D8:  MOVWF  xC6
31DA:  MOVLB  0
31DC:  RCALL  30EE
....................        delay_ms(5); 
31DE:  MOVLW  05
31E0:  MOVLB  2
31E2:  MOVWF  xBF
31E4:  MOVLB  0
31E6:  RCALL  30C4
....................    } 
31E8:  MOVLB  2
31EA:  INCF   xB1,F
31EC:  BRA    31D0
....................     
....................    lcd_send_nibble(2); 
31EE:  MOVLW  02
31F0:  MOVWF  xC6
31F2:  MOVLB  0
31F4:  RCALL  30EE
....................    for(i=0;i<=3;++i) 
31F6:  MOVLB  2
31F8:  CLRF   xB1
31FA:  MOVF   xB1,W
31FC:  SUBLW  03
31FE:  BNC   3226
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
3200:  CLRF   03
3202:  MOVF   xB1,W
3204:  MOVFF  FF2,2B2
3208:  BCF    FF2.7
320A:  MOVLB  0
320C:  CALL   209E
3210:  MOVLB  2
3212:  BTFSC  xB2.7
3214:  BSF    FF2.7
3216:  MOVWF  xB2
3218:  CLRF   xC3
321A:  MOVWF  xC4
321C:  MOVLB  0
321E:  RCALL  3168
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
3220:  MOVLB  2
3222:  INCF   xB1,F
3224:  BRA    31FA
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
3226:  MOVLB  0
3228:  GOTO   3796 (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................     
....................    if(y!=1) 
322C:  MOVLB  2
322E:  DECFSZ xC0,W
3230:  BRA    3234
3232:  BRA    323A
....................       address=LCD_LINE_TWO; 
3234:  MOVLW  40
3236:  MOVWF  xC1
....................    else 
3238:  BRA    323C
....................       address=0; 
323A:  CLRF   xC1
....................       
....................    address+=x-1; 
323C:  MOVLW  01
323E:  SUBWF  xBF,W
3240:  ADDWF  xC1,F
....................    lcd_send_byte(0,0x80|address); 
3242:  MOVF   xC1,W
3244:  IORLW  80
3246:  MOVWF  xC2
3248:  CLRF   xC3
324A:  MOVWF  xC4
324C:  MOVLB  0
324E:  RCALL  3168
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
3250:  RETLW  00
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
3252:  MOVLB  2
3254:  MOVF   xBE,W
3256:  XORLW  07
3258:  MOVLB  0
325A:  BZ    326A
325C:  XORLW  0B
325E:  BZ    3278
3260:  XORLW  06
3262:  BZ    3290
3264:  XORLW  02
3266:  BZ    32A0
3268:  BRA    32AE
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
326A:  MOVLW  01
326C:  MOVLB  2
326E:  MOVWF  xBF
3270:  MOVWF  xC0
3272:  MOVLB  0
3274:  RCALL  322C
3276:  BRA    32BE
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
3278:  MOVLB  2
327A:  CLRF   xC3
327C:  MOVLW  01
327E:  MOVWF  xC4
3280:  MOVLB  0
3282:  RCALL  3168
....................                      delay_ms(2); 
3284:  MOVLW  02
3286:  MOVLB  2
3288:  MOVWF  xBF
328A:  MOVLB  0
328C:  RCALL  30C4
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
328E:  BRA    32BE
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
3290:  MOVLW  01
3292:  MOVLB  2
3294:  MOVWF  xBF
3296:  MOVLW  02
3298:  MOVWF  xC0
329A:  MOVLB  0
329C:  RCALL  322C
329E:  BRA    32BE
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
32A0:  MOVLB  2
32A2:  CLRF   xC3
32A4:  MOVLW  10
32A6:  MOVWF  xC4
32A8:  MOVLB  0
32AA:  RCALL  3168
32AC:  BRA    32BE
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
32AE:  MOVLW  01
32B0:  MOVLB  2
32B2:  MOVWF  xC3
32B4:  MOVFF  2BE,2C4
32B8:  MOVLB  0
32BA:  RCALL  3168
32BC:  BRA    32BE
....................      #endif 
....................    } 
.................... } 
32BE:  RETLW  00
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  void Set_Char(char dir, char new_car[8] ) { 
....................    unsigned char i; 
....................  
....................    //El lcd consta de 8 espacios para caracteres personalizables 
....................    //Ejemplo: modificar caracter ascii: 0x5C 
....................    //dir debe estar entre 0 y 7 (CG RAM DATA) 
....................    //new_car es un arreglo (8 bytes) donde cada byte corresponde con una linea de 5 bits 
....................    //del nuevo caracter. 
....................    //Character Code       Address            CG RAM Character Pattern 
....................    //(DD RAM Data)     (CG RAM Data)            (CG RAM Data) 
....................    //                    bits 5 al 3              bits 2 al 0 
....................    //                0,8,16,24,32,40,48,56     0,1,2,3,4,5,6,7 
....................                     
....................    lcd_send_byte(0,0x40+dir*8);           //0x40 para seleccionar CG RAM (0x40) en lugar de DD RAM (0x80) 
....................    delay_us(100); 
....................    for(i=0;i<8;i++) {                       
....................    lcd_send_byte(1,new_car[i]);             //Escribe cada lines del nuevo caracter en CG RAM, la dir se autoincrementa 
....................    delay_us(100); 
....................    } 
....................    lcd_send_byte(0,0x80);                   //seleccionar DD RAM (0x80) 
....................    delay_us(100); 
.................... } 
....................                                              //RUTINA PARA PANTALLA DE 16X2 
.................... void Display_Dato(char *dato2,INT16 MS) {   //ESTA ES UNA RUTINA PARA DESPLEGAR DATOS(NECESITA LA VARIBALE,Y UN NUMERO X ms  PARA EL DELAY ENTRE PANTALLAS  
.................... char *str1,*str2;                            //SE DEFINEN LOS PUNTEROS 
.................... char car='\f',car2;                          //SE DEFINE EL CARACTER DE LIMPIEZA DE PANTALLA Y CAMBIO DE LINEA 
*
33BE:  MOVLW  0C
33C0:  MOVLB  2
33C2:  MOVWF  xB9
.................... unsigned int k; 
....................    k=strlen(dato2);                          //SE OBTIENE LA LONGITUD DE LA CADENA 
33C4:  MOVFF  2B2,2BD
33C8:  MOVFF  2B1,2BC
33CC:  MOVLB  0
33CE:  BRA    3382
33D0:  MOVFF  01,2BB
....................    str2=&dato2[k];                           //SE ASIGNA AL PUNTERO EL FINAL DE LA CADENA 
33D4:  CLRF   03
33D6:  MOVLB  2
33D8:  MOVF   xBB,W
33DA:  ADDWF  xB1,W
33DC:  MOVWF  xB7
33DE:  MOVF   xB2,W
33E0:  ADDWFC 03,W
33E2:  MOVWF  xB8
....................    for(str1=dato2; str1<=str2; str1+=16) {   //SE CREA UN CICLO FOR DESDE EL INICIO HASTA EL FINAL DE LA CADENA CON INCREMENTOS POR FILA 
33E4:  MOVFF  2B2,2B6
33E8:  MOVFF  2B1,2B5
33EC:  MOVF   xB6,W
33EE:  SUBWF  xB8,W
33F0:  BNC   349A
33F2:  BNZ   33FA
33F4:  MOVF   xB5,W
33F6:  SUBWF  xB7,W
33F8:  BNC   349A
....................       car2=str1[16];                         //SALVAMOS EL CARACTER DE LA POSICION 17 DE LA CADENA PARA INTRODUCIR UN FINAL (0) 
33FA:  MOVLW  10
33FC:  ADDWF  xB5,W
33FE:  MOVWF  FE9
3400:  MOVLW  00
3402:  ADDWFC xB6,W
3404:  MOVWF  FEA
3406:  MOVFF  FEF,2BA
....................       str1[16]=0;                            // INTRODUCIMOS UN CERO COMO FINAL DE CADENA 
340A:  MOVLW  10
340C:  ADDWF  xB5,W
340E:  MOVWF  FE9
3410:  MOVLW  00
3412:  ADDWFC xB6,W
3414:  MOVWF  FEA
3416:  CLRF   FEF
....................       printf(LCD_PUTC,"%c%s",car,str1);      //SE IMPRIMEN LOS PRIMEROS 16 CARACTERES DE LA CADENA 
3418:  MOVFF  2B9,2BE
341C:  MOVLB  0
341E:  RCALL  3252
3420:  MOVFF  2B6,FEA
3424:  MOVFF  2B5,FE9
3428:  MOVLW  00
342A:  IORWF  FEF,W
342C:  BZ    344C
342E:  MOVFF  FEA,2BD
3432:  MOVFF  FE9,2BC
3436:  MOVFF  FEF,2BE
343A:  RCALL  3252
343C:  MOVFF  2BD,FEA
3440:  MOVFF  2BC,FE9
3444:  INCF   FE9,F
3446:  BTFSC  FD8.2
3448:  INCF   FEA,F
344A:  BRA    3428
....................       str1[16]=car2;                         //RECUPERAMOS EL CARACTER ORIGINAL DE LA POSICION 17 
344C:  MOVLW  10
344E:  MOVLB  2
3450:  ADDWF  xB5,W
3452:  MOVWF  FE9
3454:  MOVLW  00
3456:  ADDWFC xB6,W
3458:  MOVWF  FEA
345A:  MOVFF  2BA,FEF
....................       if (car=='\n') car='\f'; else car='\n';//SE HACE EL CAMBIO DE LINEA 
345E:  MOVF   xB9,W
3460:  SUBLW  0A
3462:  BNZ   346A
3464:  MOVLW  0C
3466:  MOVWF  xB9
3468:  BRA    346E
346A:  MOVLW  0A
346C:  MOVWF  xB9
....................       delay_ms(MS);                          // TIEMPO DE ESPERA ANTES DE BORRAR EL TEXTO    
346E:  MOVFF  2B4,2BC
3472:  INCF   xBC,F
3474:  DECF   xBC,F
3476:  BTFSC  FD8.2
3478:  BRA    3486
347A:  MOVLW  FF
347C:  MOVWF  xBF
347E:  MOVLB  0
3480:  RCALL  30C4
3482:  MOVLB  2
3484:  BRA    3474
3486:  MOVFF  2B3,2BF
348A:  MOVLB  0
348C:  RCALL  30C4
....................    } 
348E:  MOVLW  10
3490:  MOVLB  2
3492:  ADDWF  xB5,F
3494:  MOVLW  00
3496:  ADDWFC xB6,F
3498:  BRA    33EC
....................   } 
349A:  MOVLB  0
349C:  RETLW  00
....................  
....................    #include <usb_desc_cdc.h>   //DESCRIPTOR 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
....................    #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0033 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
2BB0:  CLRF   03
2BB2:  MOVLB  2
2BB4:  MOVF   xD9,W
2BB6:  ADDLW  70
2BB8:  MOVWF  FE9
2BBA:  MOVLW  0F
2BBC:  ADDWFC 03,W
2BBE:  MOVWF  FEA
2BC0:  MOVF   FEF,F
2BC2:  BZ    2BE8
2BC4:  MOVF   xD9,W
2BC6:  MULLW  08
2BC8:  MOVF   FF3,W
2BCA:  CLRF   xDB
2BCC:  MOVWF  xDA
2BCE:  MOVLW  04
2BD0:  ADDWF  xDA,F
2BD2:  MOVLW  00
2BD4:  ADDWFC xDB,F
2BD6:  MOVFF  2DA,FE9
2BDA:  MOVLW  04
2BDC:  ADDWF  xDB,W
2BDE:  MOVWF  FEA
2BE0:  MOVFF  FEF,2DA
2BE4:  BTFSS  xDA.7
2BE6:  BRA    2BEC
2BE8:  MOVLW  00
2BEA:  BRA    2BEE
2BEC:  MOVLW  01
2BEE:  MOVWF  01
.................... } 
2BF0:  MOVLB  0
2BF2:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
....................    UIE = 0;   //disable USB interrupts 
....................    UCFG = __UCFG_VAL_DISABLED__; 
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
....................    usb_token_reset(); 
....................    UCON = 0; 
....................    UCFG = __UCFG_VAL_ENABLED__; 
....................    UIE = 0;                                // Mask all USB interrupts 
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
....................    { 
....................       UIR=0; 
....................       UIE=0; 
....................       enable_interrupts(INT_USB); 
....................       enable_interrupts(GLOBAL); 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
....................       usb_state=USB_STATE_POWERED; 
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
2BF4:  MOVFF  2D4,2D9
2BF8:  RCALL  2BB0
2BFA:  MOVF   01,F
2BFC:  BZ    2CC6
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
2BFE:  MOVLB  2
2C00:  MOVF   xD4,W
2C02:  MULLW  08
2C04:  MOVF   FF3,W
2C06:  CLRF   xDA
2C08:  MOVWF  xD9
2C0A:  MOVLW  04
2C0C:  ADDWF  xD9,F
2C0E:  MOVLW  00
2C10:  ADDWFC xDA,F
2C12:  MOVLW  01
2C14:  ADDWF  xD9,W
2C16:  MOVWF  01
2C18:  MOVLW  00
2C1A:  ADDWFC xDA,W
2C1C:  MOVWF  03
2C1E:  MOVFF  01,FE9
2C22:  MOVLW  04
2C24:  ADDWF  03,W
2C26:  MOVWF  FEA
2C28:  MOVFF  2D5,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
2C2C:  MOVF   xD7,W
2C2E:  SUBLW  02
2C30:  BNZ   2C60
....................       { 
....................          i = EP_BDxST_I(endpoint); 
2C32:  MOVF   xD4,W
2C34:  MULLW  08
2C36:  MOVF   FF3,W
2C38:  CLRF   xDA
2C3A:  MOVWF  xD9
2C3C:  MOVLW  04
2C3E:  ADDWF  xD9,F
2C40:  MOVLW  00
2C42:  ADDWFC xDA,F
2C44:  MOVFF  2D9,FE9
2C48:  MOVLW  04
2C4A:  ADDWF  xDA,W
2C4C:  MOVWF  FEA
2C4E:  MOVFF  FEF,2D8
....................          if (bit_test(i,6)) 
2C52:  BTFSS  xD8.6
2C54:  BRA    2C5A
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
2C56:  CLRF   xD7
....................          else 
2C58:  BRA    2C5E
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2C5A:  MOVLW  01
2C5C:  MOVWF  xD7
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
2C5E:  BRA    2C86
2C60:  MOVF   xD7,W
2C62:  SUBLW  04
2C64:  BNZ   2C86
....................       { 
....................          i = EP_BDxST_O(endpoint); 
2C66:  MOVF   xD4,W
2C68:  MULLW  08
2C6A:  MOVF   FF3,W
2C6C:  CLRF   xDA
2C6E:  MOVWF  FE9
2C70:  MOVLW  04
2C72:  ADDWF  xDA,W
2C74:  MOVWF  FEA
2C76:  MOVFF  FEF,2D8
....................          if (bit_test(i,6)) 
2C7A:  BTFSS  xD8.6
2C7C:  BRA    2C84
....................             tgl = USB_DTS_DATA1; 
2C7E:  MOVLW  01
2C80:  MOVWF  xD7
....................          else 
2C82:  BRA    2C86
....................             tgl = USB_DTS_DATA0; 
2C84:  CLRF   xD7
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
2C86:  DECFSZ xD7,W
2C88:  BRA    2C90
....................          i=0xC8;  //DATA1, UOWN 
2C8A:  MOVLW  C8
2C8C:  MOVWF  xD8
....................       else //if (tgl == USB_DTS_DATA0)  
2C8E:  BRA    2C94
....................          i=0x88; //DATA0, UOWN 
2C90:  MOVLW  88
2C92:  MOVWF  xD8
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
2C94:  BTFSC  xD6.0
2C96:  BSF    xD8.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
2C98:  BTFSC  xD6.1
2C9A:  BSF    xD8.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
2C9C:  MOVF   xD4,W
2C9E:  MULLW  08
2CA0:  MOVF   FF3,W
2CA2:  CLRF   xDA
2CA4:  MOVWF  xD9
2CA6:  MOVLW  04
2CA8:  ADDWF  xD9,F
2CAA:  MOVLW  00
2CAC:  ADDWFC xDA,F
2CAE:  MOVFF  2D9,FE9
2CB2:  MOVLW  04
2CB4:  ADDWF  xDA,W
2CB6:  MOVWF  FEA
2CB8:  MOVFF  2D8,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
2CBC:  MOVLW  01
2CBE:  MOVWF  01
2CC0:  BRA    2CCC
....................    } 
....................    else  
2CC2:  BRA    2CC4
2CC4:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
2CC6:  MOVLW  00
2CC8:  MOVWF  01
2CCA:  MOVLB  2
.................... } 
2CCC:  MOVLB  0
2CCE:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
2DCE:  MOVFF  2CC,2D9
2DD2:  RCALL  2BB0
2DD4:  MOVF   01,F
2DD6:  BZ    2E5A
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
2DD8:  MOVLB  2
2DDA:  MOVF   xCC,W
2DDC:  MULLW  08
2DDE:  MOVF   FF3,W
2DE0:  CLRF   xD5
2DE2:  MOVWF  xD4
2DE4:  MOVLW  04
2DE6:  ADDWF  xD4,F
2DE8:  MOVLW  00
2DEA:  ADDWFC xD5,F
2DEC:  MOVLW  02
2DEE:  ADDWF  xD4,W
2DF0:  MOVWF  01
2DF2:  MOVLW  00
2DF4:  ADDWFC xD5,W
2DF6:  MOVWF  03
2DF8:  MOVFF  01,FE9
2DFC:  MOVLW  04
2DFE:  ADDWF  03,W
2E00:  MOVWF  FEA
2E02:  MOVFF  FEC,03
2E06:  MOVF   FED,F
2E08:  MOVFF  FEF,2D2
2E0C:  MOVFF  03,2D3
....................       memcpy(buff_add, ptr, len);      
2E10:  MOVFF  2D3,FEA
2E14:  MOVFF  2D2,FE9
2E18:  MOVFF  2CE,FE2
2E1C:  MOVFF  2CD,FE1
2E20:  MOVFF  2D0,02
2E24:  MOVFF  2CF,01
2E28:  MOVF   01,F
2E2A:  BZ    2E30
2E2C:  INCF   02,F
2E2E:  BRA    2E34
2E30:  MOVF   02,F
2E32:  BZ    2E40
2E34:  MOVFF  FE6,FEE
2E38:  DECFSZ 01,F
2E3A:  BRA    2E34
2E3C:  DECFSZ 02,F
2E3E:  BRA    2E34
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
2E40:  MOVFF  2CC,2D4
2E44:  MOVFF  2D0,2D6
2E48:  MOVFF  2CF,2D5
2E4C:  MOVFF  2D1,2D7
2E50:  MOVLB  0
2E52:  RCALL  2BF4
2E54:  MOVF   01,W
2E56:  BRA    2E5E
....................    } 
....................    else  
2E58:  BRA    2E5A
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
2E5A:  MOVLW  00
2E5C:  MOVWF  01
.................... } 
2E5E:  GOTO   2E7C (RETURN)
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
2AE6:  MOVLB  2
2AE8:  MOVF   xCB,W
2AEA:  MULLW  08
2AEC:  MOVF   FF3,W
2AEE:  CLRF   xD1
2AF0:  MOVWF  FE9
2AF2:  MOVLW  04
2AF4:  ADDWF  xD1,W
2AF6:  MOVWF  FEA
2AF8:  MOVFF  FEF,2CD
....................    if (tgl == USB_DTS_TOGGLE)  
2AFC:  MOVF   xCC,W
2AFE:  SUBLW  02
2B00:  BNZ   2B0E
....................    { 
....................       if (bit_test(i,6)) 
2B02:  BTFSS  xCD.6
2B04:  BRA    2B0A
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
2B06:  CLRF   xCC
....................       else 
2B08:  BRA    2B0E
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2B0A:  MOVLW  01
2B0C:  MOVWF  xCC
....................    } 
....................    if (tgl == USB_DTS_STALL)  
2B0E:  MOVF   xCC,W
2B10:  SUBLW  03
2B12:  BNZ   2B3A
....................    { 
....................       i = 0x84; 
2B14:  MOVLW  84
2B16:  MOVWF  xCD
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
2B18:  MOVF   xCB,W
2B1A:  MULLW  08
2B1C:  MOVF   FF3,W
2B1E:  CLRF   xD1
2B20:  MOVWF  xD0
2B22:  MOVLW  04
2B24:  ADDWF  xD0,F
2B26:  MOVLW  00
2B28:  ADDWFC xD1,F
2B2A:  MOVFF  2D0,FE9
2B2E:  MOVLW  04
2B30:  ADDWF  xD1,W
2B32:  MOVWF  FEA
2B34:  MOVLW  84
2B36:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
2B38:  BRA    2B48
2B3A:  DECFSZ xCC,W
2B3C:  BRA    2B44
....................       i = 0xC8;  //DATA1, UOWN 
2B3E:  MOVLW  C8
2B40:  MOVWF  xCD
....................    else //if (tgl == USB_DTS_DATA0)  
2B42:  BRA    2B48
....................       i = 0x88; //DATA0, UOWN 
2B44:  MOVLW  88
2B46:  MOVWF  xCD
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
2B48:  BCF    FD8.0
2B4A:  RLCF   xCB,W
2B4C:  CLRF   03
2B4E:  MOVFF  FF2,2D0
2B52:  BCF    FF2.7
2B54:  MOVLB  0
2B56:  CALL   212C
2B5A:  TBLRD*+
2B5C:  MOVFF  FF5,03
2B60:  MOVLB  2
2B62:  BTFSC  xD0.7
2B64:  BSF    FF2.7
2B66:  MOVWF  xCE
2B68:  MOVFF  03,2CF
....................    EP_BDxCNT_O(endpoint) = len; 
2B6C:  MOVF   xCB,W
2B6E:  MULLW  08
2B70:  MOVF   FF3,W
2B72:  CLRF   xD1
2B74:  MOVWF  xD0
2B76:  MOVLW  01
2B78:  ADDWF  xD0,W
2B7A:  MOVWF  01
2B7C:  MOVLW  00
2B7E:  ADDWFC xD1,W
2B80:  MOVWF  03
2B82:  MOVFF  01,FE9
2B86:  MOVLW  04
2B88:  ADDWF  03,W
2B8A:  MOVWF  FEA
2B8C:  MOVFF  2CE,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
2B90:  BTFSC  xCF.0
2B92:  BSF    xCD.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
2B94:  BTFSC  xCF.1
2B96:  BSF    xCD.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
2B98:  MOVF   xCB,W
2B9A:  MULLW  08
2B9C:  MOVF   FF3,W
2B9E:  CLRF   xD1
2BA0:  MOVWF  FE9
2BA2:  MOVLW  04
2BA4:  ADDWF  xD1,W
2BA6:  MOVWF  FEA
2BA8:  MOVFF  2CD,FEF
.................... } 
2BAC:  MOVLB  0
2BAE:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
2D40:  MOVLB  2
2D42:  MOVF   xCC,W
2D44:  MULLW  08
2D46:  MOVF   FF3,W
2D48:  CLRF   xCE
2D4A:  MOVWF  xCD
2D4C:  MOVLW  01
2D4E:  ADDWF  xCD,W
2D50:  MOVWF  01
2D52:  MOVLW  00
2D54:  ADDWFC xCE,W
2D56:  MOVWF  03
2D58:  MOVFF  01,FE9
2D5C:  MOVLW  04
2D5E:  ADDWF  03,W
2D60:  MOVWF  FEA
2D62:  CLRF   03
2D64:  MOVFF  FEF,01
2D68:  MOVFF  03,02
.................... } 
2D6C:  MOVLB  0
2D6E:  GOTO   2D80 (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
28F2:  MOVLB  2
28F4:  BCF    xCC.0
28F6:  BTFSC  xCB.7
28F8:  BSF    xCC.0
....................    endpoint &= 0x7F; 
28FA:  BCF    xCB.7
....................     
....................    if (direction)  
28FC:  BTFSS  xCC.0
28FE:  BRA    2922
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
2900:  MOVF   xCB,W
2902:  MULLW  08
2904:  MOVF   FF3,W
2906:  CLRF   xCE
2908:  MOVWF  xCD
290A:  MOVLW  04
290C:  ADDWF  xCD,F
290E:  MOVLW  00
2910:  ADDWFC xCE,F
2912:  MOVFF  2CD,FE9
2916:  MOVLW  04
2918:  ADDWF  xCE,W
291A:  MOVWF  FEA
291C:  MOVLW  84
291E:  MOVWF  FEF
....................    } 
....................    else  
2920:  BRA    2936
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
2922:  MOVF   xCB,W
2924:  MULLW  08
2926:  MOVF   FF3,W
2928:  CLRF   xCE
292A:  MOVWF  FE9
292C:  MOVLW  04
292E:  ADDWF  xCE,W
2930:  MOVWF  FEA
2932:  MOVLW  84
2934:  MOVWF  FEF
....................    } 
.................... } 
2936:  MOVLB  0
2938:  GOTO   29CA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
28AA:  MOVLB  2
28AC:  BCF    xCC.0
28AE:  BTFSC  xCB.7
28B0:  BSF    xCC.0
....................    endpoint &= 0x7F; 
28B2:  BCF    xCB.7
....................     
....................    if (direction)  
28B4:  BTFSS  xCC.0
28B6:  BRA    28DA
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
28B8:  MOVF   xCB,W
28BA:  MULLW  08
28BC:  MOVF   FF3,W
28BE:  CLRF   xCE
28C0:  MOVWF  xCD
28C2:  MOVLW  04
28C4:  ADDWF  xCD,F
28C6:  MOVLW  00
28C8:  ADDWFC xCE,F
28CA:  MOVFF  2CD,FE9
28CE:  MOVLW  04
28D0:  ADDWF  xCE,W
28D2:  MOVWF  FEA
28D4:  MOVLW  88
28D6:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
28D8:  BRA    28EC
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
28DA:  MOVF   xCB,W
28DC:  MULLW  08
28DE:  MOVF   FF3,W
28E0:  CLRF   xCE
28E2:  MOVWF  FE9
28E4:  MOVLW  04
28E6:  ADDWF  xCE,W
28E8:  MOVWF  FEA
28EA:  CLRF   FEF
....................    } 
.................... } 
28EC:  MOVLB  0
28EE:  GOTO   29BA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
293C:  MOVLB  2
293E:  BCF    xCC.0
2940:  BTFSC  xCB.7
2942:  BSF    xCC.0
....................    endpoint &= 0x7F; 
2944:  BCF    xCB.7
....................     
....................    if (direction)  
2946:  BTFSS  xCC.0
2948:  BRA    296C
....................    { 
....................       st=EP_BDxST_I(endpoint); 
294A:  MOVF   xCB,W
294C:  MULLW  08
294E:  MOVF   FF3,W
2950:  CLRF   xCF
2952:  MOVWF  xCE
2954:  MOVLW  04
2956:  ADDWF  xCE,F
2958:  MOVLW  00
295A:  ADDWFC xCF,F
295C:  MOVFF  2CE,FE9
2960:  MOVLW  04
2962:  ADDWF  xCF,W
2964:  MOVWF  FEA
2966:  MOVFF  FEF,2CD
....................    } 
....................    else  
296A:  BRA    2980
....................    { 
....................       st=EP_BDxST_O(endpoint); 
296C:  MOVF   xCB,W
296E:  MULLW  08
2970:  MOVF   FF3,W
2972:  CLRF   xCF
2974:  MOVWF  FE9
2976:  MOVLW  04
2978:  ADDWF  xCF,W
297A:  MOVWF  FEA
297C:  MOVFF  FEF,2CD
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
2980:  BTFSS  xCD.7
2982:  BRA    2988
2984:  BTFSC  xCD.2
2986:  BRA    298C
2988:  MOVLW  00
298A:  BRA    298E
298C:  MOVLW  01
298E:  MOVWF  01
.................... } 
2990:  MOVLB  0
2992:  GOTO   29E2 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
2DA6:  MOVFF  2CC,F6E
....................     
....................    if (address)  
2DAA:  MOVLB  2
2DAC:  MOVF   xCC,F
2DAE:  BZ    2DB6
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
2DB0:  MOVLW  04
2DB2:  MOVWF  2B
....................    } 
....................    else  
2DB4:  BRA    2DBA
....................    { 
....................       usb_state = USB_STATE_POWERED; 
2DB6:  MOVLW  02
2DB8:  MOVWF  2B
....................    } 
.................... } 
2DBA:  MOVLB  0
2DBC:  GOTO   2DCA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
2520:  MOVLB  2
2522:  MOVF   xCB,F
2524:  BNZ   2532
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
2526:  MOVLW  04
2528:  MOVWF  2B
....................       usb_disable_endpoints(); 
252A:  MOVLB  0
252C:  RCALL  2306
....................    } 
....................    else  
252E:  BRA    26EC
2530:  MOVLB  2
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
2532:  MOVLW  05
2534:  MOVWF  2B
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
2536:  MOVLW  04
2538:  MOVWF  xCE
253A:  MOVLW  28
253C:  MOVWF  xCD
....................       for (en=1; en<USB_NUM_UEP; en++)  
253E:  MOVLW  01
2540:  MOVWF  xCC
2542:  MOVF   xCC,W
2544:  SUBLW  0F
2546:  BTFSS  FD8.0
2548:  BRA    26EC
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
254A:  MOVFF  2CC,2D4
254E:  MOVLB  0
2550:  RCALL  22C0
....................          new_uep = 0; 
2552:  MOVLB  2
2554:  CLRF   xCF
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
2556:  CLRF   03
2558:  MOVF   xCC,W
255A:  MOVFF  FF2,2D3
255E:  BCF    FF2.7
2560:  MOVLB  0
2562:  RCALL  20DC
2564:  MOVLB  2
2566:  BTFSC  xD3.7
2568:  BSF    FF2.7
256A:  SUBLW  FF
256C:  BZ    2624
....................          { 
....................             new_uep = 0x04; 
256E:  MOVLW  04
2570:  MOVWF  xCF
....................             len = usb_ep_rx_size[en]; 
2572:  BCF    FD8.0
2574:  RLCF   xCC,W
2576:  CLRF   03
2578:  MOVFF  FF2,2D3
257C:  BCF    FF2.7
257E:  MOVLB  0
2580:  RCALL  212C
2582:  TBLRD*+
2584:  MOVFF  FF5,03
2588:  MOVLB  2
258A:  BTFSC  xD3.7
258C:  BSF    FF2.7
258E:  MOVWF  xD0
2590:  MOVFF  03,2D1
....................             EP_BDxCNT_O(en) = len; 
2594:  MOVF   xCC,W
2596:  MULLW  08
2598:  MOVF   FF3,W
259A:  CLRF   xD4
259C:  MOVWF  xD3
259E:  MOVLW  01
25A0:  ADDWF  xD3,W
25A2:  MOVWF  01
25A4:  MOVLW  00
25A6:  ADDWFC xD4,W
25A8:  MOVWF  03
25AA:  MOVFF  01,FE9
25AE:  MOVLW  04
25B0:  ADDWF  03,W
25B2:  MOVWF  FEA
25B4:  MOVFF  2D0,FEF
....................             EP_BDxADR_O(en) = addy; 
25B8:  MOVF   xCC,W
25BA:  MULLW  08
25BC:  MOVF   FF3,W
25BE:  CLRF   xD4
25C0:  MOVWF  xD3
25C2:  MOVLW  02
25C4:  ADDWF  xD3,W
25C6:  MOVWF  01
25C8:  MOVLW  00
25CA:  ADDWFC xD4,W
25CC:  MOVWF  03
25CE:  MOVFF  01,FE9
25D2:  MOVLW  04
25D4:  ADDWF  03,W
25D6:  MOVWF  FEA
25D8:  MOVFF  2CE,FEC
25DC:  MOVF   FED,F
25DE:  MOVFF  2CD,FEF
....................             addy += usb_ep_rx_size[en]; 
25E2:  BCF    FD8.0
25E4:  RLCF   xCC,W
25E6:  CLRF   03
25E8:  MOVFF  FF2,2D3
25EC:  BCF    FF2.7
25EE:  MOVLB  0
25F0:  RCALL  212C
25F2:  TBLRD*+
25F4:  MOVFF  FF5,03
25F8:  MOVLB  2
25FA:  BTFSC  xD3.7
25FC:  BSF    FF2.7
25FE:  ADDWF  xCD,F
2600:  MOVF   03,W
2602:  ADDWFC xCE,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
2604:  MOVLW  88
2606:  MOVWF  xD2
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
2608:  BTFSC  xD1.0
260A:  BSF    xD2.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
260C:  BTFSC  xD1.1
260E:  BSF    xD2.1
....................             EP_BDxST_O(en) = i; 
2610:  MOVF   xCC,W
2612:  MULLW  08
2614:  MOVF   FF3,W
2616:  CLRF   xD4
2618:  MOVWF  FE9
261A:  MOVLW  04
261C:  ADDWF  xD4,W
261E:  MOVWF  FEA
2620:  MOVFF  2D2,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
2624:  CLRF   03
2626:  MOVF   xCC,W
2628:  MOVFF  FF2,2D3
262C:  BCF    FF2.7
262E:  MOVLB  0
2630:  RCALL  20BC
2632:  MOVLB  2
2634:  BTFSC  xD3.7
2636:  BSF    FF2.7
2638:  SUBLW  FF
263A:  BZ    26B2
....................          { 
....................             new_uep |= 0x02; 
263C:  BSF    xCF.1
....................             EP_BDxADR_I(en) = addy; 
263E:  MOVF   xCC,W
2640:  MULLW  08
2642:  MOVF   FF3,W
2644:  CLRF   xD4
2646:  MOVWF  xD3
2648:  MOVLW  04
264A:  ADDWF  xD3,F
264C:  MOVLW  00
264E:  ADDWFC xD4,F
2650:  MOVLW  02
2652:  ADDWF  xD3,W
2654:  MOVWF  01
2656:  MOVLW  00
2658:  ADDWFC xD4,W
265A:  MOVWF  03
265C:  MOVFF  01,FE9
2660:  MOVLW  04
2662:  ADDWF  03,W
2664:  MOVWF  FEA
2666:  MOVFF  2CE,FEC
266A:  MOVF   FED,F
266C:  MOVFF  2CD,FEF
....................             addy += usb_ep_tx_size[en]; 
2670:  BCF    FD8.0
2672:  RLCF   xCC,W
2674:  CLRF   03
2676:  MOVFF  FF2,2D3
267A:  BCF    FF2.7
267C:  MOVLB  0
267E:  RCALL  20FC
2680:  TBLRD*+
2682:  MOVFF  FF5,03
2686:  MOVLB  2
2688:  BTFSC  xD3.7
268A:  BSF    FF2.7
268C:  ADDWF  xCD,F
268E:  MOVF   03,W
2690:  ADDWFC xCE,F
....................             EP_BDxST_I(en) = 0x40; 
2692:  MOVF   xCC,W
2694:  MULLW  08
2696:  MOVF   FF3,W
2698:  CLRF   xD4
269A:  MOVWF  xD3
269C:  MOVLW  04
269E:  ADDWF  xD3,F
26A0:  MOVLW  00
26A2:  ADDWFC xD4,F
26A4:  MOVFF  2D3,FE9
26A8:  MOVLW  04
26AA:  ADDWF  xD4,W
26AC:  MOVWF  FEA
26AE:  MOVLW  40
26B0:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
26B2:  MOVF   xCF,W
26B4:  SUBLW  06
26B6:  BNZ   26BC
26B8:  MOVLW  0E
26BA:  MOVWF  xCF
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
26BC:  CLRF   03
26BE:  MOVF   xCC,W
26C0:  MOVFF  FF2,2D3
26C4:  BCF    FF2.7
26C6:  MOVLB  0
26C8:  RCALL  20BC
26CA:  MOVLB  2
26CC:  BTFSC  xD3.7
26CE:  BSF    FF2.7
26D0:  SUBLW  01
26D2:  BTFSS  FD8.2
26D4:  BSF    xCF.4
....................           
....................          UEP(en) = new_uep; 
26D6:  CLRF   03
26D8:  MOVF   xCC,W
26DA:  ADDLW  70
26DC:  MOVWF  FE9
26DE:  MOVLW  0F
26E0:  ADDWFC 03,W
26E2:  MOVWF  FEA
26E4:  MOVFF  2CF,FEF
....................       } 
26E8:  INCF   xCC,F
26EA:  BRA    2542
26EC:  MOVLB  0
....................    } 
.................... } 
26EE:  GOTO   2794 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
22C0:  CLRF   03
22C2:  MOVLB  2
22C4:  MOVF   xD4,W
22C6:  ADDLW  70
22C8:  MOVWF  FE9
22CA:  MOVLW  0F
22CC:  ADDWFC 03,W
22CE:  MOVWF  FEA
22D0:  CLRF   FEF
....................    EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
22D2:  MOVF   xD4,W
22D4:  MULLW  08
22D6:  MOVF   FF3,W
22D8:  CLRF   xD6
22DA:  MOVWF  FE9
22DC:  MOVLW  04
22DE:  ADDWF  xD6,W
22E0:  MOVWF  FEA
22E2:  CLRF   FEF
....................    EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
22E4:  MOVF   xD4,W
22E6:  MULLW  08
22E8:  MOVF   FF3,W
22EA:  CLRF   xD6
22EC:  MOVWF  xD5
22EE:  MOVLW  04
22F0:  ADDWF  xD5,F
22F2:  MOVLW  00
22F4:  ADDWFC xD6,F
22F6:  MOVFF  2D5,FE9
22FA:  MOVLW  04
22FC:  ADDWF  xD6,W
22FE:  MOVWF  FEA
2300:  CLRF   FEF
.................... } 
2302:  MOVLB  0
2304:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
2306:  MOVLW  01
2308:  MOVLB  2
230A:  MOVWF  xD3
230C:  MOVF   xD3,W
230E:  SUBLW  0F
2310:  BNC   2320
....................       usb_disable_endpoint(i); 
2312:  MOVFF  2D3,2D4
2316:  MOVLB  0
2318:  RCALL  22C0
231A:  MOVLB  2
231C:  INCF   xD3,F
231E:  BRA    230C
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
2320:  MOVLB  0
2322:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
2376:  BCF    F68.3
.................... } 
2378:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
303C:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
303E:  MOVF   2B,F
3040:  BNZ   3044
3042:  BRA    30C0
....................    if (UIR)  
3044:  MOVF   F68,F
3046:  BZ    30C0
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
3048:  BTFSS  F68.2
304A:  BRA    3054
304C:  BTFSS  F69.2
304E:  BRA    3054
3050:  GOTO   227A
....................  
....................       if (UCON_SUSPND) return; 
3054:  BTFSS  F6D.1
3056:  BRA    305A
3058:  BRA    30C0
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
305A:  BTFSS  F68.5
305C:  BRA    3066
305E:  BTFSS  F69.5
3060:  BRA    3066
3062:  GOTO   22AA
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
3066:  BTFSS  F68.1
3068:  BRA    3072
306A:  BTFSS  F69.1
306C:  BRA    3072
306E:  GOTO   22B8
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
3072:  BTFSS  F68.0
3074:  BRA    307E
3076:  BTFSS  F69.0
3078:  BRA    307E
307A:  GOTO   237A
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
307E:  BTFSS  F68.4
3080:  BRA    308A
3082:  BTFSS  F69.4
3084:  BRA    308A
3086:  GOTO   23A4
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
308A:  BTFSS  F68.6
308C:  BRA    3096
308E:  BTFSS  F69.6
3090:  BRA    3096
3092:  GOTO   23AE
....................  
....................       TRNAttempts = 0; 
3096:  MOVLB  2
3098:  CLRF   xC8
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
309A:  BTFSS  F68.3
309C:  BRA    30B2
309E:  BTFSS  F69.3
30A0:  BRA    30B2
....................          { 
....................             USTATCopy = U1STAT; 
30A2:  MOVFF  F6C,2A
....................             usb_clear_trn(); 
30A6:  MOVLB  0
30A8:  CALL   2376
....................             usb_isr_tok_dne(); 
30AC:  BRA    2EC2
....................          } 
....................          else 
30AE:  BRA    30B4
30B0:  MOVLB  2
....................             break; 
30B2:  BRA    30BE
....................       } while (TRNAttempts++ < 4); 
30B4:  MOVLB  2
30B6:  MOVF   xC8,W
30B8:  INCF   xC8,F
30BA:  SUBLW  03
30BC:  BC    309A
30BE:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
30C0:  GOTO   2058
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
23AE:  BCF    F68.6
.................... } 
23B0:  GOTO   3096 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
237A:  CLRF   F6A
....................    UIR = 0; 
237C:  CLRF   F68
....................    UEIE = 0x9F; 
237E:  MOVLW  9F
2380:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
2382:  MOVLW  3D
2384:  MOVWF  F69
....................  
....................    UADDR = 0; 
2386:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
2388:  RCALL  2306
....................     
....................    usb_token_reset(); 
238A:  BRA    2348
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
238C:  MOVLW  16
238E:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
2390:  BTFSS  F68.3
2392:  BRA    2398
....................       usb_clear_trn(); 
2394:  RCALL  2376
....................    } 
2396:  BRA    2390
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
2398:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
239A:  RCALL  228A
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
239C:  MOVLW  03
239E:  MOVWF  2B
.................... } 
23A0:  GOTO   307E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
228A:  MOVLW  08
228C:  MOVLB  4
228E:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
2290:  MOVLW  04
2292:  MOVWF  x03
2294:  MOVLW  18
2296:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
2298:  MOVLW  88
229A:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
229C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
229E:  MOVLW  04
22A0:  MOVWF  x07
22A2:  MOVLW  20
22A4:  MOVWF  x06
.................... } 
22A6:  MOVLB  0
22A8:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
22B8:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
22BA:  BCF    F68.1
.................... } 
22BC:  GOTO   3072 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
23A4:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
23A6:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
23A8:  BSF    F6D.1
.................... } 
23AA:  GOTO   308A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
227A:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
227C:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
227E:  BTFSS  F68.2
2280:  BRA    2286
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
2282:  BCF    F68.2
....................    } 
2284:  BRA    227E
.................... } 
2286:  GOTO   3054 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
22AA:  BTFSS  F70.0
22AC:  BRA    22B2
....................    { 
....................       usb_init_ep0_setup(); 
22AE:  RCALL  228A
....................       bit_clear(UEP(0), 0); 
22B0:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
22B2:  BCF    F68.5
.................... } 
22B4:  GOTO   3066 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
23B4:  MOVFF  2CE,2C
23B8:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
2A00:  MOVLW  FE
2A02:  MOVWF  2C
2A04:  RETLW  00
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
23BA:  MOVLW  FF
23BC:  MOVWF  2C
23BE:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
2EC2:  RRCF   2A,W
2EC4:  MOVLB  2
2EC6:  MOVWF  xC9
2EC8:  RRCF   xC9,F
2ECA:  RRCF   xC9,F
2ECC:  MOVLW  1F
2ECE:  ANDWF  xC9,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
2ED0:  MOVF   2A,F
2ED2:  BNZ   2F72
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
2ED4:  MOVLB  4
2ED6:  MOVF   x00,W
2ED8:  ANDLW  3C
2EDA:  MOVLB  2
2EDC:  MOVWF  xCA
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
2EDE:  MOVLW  43
2EE0:  MOVLB  4
2EE2:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
2EE4:  MOVLB  2
2EE6:  MOVF   xCA,W
2EE8:  SUBLW  34
2EEA:  BNZ   2F36
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
2EEC:  MOVLB  4
2EEE:  MOVF   x04,W
2EF0:  ANDLW  80
2EF2:  BZ    2EF6
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
2EF4:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
2EF6:  MOVLB  0
2EF8:  BRA    2AB4
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
2EFA:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
2EFC:  INCFSZ 2C,W
2EFE:  BRA    2F0E
....................             usb_flush_out(0, USB_DTS_STALL); 
2F00:  MOVLB  2
2F02:  CLRF   xCB
2F04:  MOVLW  03
2F06:  MOVWF  xCC
2F08:  MOVLB  0
2F0A:  RCALL  2AE6
....................          else  
2F0C:  BRA    2F32
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
2F0E:  MOVLB  2
2F10:  CLRF   xCB
2F12:  MOVLW  02
2F14:  MOVWF  xCC
2F16:  MOVLB  0
2F18:  RCALL  2AE6
....................             if (__setup_0_tx_size != 0xFE) 
2F1A:  MOVF   2C,W
2F1C:  SUBLW  FE
2F1E:  BZ    2F32
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
2F20:  MOVLB  2
2F22:  CLRF   xD4
2F24:  CLRF   xD6
2F26:  MOVFF  2C,2D5
2F2A:  MOVLW  04
2F2C:  MOVWF  xD7
2F2E:  MOVLB  0
2F30:  RCALL  2BF4
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
2F32:  BRA    2F6E
2F34:  MOVLB  2
2F36:  MOVF   xCA,W
2F38:  SUBLW  04
2F3A:  BNZ   2F70
....................       { 
....................          usb_isr_tok_out_dne(0); 
2F3C:  CLRF   xCB
2F3E:  MOVLB  0
2F40:  RCALL  2D88
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
2F42:  MOVLB  2
2F44:  CLRF   xCB
2F46:  MOVLW  02
2F48:  MOVWF  xCC
2F4A:  MOVLB  0
2F4C:  RCALL  2AE6
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
2F4E:  MOVF   2C,W
2F50:  SUBLW  FE
2F52:  BZ    2F6C
2F54:  INCFSZ 2C,W
2F56:  BRA    2F5A
2F58:  BRA    2F6C
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
2F5A:  MOVLB  2
2F5C:  CLRF   xD4
2F5E:  CLRF   xD6
2F60:  MOVFF  2C,2D5
2F64:  MOVLW  01
2F66:  MOVWF  xD7
2F68:  MOVLB  0
2F6A:  RCALL  2BF4
....................          } 
....................       } 
....................       else 
2F6C:  BRA    2F6E
2F6E:  MOVLB  2
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
2F70:  BRA    3036
2F72:  MOVF   2A,W
2F74:  SUBLW  04
2F76:  BNZ   2FA8
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
2F78:  MOVLW  43
2F7A:  MOVLB  4
2F7C:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
2F7E:  MOVLW  FF
2F80:  MOVWF  2C
....................       usb_isr_tok_in_dne(0); 
2F82:  MOVLB  2
2F84:  CLRF   xCB
2F86:  MOVLB  0
2F88:  RCALL  2E90
....................       if (__setup_0_tx_size!=0xFF) 
2F8A:  INCFSZ 2C,W
2F8C:  BRA    2F90
2F8E:  BRA    2FA4
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
2F90:  MOVLB  2
2F92:  CLRF   xD4
2F94:  CLRF   xD6
2F96:  MOVFF  2C,2D5
2F9A:  MOVLW  02
2F9C:  MOVWF  xD7
2F9E:  MOVLB  0
2FA0:  RCALL  2BF4
....................       else 
2FA2:  BRA    2FA4
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
2FA4:  BRA    3034
2FA6:  MOVLB  2
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
2FA8:  BTFSC  2A.2
2FAA:  BRA    2FE6
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
2FAC:  MOVF   xC9,W
2FAE:  MULLW  08
2FB0:  MOVF   FF3,W
2FB2:  CLRF   xCC
2FB4:  MOVWF  01
2FB6:  MOVLW  04
2FB8:  ADDWF  xCC,W
2FBA:  MOVWF  03
2FBC:  MOVF   xC9,W
2FBE:  MULLW  08
2FC0:  MOVF   FF3,W
2FC2:  CLRF   xCE
2FC4:  MOVWF  FE9
2FC6:  MOVLW  04
2FC8:  ADDWF  xCE,W
2FCA:  MOVWF  FEA
2FCC:  MOVF   FEF,W
2FCE:  ANDLW  43
2FD0:  MOVFF  03,FEA
2FD4:  MOVFF  01,FE9
2FD8:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
2FDA:  MOVFF  2C9,2CB
2FDE:  MOVLB  0
2FE0:  RCALL  2D88
....................       } 
....................       else  
2FE2:  BRA    3034
2FE4:  MOVLB  2
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
2FE6:  MOVF   xC9,W
2FE8:  MULLW  08
2FEA:  MOVF   FF3,W
2FEC:  CLRF   xCC
2FEE:  MOVWF  xCB
2FF0:  MOVLW  04
2FF2:  ADDWF  xCB,F
2FF4:  MOVLW  00
2FF6:  ADDWFC xCC,F
2FF8:  MOVFF  2CB,01
2FFC:  MOVLW  04
2FFE:  ADDWF  xCC,W
3000:  MOVWF  03
3002:  MOVF   xC9,W
3004:  MULLW  08
3006:  MOVF   FF3,W
3008:  CLRF   xCE
300A:  MOVWF  xCD
300C:  MOVLW  04
300E:  ADDWF  xCD,F
3010:  MOVLW  00
3012:  ADDWFC xCE,F
3014:  MOVFF  2CD,FE9
3018:  MOVLW  04
301A:  ADDWF  xCE,W
301C:  MOVWF  FEA
301E:  MOVF   FEF,W
3020:  ANDLW  43
3022:  MOVFF  03,FEA
3026:  MOVFF  2CB,FE9
302A:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
302C:  MOVFF  2C9,2CB
3030:  MOVLB  0
3032:  RCALL  2E90
3034:  MOVLB  2
....................       } 
....................    } 
.................... } 
3036:  MOVLB  0
3038:  GOTO   30AE (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
2348:  MOVLB  2
234A:  CLRF   xC9
234C:  MOVF   xC9,W
234E:  SUBLW  01
2350:  BNC   2366
....................       USB_Interface[i] = 0;   //reset each interface to default 
2352:  CLRF   03
2354:  MOVF   xC9,W
2356:  ADDLW  30
2358:  MOVWF  FE9
235A:  MOVLW  00
235C:  ADDWFC 03,W
235E:  MOVWF  FEA
2360:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
2362:  INCF   xC9,F
2364:  BRA    234C
....................    usb_cdc_init(); 
2366:  MOVLB  0
2368:  BRA    2324
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
236A:  CLRF   27
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
236C:  MOVLW  01
236E:  MOVWF  28
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
2370:  CLRF   26
.................... } 
2372:  GOTO   238C (RETURN)
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
2850:  MOVLB  2
2852:  BCF    xCC.0
2854:  BTFSC  xCB.7
2856:  BSF    xCC.0
....................    endpoint &= 0x7F; 
2858:  BCF    xCB.7
....................    if (direction) { //IN 
285A:  BTFSS  xCC.0
285C:  BRA    2882
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
285E:  CLRF   03
2860:  MOVF   xCB,W
2862:  MOVFF  FF2,2CD
2866:  BCF    FF2.7
2868:  MOVLB  0
286A:  RCALL  20BC
286C:  MOVLB  2
286E:  BTFSC  xCD.7
2870:  BSF    FF2.7
2872:  SUBLW  FF
2874:  BNZ   287A
2876:  MOVLW  00
2878:  BRA    287C
287A:  MOVLW  01
287C:  MOVWF  01
287E:  BRA    28A4
....................    } 
....................    else {   //OUT 
2880:  BRA    28A4
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
2882:  CLRF   03
2884:  MOVF   xCB,W
2886:  MOVFF  FF2,2CD
288A:  BCF    FF2.7
288C:  MOVLB  0
288E:  RCALL  20DC
2890:  MOVLB  2
2892:  BTFSC  xCD.7
2894:  BSF    FF2.7
2896:  SUBLW  FF
2898:  BNZ   289E
289A:  MOVLW  00
289C:  BRA    28A0
289E:  MOVLW  01
28A0:  MOVWF  01
28A2:  BRA    28A4
....................    } 
.................... } 
28A4:  MOVLB  0
28A6:  GOTO   299C (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
2E90:  MOVLB  2
2E92:  MOVF   xCB,F
2E94:  BNZ   2EB2
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
2E96:  DECFSZ 26,W
2E98:  BRA    2EA4
2E9A:  MOVLB  0
2E9C:  CALL   23C0
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
2EA0:  BRA    2EAE
2EA2:  MOVLB  2
2EA4:  MOVF   26,W
2EA6:  SUBLW  02
2EA8:  BNZ   2EB0
2EAA:  MOVLB  0
2EAC:  BRA    2DC0
2EAE:  MOVLB  2
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
2EB0:  BRA    2EBE
2EB2:  MOVF   xCB,W
2EB4:  SUBLW  02
2EB6:  BNZ   2EBE
....................       usb_isr_tok_in_cdc_data_dne(); 
2EB8:  MOVLB  0
2EBA:  BRA    2E86
2EBC:  MOVLB  2
....................   } 
....................   #endif 
.................... } 
2EBE:  MOVLB  0
2EC0:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2D88:  MOVLB  2
2D8A:  MOVF   xCB,F
2D8C:  BNZ   2D96
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
2D8E:  MOVLB  0
2D90:  BRA    2CD0
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
2D92:  BRA    2DA0
2D94:  MOVLB  2
2D96:  MOVF   xCB,W
2D98:  SUBLW  02
2D9A:  BNZ   2DA2
....................       usb_isr_tok_out_cdc_data_dne(); 
2D9C:  MOVLB  0
2D9E:  BRA    2D72
2DA0:  MOVLB  2
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
2DA2:  MOVLB  0
2DA4:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
2AB4:  CLRF   26
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
2AB6:  MOVLB  4
2AB8:  MOVF   x18,W
2ABA:  ANDLW  7F
2ABC:  MOVLB  0
2ABE:  BZ    2ACE
2AC0:  XORLW  01
2AC2:  BZ    2AD2
2AC4:  XORLW  03
2AC6:  BZ    2AD6
2AC8:  XORLW  23
2ACA:  BZ    2ADA
2ACC:  BRA    2ADE
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
2ACE:  BRA    26F2
....................          break; 
2AD0:  BRA    2AE2
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
2AD2:  BRA    27A8
....................          break; 
2AD4:  BRA    2AE2
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
2AD6:  BRA    2996
....................          break; 
2AD8:  BRA    2AE2
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
2ADA:  BRA    2A06
....................          break; 
2ADC:  BRA    2AE2
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
2ADE:  RCALL  23BA
....................          break; 
2AE0:  BRA    2AE2
....................    } 
.................... } 
2AE2:  GOTO   2EFA (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
26F2:  MOVLB  4
26F4:  MOVF   x19,W
26F6:  MOVLB  0
26F8:  BZ    2714
26FA:  XORLW  01
26FC:  BZ    2728
26FE:  XORLW  02
2700:  BZ    2742
2702:  XORLW  06
2704:  BZ    275A
2706:  XORLW  03
2708:  BZ    276C
270A:  XORLW  0E
270C:  BZ    2770
270E:  XORLW  01
2710:  BZ    2780
2712:  BRA    27A0
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
2714:  MOVFF  28,420
....................             usb_ep0_tx_buffer[1]=0; 
2718:  MOVLB  4
271A:  CLRF   x21
....................             usb_request_send_response(2); 
271C:  MOVLW  02
271E:  MOVLB  2
2720:  MOVWF  xCE
2722:  MOVLB  0
2724:  RCALL  23B4
....................             break; 
2726:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
2728:  MOVLB  4
272A:  DECFSZ x1A,W
272C:  BRA    273C
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
272E:  MOVLW  01
2730:  ANDWF  28,F
....................                usb_put_0len_0(); 
2732:  MOVLB  2
2734:  CLRF   xCE
2736:  MOVLB  0
2738:  RCALL  23B4
....................             } 
....................             else 
273A:  BRA    2740
....................                usb_request_stall(); 
273C:  MOVLB  0
273E:  RCALL  23BA
....................             break; 
2740:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
2742:  MOVLB  4
2744:  DECFSZ x1A,W
2746:  BRA    2754
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
2748:  BSF    28.1
....................                usb_put_0len_0(); 
274A:  MOVLB  2
274C:  CLRF   xCE
274E:  MOVLB  0
2750:  RCALL  23B4
....................             } 
....................             else 
2752:  BRA    2758
....................                usb_request_stall(); 
2754:  MOVLB  0
2756:  RCALL  23BA
....................             break; 
2758:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
275A:  MOVLW  02
275C:  MOVWF  26
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
275E:  MOVFF  41A,2D
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
2762:  MOVLB  2
2764:  CLRF   xCE
2766:  MOVLB  0
2768:  RCALL  23B4
....................             break; 
276A:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
276C:  BRA    2460
....................             break; 
276E:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
2770:  MOVFF  27,420
....................             usb_request_send_response(1); 
2774:  MOVLW  01
2776:  MOVLB  2
2778:  MOVWF  xCE
277A:  MOVLB  0
277C:  RCALL  23B4
....................             break; 
277E:  BRA    27A4
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
2780:  MOVLB  4
2782:  MOVF   x1A,W
2784:  SUBLW  01
2786:  BNC   279C
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
2788:  MOVFF  41A,27
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
278C:  MOVFF  41A,2CB
2790:  MOVLB  0
2792:  BRA    2520
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
2794:  MOVLB  2
2796:  CLRF   xCE
2798:  MOVLB  0
279A:  RCALL  23B4
....................             } 
....................             break; 
279C:  MOVLB  0
279E:  BRA    27A4
....................  
....................       default: 
....................             usb_request_stall(); 
27A0:  RCALL  23BA
....................             break; 
27A2:  BRA    27A4
....................    } 
.................... } 
27A4:  GOTO   2AE2 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
27A8:  MOVFF  27,2CB
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
27AC:  MOVLB  4
27AE:  MOVF   x19,W
27B0:  MOVLB  0
27B2:  BZ    27BE
27B4:  XORLW  0A
27B6:  BZ    27D0
27B8:  XORLW  01
27BA:  BZ    281E
27BC:  BRA    2848
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
27BE:  MOVLB  4
27C0:  CLRF   x20
....................             usb_ep0_tx_buffer[1]=0; 
27C2:  CLRF   x21
....................             usb_request_send_response(2); 
27C4:  MOVLW  02
27C6:  MOVLB  2
27C8:  MOVWF  xCE
27CA:  MOVLB  0
27CC:  RCALL  23B4
....................             break; 
27CE:  BRA    284C
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
27D0:  MOVLB  2
27D2:  MOVF   xCB,F
27D4:  BZ    2818
27D6:  MOVLW  01
27D8:  SUBWF  xCB,W
27DA:  CLRF   03
27DC:  MOVFF  FF2,2CC
27E0:  BCF    FF2.7
27E2:  MOVLB  0
27E4:  RCALL  21B0
27E6:  MOVLB  2
27E8:  BTFSC  xCC.7
27EA:  BSF    FF2.7
27EC:  MOVWF  01
27EE:  MOVLB  4
27F0:  SUBWF  x1C,W
27F2:  BTFSS  FD8.0
27F4:  BRA    27FA
27F6:  MOVLB  2
27F8:  BRA    2818
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
27FA:  CLRF   03
27FC:  MOVF   x1C,W
27FE:  ADDLW  30
2800:  MOVWF  FE9
2802:  MOVLW  00
2804:  ADDWFC 03,W
2806:  MOVWF  FEA
2808:  MOVFF  FEF,420
....................                usb_request_send_response(1);; //send byte back 
280C:  MOVLW  01
280E:  MOVLB  2
2810:  MOVWF  xCE
2812:  MOVLB  0
2814:  RCALL  23B4
....................             } 
....................             else 
2816:  BRA    281C
....................                usb_request_stall(); 
2818:  MOVLB  0
281A:  RCALL  23BA
....................             break; 
281C:  BRA    284C
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
281E:  MOVLB  2
2820:  MOVF   xCB,F
2822:  BZ    2842
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
2824:  CLRF   03
2826:  MOVLB  4
2828:  MOVF   x1C,W
282A:  ADDLW  30
282C:  MOVWF  FE9
282E:  MOVLW  00
2830:  ADDWFC 03,W
2832:  MOVWF  FEA
2834:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
2838:  MOVLB  2
283A:  CLRF   xCE
283C:  MOVLB  0
283E:  RCALL  23B4
....................             } 
....................             else 
2840:  BRA    2846
....................                usb_request_stall(); 
2842:  MOVLB  0
2844:  RCALL  23BA
....................             break; 
2846:  BRA    284C
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
2848:  RCALL  23BA
....................             break; 
284A:  BRA    284C
....................    } 
.................... } 
284C:  GOTO   2AE2 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
2996:  MOVFF  41C,2CB
299A:  BRA    2850
299C:  MOVF   01,F
299E:  BZ    29FC
....................       switch(usb_ep0_rx_buffer[1]) { 
29A0:  MOVLB  4
29A2:  MOVF   x19,W
29A4:  XORLW  01
29A6:  MOVLB  0
29A8:  BZ    29B4
29AA:  XORLW  02
29AC:  BZ    29C4
29AE:  XORLW  03
29B0:  BZ    29D4
29B2:  BRA    29F8
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
29B4:  MOVFF  41C,2CB
29B8:  BRA    28AA
....................                usb_put_0len_0(); 
29BA:  MOVLB  2
29BC:  CLRF   xCE
29BE:  MOVLB  0
29C0:  RCALL  23B4
....................                break; 
29C2:  BRA    29FC
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
29C4:  MOVFF  41C,2CB
29C8:  BRA    28F2
....................                      usb_put_0len_0(); 
29CA:  MOVLB  2
29CC:  CLRF   xCE
29CE:  MOVLB  0
29D0:  RCALL  23B4
....................                      break; 
29D2:  BRA    29FC
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
29D4:  MOVLB  4
29D6:  CLRF   x20
....................                usb_ep0_tx_buffer[1]=0; 
29D8:  CLRF   x21
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
29DA:  MOVFF  41C,2CB
29DE:  MOVLB  0
29E0:  BRA    293C
29E2:  MOVF   01,F
29E4:  BZ    29EC
....................                   usb_ep0_tx_buffer[0]=1; 
29E6:  MOVLW  01
29E8:  MOVLB  4
29EA:  MOVWF  x20
....................                } 
....................                usb_request_send_response(2); 
29EC:  MOVLW  02
29EE:  MOVLB  2
29F0:  MOVWF  xCE
29F2:  MOVLB  0
29F4:  RCALL  23B4
....................                break; 
29F6:  BRA    29FC
....................  
....................          default: 
....................             usb_request_stall(); 
29F8:  RCALL  23BA
....................             break; 
29FA:  BRA    29FC
....................       } 
....................    } 
.................... } 
29FC:  GOTO   2AE2 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
2460:  CLRF   2E
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
2462:  CLRF   29
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
2464:  MOVLB  4
2466:  MOVF   x1B,W
2468:  XORLW  01
246A:  MOVLB  0
246C:  BZ    247C
246E:  XORLW  03
2470:  BZ    2486
2472:  XORLW  01
2474:  BZ    248C
2476:  XORLW  22
2478:  BZ    24BE
247A:  BRA    2500
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
247C:  MOVLW  12
247E:  MOVWF  2F
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
2480:  MOVLW  03
2482:  MOVWF  29
....................             break; 
2484:  BRA    2504
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
2486:  MOVLW  43
2488:  MOVWF  2F
....................             break; 
248A:  BRA    2504
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
248C:  MOVLW  02
248E:  MOVWF  29
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
2490:  CLRF   03
2492:  MOVLB  4
2494:  MOVF   x1A,W
2496:  ADDLW  22
2498:  MOVWF  FE9
249A:  MOVLW  00
249C:  ADDWFC 03,W
249E:  MOVWF  FEA
24A0:  MOVFF  FEF,2E
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
24A4:  CLRF   03
24A6:  MOVF   2E,W
24A8:  MOVFF  FF2,2CB
24AC:  BCF    FF2.7
24AE:  MOVLB  0
24B0:  RCALL  21FC
24B2:  MOVLB  2
24B4:  BTFSC  xCB.7
24B6:  BSF    FF2.7
24B8:  MOVWF  2F
....................             break; 
24BA:  MOVLB  0
24BC:  BRA    2504
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
24BE:  CLRF   03
24C0:  MOVLB  4
24C2:  MOVF   x1A,W
24C4:  MOVFF  FF2,2CB
24C8:  BCF    FF2.7
24CA:  MOVLB  0
24CC:  RCALL  21C2
24CE:  MOVLB  2
24D0:  BTFSC  xCB.7
24D2:  BSF    FF2.7
24D4:  MOVWF  2E
....................             if (usb_getdesc_ptr!=0xFF) { 
24D6:  INCFSZ 2E,W
24D8:  BRA    24DC
24DA:  BRA    24FA
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
24DC:  CLRF   03
24DE:  MOVF   2E,W
24E0:  MOVFF  FF2,2CB
24E4:  BCF    FF2.7
24E6:  MOVLB  0
24E8:  RCALL  215C
24EA:  MOVLB  2
24EC:  BTFSC  xCB.7
24EE:  BSF    FF2.7
24F0:  MOVWF  2F
....................                break; 
24F2:  MOVLB  0
24F4:  BRA    2504
....................             } 
....................             else { 
24F6:  BRA    2500
24F8:  MOVLB  2
....................                usb_request_stall(); 
24FA:  MOVLB  0
24FC:  RCALL  23BA
....................                return; 
24FE:  BRA    251C
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
2500:  RCALL  23BA
....................             return; 
2502:  BRA    251C
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
2504:  MOVLB  4
2506:  MOVF   x1F,F
2508:  BNZ   2514
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
250A:  MOVF   2F,W
250C:  SUBWF  x1E,W
250E:  BC    2514
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
2510:  MOVFF  41E,2F
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
2514:  MOVLW  01
2516:  MOVWF  26
....................    usb_copy_desc_seg_to_ep(); 
2518:  MOVLB  0
251A:  RCALL  23C0
.................... } 
251C:  GOTO   27A4 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
2DC0:  CLRF   27
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
2DC2:  CLRF   26
....................    usb_set_address(USB_address_pending); 
2DC4:  MOVFF  2D,2CC
2DC8:  BRA    2DA6
....................    #endif 
.................... } 
2DCA:  GOTO   2EAE (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    unsigned int i=0; 
*
23C0:  MOVLB  2
23C2:  CLRF   xCC
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
23C4:  MOVF   2F,F
23C6:  BZ    244A
23C8:  MOVF   xCC,W
23CA:  SUBLW  07
23CC:  BNC   244A
....................       switch(USB_stack_status.getdesc_type) { 
23CE:  MOVF   29,W
23D0:  MOVLB  0
23D2:  BZ    23DE
23D4:  XORLW  02
23D6:  BZ    23F6
23D8:  XORLW  01
23DA:  BZ    240E
23DC:  BRA    2426
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
23DE:  CLRF   03
23E0:  MOVF   2E,W
23E2:  MOVFF  FF2,2CE
23E6:  BCF    FF2.7
23E8:  RCALL  215C
23EA:  MOVLB  2
23EC:  BTFSC  xCE.7
23EE:  BSF    FF2.7
23F0:  MOVWF  xCD
....................             break; 
23F2:  MOVLB  0
23F4:  BRA    2426
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
23F6:  CLRF   03
23F8:  MOVF   2E,W
23FA:  MOVFF  FF2,2CE
23FE:  BCF    FF2.7
2400:  RCALL  21FC
2402:  MOVLB  2
2404:  BTFSC  xCE.7
2406:  BSF    FF2.7
2408:  MOVWF  xCD
....................             break; 
240A:  MOVLB  0
240C:  BRA    2426
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
240E:  CLRF   03
2410:  MOVF   2E,W
2412:  MOVFF  FF2,2CE
2416:  BCF    FF2.7
2418:  RCALL  21DA
241A:  MOVLB  2
241C:  BTFSC  xCE.7
241E:  BSF    FF2.7
2420:  MOVWF  xCD
....................             break; 
2422:  MOVLB  0
2424:  BRA    2426
....................       } 
....................       usb_getdesc_ptr++; 
2426:  INCF   2E,F
....................       usb_getdesc_len--; 
2428:  DECF   2F,F
....................       usb_ep0_tx_buffer[i++]=c; 
242A:  MOVLB  2
242C:  MOVF   xCC,W
242E:  INCF   xCC,F
2430:  CLRF   03
2432:  ADDLW  20
2434:  MOVWF  01
2436:  MOVLW  00
2438:  ADDWFC 03,F
243A:  MOVFF  01,FE9
243E:  MOVLW  04
2440:  ADDWF  03,W
2442:  MOVWF  FEA
2444:  MOVFF  2CD,FEF
....................    } 
2448:  BRA    23C4
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
244A:  MOVF   2F,F
244C:  BNZ   2456
244E:  MOVF   xCC,W
2450:  SUBLW  08
2452:  BZ    2456
....................          USB_stack_status.dev_req = NONE; 
2454:  CLRF   26
....................    } 
....................  
....................    usb_request_send_response(i); 
2456:  MOVFF  2CC,2CE
245A:  MOVLB  0
245C:  RCALL  23B4
.................... } 
245E:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  unsigned int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... unsigned int8 g_LastCDCDataPacketSize; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
2CD0:  MOVF   x89,W
2CD2:  XORLW  01
2CD4:  BZ    2CE0
2CD6:  XORLW  02
2CD8:  BZ    2D02
2CDA:  XORLW  01
2CDC:  BZ    2D10
2CDE:  BRA    2D38
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
2CE0:  CLRF   FEA
2CE2:  MOVLW  3B
2CE4:  MOVWF  FE9
2CE6:  MOVLW  04
2CE8:  MOVWF  FE2
2CEA:  MOVLW  18
2CEC:  MOVWF  FE1
2CEE:  MOVLW  08
2CF0:  MOVWF  01
2CF2:  MOVFF  FE6,FEE
2CF6:  DECFSZ 01,F
2CF8:  BRA    2CF2
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
2CFA:  MOVLW  03
2CFC:  MOVWF  x89
....................          usb_request_get_data(); 
2CFE:  RCALL  2A00
....................         #else 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................         #endif 
....................          break; 
2D00:  BRA    2D3C
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
2D02:  MOVLB  2
2D04:  CLRF   xCE
2D06:  MOVLB  0
2D08:  CALL   23B4
....................          __usb_cdc_state=0; 
2D0C:  CLRF   x89
....................          break; 
2D0E:  BRA    2D3C
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
2D10:  CLRF   FEA
2D12:  MOVLW  32
2D14:  MOVWF  FE9
2D16:  MOVLW  04
2D18:  MOVWF  FE2
2D1A:  MOVLW  18
2D1C:  MOVWF  FE1
2D1E:  MOVLW  07
2D20:  MOVWF  01
2D22:  MOVFF  FE6,FEE
2D26:  DECFSZ 01,F
2D28:  BRA    2D22
....................          __usb_cdc_state=0; 
2D2A:  CLRF   x89
....................          usb_put_0len_0(); 
2D2C:  MOVLB  2
2D2E:  CLRF   xCE
2D30:  MOVLB  0
2D32:  CALL   23B4
....................          break; 
2D36:  BRA    2D3C
....................  
....................       default: 
....................          __usb_cdc_state=0; 
2D38:  CLRF   x89
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
2D3A:  BRA    2D3C
....................    } 
.................... } 
2D3C:  GOTO   2D92 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
2A06:  MOVLB  4
2A08:  DECFSZ x1C,W
2A0A:  BRA    2A0E
2A0C:  BRA    2A12
2A0E:  MOVF   x1C,F
2A10:  BNZ   2AAE
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
2A12:  MOVF   x19,W
2A14:  MOVLB  0
2A16:  BZ    2A2E
2A18:  XORLW  01
2A1A:  BZ    2A36
2A1C:  XORLW  21
2A1E:  BZ    2A58
2A20:  XORLW  01
2A22:  BZ    2A62
2A24:  XORLW  03
2A26:  BZ    2A88
2A28:  XORLW  01
2A2A:  BZ    2A96
2A2C:  BRA    2AA8
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
2A2E:  MOVLW  01
2A30:  MOVWF  x89
....................             usb_request_get_data(); 
2A32:  RCALL  2A00
....................             break; 
2A34:  BRA    2AAC
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
2A36:  MOVLW  04
2A38:  MOVWF  FEA
2A3A:  MOVLW  20
2A3C:  MOVWF  FE9
2A3E:  CLRF   FE2
2A40:  MOVLW  3B
2A42:  MOVWF  FE1
2A44:  MOVLW  08
2A46:  MOVWF  01
2A48:  MOVFF  FE6,FEE
2A4C:  DECFSZ 01,F
2A4E:  BRA    2A48
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
2A50:  MOVFF  41E,2CE
2A54:  RCALL  23B4
....................             break; 
2A56:  BRA    2AAC
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
2A58:  MOVLW  02
2A5A:  MOVWF  x89
....................             usb_cdc_got_set_line_coding=TRUE; 
2A5C:  BSF    x86.0
....................             usb_request_get_data(); 
2A5E:  RCALL  2A00
....................             break; 
2A60:  BRA    2AAC
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
2A62:  MOVLW  04
2A64:  MOVWF  FEA
2A66:  MOVLW  20
2A68:  MOVWF  FE9
2A6A:  CLRF   FE2
2A6C:  MOVLW  32
2A6E:  MOVWF  FE1
2A70:  MOVLW  07
2A72:  MOVWF  01
2A74:  MOVFF  FE6,FEE
2A78:  DECFSZ 01,F
2A7A:  BRA    2A74
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
2A7C:  MOVLW  07
2A7E:  MOVLB  2
2A80:  MOVWF  xCE
2A82:  MOVLB  0
2A84:  RCALL  23B4
....................             break; 
2A86:  BRA    2AAC
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
2A88:  MOVFF  41A,87
....................             usb_put_0len_0(); 
2A8C:  MOVLB  2
2A8E:  CLRF   xCE
2A90:  MOVLB  0
2A92:  RCALL  23B4
....................             break; 
2A94:  BRA    2AAC
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
2A96:  MOVFF  41A,3A
2A9A:  MOVFF  41B,39
....................             usb_put_0len_0(); 
2A9E:  MOVLB  2
2AA0:  CLRF   xCE
2AA2:  MOVLB  0
2AA4:  RCALL  23B4
....................             break; 
2AA6:  BRA    2AAC
....................  
....................          default: 
....................             usb_request_stall(); 
2AA8:  RCALL  23BA
....................             break; 
2AAA:  BRA    2AAC
2AAC:  MOVLB  4
....................       } 
....................    } 
.................... } 
2AAE:  MOVLB  0
2AB0:  GOTO   2AE2 (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
2D72:  BSF    x83.0
....................    usb_cdc_get_buffer_status.index=0; 
2D74:  CLRF   x85
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
2D76:  MOVLW  02
2D78:  MOVLB  2
2D7A:  MOVWF  xCC
2D7C:  MOVLB  0
2D7E:  BRA    2D40
2D80:  MOVFF  01,84
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
2D84:  GOTO   2DA0 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    //putc('!'); 
....................    if (usb_cdc_put_buffer_nextin /* || (g_LastCDCDataPacketSize == USB_CDC_DATA_IN_SIZE)*/ )  
*
2E86:  MOVF   x82,F
2E88:  BZ    2E8C
....................    { 
....................       //printf("FL3 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
2E8A:  BRA    2E62
....................    } 
.................... } 
2E8C:  GOTO   2EBC (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................    usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
*
2E62:  MOVLW  02
2E64:  MOVLB  2
2E66:  MOVWF  xCC
2E68:  CLRF   xCE
2E6A:  MOVLW  43
2E6C:  MOVWF  xCD
2E6E:  CLRF   xD0
2E70:  MOVFF  82,2CF
2E74:  MOVLW  02
2E76:  MOVWF  xD1
2E78:  MOVLB  0
2E7A:  BRA    2DCE
....................    g_LastCDCDataPacketSize = usb_cdc_put_buffer_nextin; 
2E7C:  MOVFF  82,88
....................    usb_cdc_put_buffer_nextin=0; 
2E80:  CLRF   x82
.................... } 
2E82:  GOTO   2E8C (RETURN)
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
2324:  CLRF   35
2326:  CLRF   34
2328:  MOVLW  25
232A:  MOVWF  33
232C:  MOVLW  80
232E:  MOVWF  32
....................    usb_cdc_line_coding.bCharFormat = 0; 
2330:  CLRF   36
....................    usb_cdc_line_coding.bParityType = 0; 
2332:  CLRF   37
....................    usb_cdc_line_coding.bDataBits = 8; 
2334:  MOVLW  08
2336:  MOVWF  38
....................    (int8)usb_cdc_carrier = 0; 
2338:  CLRF   x87
....................    usb_cdc_got_set_line_coding = FALSE; 
233A:  BCF    x86.0
....................    usb_cdc_break = 0; 
233C:  CLRF   3A
233E:  CLRF   39
....................    usb_cdc_put_buffer_nextin = 0; 
2340:  CLRF   x82
....................    usb_cdc_get_buffer_status.got = 0; 
2342:  BCF    x83.0
.................... } 
2344:  GOTO   236A (RETURN)
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
....................    { 
....................       usb_cdc_get_discard(); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c)  
.................... { 
....................  #if defined(__PCH__) 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie = INT_GIE; 
....................    INT_GIE = 0; 
....................  #else 
....................    int16 oldSR; 
....................     
....................    oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
....................  
....................    //renable global interrupts 
....................   #if defined(__PCH__) 
....................    INT_GIE = old_gie; 
....................   #else 
....................    SR = oldSR; 
....................   #endif 
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free()) { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c)  
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
.................... } 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... //configuramos el puerto  
....................    #use rs232(UART1, baud=9600, XMIT=PIN_C6, RCV=PIN_C7, DISABLE_INTS) 
*
32C0:  BTFSS  F9E.4
32C2:  BRA    32C0
32C4:  MOVLB  2
32C6:  MOVFF  2B1,FAD
32CA:  MOVLB  0
32CC:  RETLW  00
32CE:  BTFSS  F9E.5
32D0:  BRA    32CE
32D2:  MOVFF  FAB,8A
32D6:  MOVFF  FAE,01
32DA:  BTFSS  x8A.1
32DC:  BRA    32E2
32DE:  BCF    FAB.4
32E0:  BSF    FAB.4
32E2:  GOTO   3336 (RETURN)
....................    #define ON                 output_high    // DEFINE COMO OUTPUT_HIGH A ON 
....................    #define OFF                output_low     //DEFINE COMO OUTPUT_LOW A OFF 
....................     
....................    unsigned char dato[250];             //CREAMOS LA VARIABLES CONTENEDORAS DE 250 BYTES 
....................    int1 act_lcd = 0; 
....................    char c,nombre;                   
....................    unsigned int band1,l; 
....................    UNSIGNED INT32 k; 
....................    unsigned int16 j=1; 
....................    long d; 
....................    long menuC[12][12]={"SCS","ECS","IPA","IPH","SBD-DIVISOR","FWV","E","e","DIR","CLF","salir"};//LEAMOS EL MENU DE COMANDOS PARA DESPLEGAR 
....................     
....................    
....................      
.................... void put_enter(){putc(0x0D);}          //lista comandos de configuracion del vdrive 
.................... VOID PUT_SCS(){putc(0x10);PUTC(0X0D);} //Switches to the shortened command set 
.................... VOID PUT_ECS(){putc(0x11);PUTC(0X0D);} //Switches to the extended command set 
.................... VOID PUT_IPA(){putc(0x90);PUTC(0X0D);} //Input numbers in ASCII 
.................... VOID PUT_IPH(){putc(0x91);PUTC(0X0D);} //Input numbers in HEX 
.................... //VOID PUT_SBS(){putc(0x14);PUTC(0x20);PUTC(VB1);PUTC(VB2);PUTC(VB3);PUTC(0X0D);} 
.................... VOID PUT_FWV(){putc(0x13);PUTC(0X0D);} //DEVUELVE LA VERSION DE FIRMWARE 
.................... VOID P_E(){putc(0x45);PUTC(0X0D);}     //DEVUELVE UNA E SE USA PARA SINCRONIZAR 
.................... VOID PUT_e(){putc(0x65);PUTC(0X0D);}   //DEVUELVE UNA e SE USA PARA SINCRONIZAR 
....................  
....................  
.................... VOID PUT_DIR(){putc(0x01);PUTC(0X0D);}                                          //DEVUELVE EL DIRECTORIO DE LA MEMORIA FLASH 
.................... VOID PUT_DIR_FILE(){PUTC(0x01);PUTC(0x20);PUTC(0x0D);}                          //DEVUELVE EL ARCHIVO SOLICITADO Y SU TAMAÑO 
.................... VOID PUT_CD_FILE(){PUTC(0x02);PUTC(0x20);PUTC(0x0D);}                           // ABRE UN DIRECTORIO 
.................... VOID PUT_CD_(){PUTC(0x02);PUTC(0x20);PUTC(0x2E);PUTC(0x2E);PUTC(0x0D);}         //CIERRA UN NIVEL DE DIRECTORIO 
.................... VOID PUT_RD_FILE(){PUTC(0x04);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c); 
....................                   PUTC(0x41);PUTC(0x2e);PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);}//LEE EL CONTENIDO COMPLETO DE UN ARCHIVO 
.................... VOID PUT_DLD_FILE(){PUTC(0x05);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c);PUTC(0x41);PUTC(0x2e); 
....................                   PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);}                     // BORRA EL SUBDIRECTORIO 
.................... VOID PUT_MKD_FILE(){PUTC(0x06);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c);PUTC(0x41);PUTC(0x2e); 
....................                    PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);}                   //CREA UN DIRECTORIO 
.................... VOID PUT_DLF_FILE(){PUTC(0x07);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c);PUTC(0x41);PUTC(0x2e); 
....................                    PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);}                  //BORRA UN ARCHIVO 
.................... VOID PUT_WRF(UNSIGNED INT BYTE3,BYTE2,BYTE1,BYTE0){ PUTC(0x08);PUTC(0x20);PUTC(BYTE3);PUTC(BYTE2);PUTC(BYTE1);PUTC(BYTE0);PUTC(0x0D);} // ESCRIBE EN EL ARCHIVO EL NUMERO BYTES ESPESIFCADO POR NB 
.................... VOID PUT_RDF(UNSIGNED INT BYTE3,BYTE2,BYTE1,BYTE0){PUTC(0x0B);PUTC(0x20);PUTC(BYTE3);PUTC(BYTE2);PUTC(BYTE1);PUTC(BYTE0); PUTC(0x0D);} 
.................... VOID PUT_OPR_FILE(){PUTC(0x0E);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c);PUTC(0x41);PUTC(0x2e); 
....................                    PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);} 
.................... VOID PUT_OPW_FILE(){PUTC(0x09);PUTC(0x20); putc(0x48);putc(0x4f);putC(0x4c);PUTC(0x41);PUTC(0x2e); 
....................                    PUTC(0x54);PUTC(0x58);PUTC(0x54); PUTC(0x0D);}                 
....................                     
.................... VOID PUT_CLF(CHAR NOMBRE) {printf("CLF %s\r",NOMBRE);} 
....................  
.................... // RUTINA PARA OBTENER EL DATO DEL PUERTO SERIAL 
.................... VOID ObtenerDato(void)       
.................... {  j=1;k=0;                             
32E6:  MOVLB  1
32E8:  CLRF   x8E
32EA:  MOVLW  01
32EC:  MOVWF  x8D
32EE:  CLRF   x8C
32F0:  CLRF   x8B
32F2:  CLRF   x8A
32F4:  CLRF   x89
....................    while(j!=0) 
....................    { 
32F6:  MOVF   x8D,F
32F8:  BNZ   32FE
32FA:  MOVF   x8E,F
32FC:  BZ    337E
....................       While(!kbhit()){j++; delay_us(40);if(j>=50000){j=0;break;}} //COMIENZA UN DELAY  POCO MAYOR A 2 S  EN ESPERA 
32FE:  BTFSC  F9E.5
3300:  BRA    332A
3302:  INCF   x8D,F
3304:  BTFSC  FD8.2
3306:  INCF   x8E,F
3308:  MOVLW  9F
330A:  MOVWF  00
330C:  DECFSZ 00,F
330E:  BRA    330C
3310:  BRA    3312
3312:  MOVF   x8E,W
3314:  SUBLW  C2
3316:  BC    3328
3318:  XORLW  FF
331A:  BNZ   3322
331C:  MOVF   x8D,W
331E:  SUBLW  4F
3320:  BC    3328
3322:  CLRF   x8E
3324:  CLRF   x8D
3326:  BRA    332A
3328:  BRA    32FE
....................       if(j!=0)                                                     //SI SE VENCE EL DELAY Y NO LLEGÓ DATO SE SALE 
332A:  MOVF   x8D,F
332C:  BNZ   3332
332E:  MOVF   x8E,F
3330:  BZ    337C
....................       {                                                              
....................       c=getc(); 
3332:  MOVLB  0
3334:  BRA    32CE
3336:  MOVFF  01,185
....................       if(c!='\r'){dato[k]=c;  k++; dato[k]=0; act_lcd=1; j=1;}       // SI LLEGO DATO SE ALMACENA EN DATO 
333A:  MOVLB  1
333C:  MOVF   x85,W
333E:  SUBLW  0D
3340:  BZ    337C
3342:  MOVLW  8B
3344:  ADDWF  x89,W
3346:  MOVWF  FE9
3348:  MOVLW  00
334A:  ADDWFC x8A,W
334C:  MOVWF  FEA
334E:  MOVFF  185,FEF
3352:  MOVLW  01
3354:  ADDWF  x89,F
3356:  BTFSC  FD8.0
3358:  INCF   x8A,F
335A:  BTFSC  FD8.2
335C:  INCF   x8B,F
335E:  BTFSC  FD8.2
3360:  INCF   x8C,F
3362:  MOVLW  8B
3364:  ADDWF  x89,W
3366:  MOVWF  FE9
3368:  MOVLW  00
336A:  ADDWFC x8A,W
336C:  MOVWF  FEA
336E:  CLRF   FEF
3370:  MOVLB  0
3372:  BSF    x86.1
3374:  MOVLB  1
3376:  CLRF   x8E
3378:  MOVLW  01
337A:  MOVWF  x8D
....................       } 
....................    }               
337C:  BRA    32F6
....................                   
....................  }    
337E:  MOVLB  0
3380:  RETLW  00
....................  
.................... // RUTINA EJEMPLO PARA INTRODUCIR COMANDOS CORTOS AL VDRIVE DESDE EL MICRO 
....................  
.................... void menu_config() 
.................... { 
....................    char L1=1; 
....................    char L2=1; 
....................    printf(lcd_putc,"\fmenu de config");    //SE NOTIFICA QUE A ENTRADO AL MENU DE CONFIGURACION 
....................    printf(lcd_putc,"\nA3 alux  A1 PC");    // SE PIDE AL USUARIO UNA DECISION DE ENTRADA DE COMANDOS 
....................    delay_ms(500);                          //DESDE LA PC O DESDE  LA TARJETA ALUX   
....................    while((INPUT(PIN_A1))&&(INPUT(PIN_A3))){};// ESPERA INDEFINIDAMENTE UNA RESPUESTA  
....................    IF(!INPUT(PIN_A1)) GOTO PC;               // SI SE HA SELECCIONADO PC SE HACE UN SALTO A LA RUTINA DE EN CUESTION 
....................    l=0;                                     // SI SE HA SELECCIONADO ALUX 
....................    while((input(PIN_A1))||(input(PIN_A3)))   //CONDION PARA SALIR DE MENU CONFIG   
....................    { 
....................       d = menuC[l];  
....................       printf(lcd_putc,"\n     %s",d);                                                  // SE INICIA LA RUTINA DEL MENU DESDE EL ALUX 
....................       if((!input(PIN_A5))&&(l==0)){PUT_SCS(); ObtenerDato();Display_Dato(DATO,300);}   //SE AVANZA EN LOS COMANDOS CON A1 
....................       if((!input(PIN_A5))&&(l==1)){PUT_ECS(); ObtenerDato();Display_Dato(DATO,300);}   //DE FORMA CICLICA Y SE DEFINE A A5 COMO ENTER 
....................       if((!input(PIN_A5))&&(l==2)){PUT_IPA(); ObtenerDato();Display_Dato(DATO,300);}   //DESPUES DE ENVIAR EL COMANDO SE LANZA LA RUTINA 
....................       if((!input(PIN_A5))&&(l==3)){PUT_IPH(); ObtenerDato();Display_Dato(DATO,300);}   //OBTENER DATO PARA CAPTURAR EL SUCESO ENVIADO POR  
....................       if((!input(PIN_A5))&&(l==5)){PUT_FWV(); ObtenerDato();Display_Dato(DATO,300);}   //EL MONITOR DE COMANDOS Y LA RUTINA DISPLAY DATO 
....................       if((!input(PIN_A5))&&(l==6)){P_E(); ObtenerDato();Display_Dato(DATO,300);}       // LEER EL SUCESO 
....................       if((!input(PIN_A5))&&(l==7)){PUT_e(); ObtenerDato();Display_Dato(DATO,300);} 
....................       if((!input(PIN_A5))&&(l==8)){PUT_DIR(); ObtenerDato();Display_Dato(DATO,300);} 
....................       if((!input(PIN_A5))&&(l==9)){PUT_CLF("HOLA2.TXT"); ObtenerDato();Display_Dato(DATO,300);} 
....................       if((!input(PIN_A5))&&(l==10)){break;} 
....................                 
....................       if (!input(PIN_A1)) {                                          
....................                            delay_ms(300);                                                                
....................                            if (l>9) {l=0;} else { l++;} 
....................                            printf(lcd_putc,"\n                ");                    } 
....................     } 
....................    GOTO FIN; 
....................  
....................    PC:   // INICIA LA RUTINA PARA INTRODUCIR DATOS DESDE EL PC 
....................    while((input(PIN_A1))||(input(PIN_A3)))    // CONDICION PARA SALIR DE MENU CONFIG 
....................    { 
....................      usb_task();           // SE INICIALIZA LA CONEXION USB CON LA PC 
....................       //**********************************************************************// 
....................       // SE RECIBE CARACTERES DE RESPUESTA DEL VDRIVE                         // 
....................       //**********************************************************************// 
....................        
....................       if (kbhit()) {                   //SE RECIBIO UN CARACTER DEL VDRIVE... 
....................            
....................          c=getc();                     //SE ALMACENA EN C 
....................           
....................          if (c=='\r') {                //SE RECIBIO FINAL DEL COMANDO 
....................             usb_cdc_putc("\r\n");      //ENVIAR A LA PC UN SALTO DE LINEA 
....................             L2=1; 
....................          } 
....................          else { 
....................             usb_cdc_putc(c);           //ENVIAR C A LA PC 
....................             if (L2==1) printf(LCD_PUTC,"\n                ");  //LIMPIA LINEA 2 
....................             lcd_gotoxy(L2++,2);        //ENVIA EL CURSOR AL INICIO DE LA LINEA 2 
....................             if (c==0x5C) c=0;          //SUSTITUYE CARACTER 0x5C POR EL 0 
....................             printf(LCD_PUTC,"%c",c);   //ENVIA AL LCD EL CARACTER C           
....................          } 
....................       } 
....................           
....................       //**********************************************************************// 
....................       // SE ENVIAN CARACTERES DE COMANDO AL VDRIVE                            // 
....................       //**********************************************************************// 
....................   
....................       if (usb_cdc_kbhit())  
....................       {                                  //SE RECIBIO UN CARACTER DE LA PC... 
....................          c=usb_cdc_getc();             //SE ALMACENA EN C 
....................          if (c!='\n')  
....................          { 
....................            putc(c);  
....................            if (c=='\r')  
....................            { 
....................               L1=1; 
....................             } 
....................             else  
....................              { 
....................                if (L1==1) printf(LCD_PUTC,"\f");  //BORRA TODO 
....................                lcd_gotoxy(L1++,1); 
....................                printf(LCD_PUTC,"%c",c); 
....................             } 
....................            } 
....................       } 
....................        
....................       //**********************************************************************// 
....................       // FINAL DE LAS RUTINAS                                                 // 
....................       //**********************************************************************// 
....................        
....................    } 
....................  usb_detach(); 
....................  
....................  FIN: 
.................... BREAK; 
.................... } 
.................... // INICIA PROGRAMA PRINCIPAL 
....................  
.................... void main(void)    //INICIO DE PROGRAMA 
.................... { 
*
349E:  CLRF   FF8
34A0:  BCF    FD0.7
34A2:  BSF    08.7
34A4:  CLRF   FEA
34A6:  CLRF   FE9
34A8:  BSF    FB8.3
34AA:  MOVLW  E1
34AC:  MOVWF  FAF
34AE:  MOVLW  04
34B0:  MOVWF  FB0
34B2:  MOVLW  A6
34B4:  MOVWF  FAC
34B6:  MOVLW  90
34B8:  MOVWF  FAB
34BA:  MOVF   FC1,W
34BC:  ANDLW  C0
34BE:  IORLW  0F
34C0:  MOVWF  FC1
34C2:  MOVLW  07
34C4:  MOVWF  FB4
34C6:  CLRF   18
34C8:  CLRF   19
34CA:  CLRF   1A
34CC:  MOVLW  10
34CE:  MOVWF  1B
34D0:  MOVLW  08
34D2:  MOVWF  1C
34D4:  MOVLW  04
34D6:  MOVWF  1D
34D8:  MOVLW  02
34DA:  MOVWF  1E
34DC:  MOVLW  01
34DE:  MOVWF  1F
34E0:  CLRF   20
34E2:  CLRF   21
34E4:  CLRF   22
34E6:  MOVLW  04
34E8:  MOVWF  23
34EA:  MOVLW  0C
34EC:  MOVWF  24
34EE:  CLRF   2B
34F0:  CLRF   2F
34F2:  CLRF   x82
34F4:  CLRF   x89
34F6:  CLRF   x8A
34F8:  BCF    x86.1
34FA:  MOVLW  01
34FC:  MOVLB  1
34FE:  MOVWF  x8D
3500:  CLRF   x8E
3502:  MOVLW  53
3504:  MOVWF  x91
3506:  MOVLW  43
3508:  MOVWF  x92
350A:  MOVLW  53
350C:  MOVWF  x93
350E:  CLRF   x94
3510:  CLRF   x95
3512:  CLRF   x96
3514:  CLRF   x97
3516:  CLRF   x98
3518:  CLRF   x99
351A:  CLRF   x9A
351C:  CLRF   x9B
351E:  CLRF   x9C
3520:  CLRF   x9D
3522:  CLRF   x9E
3524:  CLRF   x9F
3526:  CLRF   xA0
3528:  CLRF   xA1
352A:  CLRF   xA2
352C:  CLRF   xA3
352E:  CLRF   xA4
3530:  CLRF   xA5
3532:  CLRF   xA6
3534:  CLRF   xA7
3536:  CLRF   xA8
3538:  MOVLW  45
353A:  MOVWF  xA9
353C:  MOVLW  43
353E:  MOVWF  xAA
3540:  MOVLW  53
3542:  MOVWF  xAB
3544:  CLRF   xAC
3546:  CLRF   xAD
3548:  CLRF   xAE
354A:  CLRF   xAF
354C:  CLRF   xB0
354E:  CLRF   xB1
3550:  CLRF   xB2
3552:  CLRF   xB3
3554:  CLRF   xB4
3556:  CLRF   xB5
3558:  CLRF   xB6
355A:  CLRF   xB7
355C:  CLRF   xB8
355E:  CLRF   xB9
3560:  CLRF   xBA
3562:  CLRF   xBB
3564:  CLRF   xBC
3566:  CLRF   xBD
3568:  CLRF   xBE
356A:  CLRF   xBF
356C:  CLRF   xC0
356E:  MOVLW  49
3570:  MOVWF  xC1
3572:  MOVLW  50
3574:  MOVWF  xC2
3576:  MOVLW  41
3578:  MOVWF  xC3
357A:  CLRF   xC4
357C:  CLRF   xC5
357E:  CLRF   xC6
3580:  CLRF   xC7
3582:  CLRF   xC8
3584:  CLRF   xC9
3586:  CLRF   xCA
3588:  CLRF   xCB
358A:  CLRF   xCC
358C:  CLRF   xCD
358E:  CLRF   xCE
3590:  CLRF   xCF
3592:  CLRF   xD0
3594:  CLRF   xD1
3596:  CLRF   xD2
3598:  CLRF   xD3
359A:  CLRF   xD4
359C:  CLRF   xD5
359E:  CLRF   xD6
35A0:  CLRF   xD7
35A2:  CLRF   xD8
35A4:  MOVLW  49
35A6:  MOVWF  xD9
35A8:  MOVLW  50
35AA:  MOVWF  xDA
35AC:  MOVLW  48
35AE:  MOVWF  xDB
35B0:  CLRF   xDC
35B2:  CLRF   xDD
35B4:  CLRF   xDE
35B6:  CLRF   xDF
35B8:  CLRF   xE0
35BA:  CLRF   xE1
35BC:  CLRF   xE2
35BE:  CLRF   xE3
35C0:  CLRF   xE4
35C2:  CLRF   xE5
35C4:  CLRF   xE6
35C6:  CLRF   xE7
35C8:  CLRF   xE8
35CA:  CLRF   xE9
35CC:  CLRF   xEA
35CE:  CLRF   xEB
35D0:  CLRF   xEC
35D2:  CLRF   xED
35D4:  CLRF   xEE
35D6:  CLRF   xEF
35D8:  CLRF   xF0
35DA:  MOVLW  53
35DC:  MOVWF  xF1
35DE:  MOVLW  42
35E0:  MOVWF  xF2
35E2:  MOVLW  44
35E4:  MOVWF  xF3
35E6:  MOVLW  2D
35E8:  MOVWF  xF4
35EA:  MOVLW  44
35EC:  MOVWF  xF5
35EE:  MOVLW  49
35F0:  MOVWF  xF6
35F2:  MOVLW  56
35F4:  MOVWF  xF7
35F6:  MOVLW  49
35F8:  MOVWF  xF8
35FA:  MOVLW  53
35FC:  MOVWF  xF9
35FE:  MOVLW  4F
3600:  MOVWF  xFA
3602:  MOVLW  52
3604:  MOVWF  xFB
3606:  CLRF   xFC
3608:  CLRF   xFD
360A:  CLRF   xFE
360C:  CLRF   xFF
360E:  MOVLB  2
3610:  CLRF   x00
3612:  CLRF   x01
3614:  CLRF   x02
3616:  CLRF   x03
3618:  CLRF   x04
361A:  CLRF   x05
361C:  CLRF   x06
361E:  CLRF   x07
3620:  CLRF   x08
3622:  MOVLW  46
3624:  MOVWF  x09
3626:  MOVLW  57
3628:  MOVWF  x0A
362A:  MOVLW  56
362C:  MOVWF  x0B
362E:  CLRF   x0C
3630:  CLRF   x0D
3632:  CLRF   x0E
3634:  CLRF   x0F
3636:  CLRF   x10
3638:  CLRF   x11
363A:  CLRF   x12
363C:  CLRF   x13
363E:  CLRF   x14
3640:  CLRF   x15
3642:  CLRF   x16
3644:  CLRF   x17
3646:  CLRF   x18
3648:  CLRF   x19
364A:  CLRF   x1A
364C:  CLRF   x1B
364E:  CLRF   x1C
3650:  CLRF   x1D
3652:  CLRF   x1E
3654:  CLRF   x1F
3656:  CLRF   x20
3658:  MOVLW  45
365A:  MOVWF  x21
365C:  CLRF   x22
365E:  CLRF   x23
3660:  CLRF   x24
3662:  CLRF   x25
3664:  CLRF   x26
3666:  CLRF   x27
3668:  CLRF   x28
366A:  CLRF   x29
366C:  CLRF   x2A
366E:  CLRF   x2B
3670:  CLRF   x2C
3672:  CLRF   x2D
3674:  CLRF   x2E
3676:  CLRF   x2F
3678:  CLRF   x30
367A:  CLRF   x31
367C:  CLRF   x32
367E:  CLRF   x33
3680:  CLRF   x34
3682:  CLRF   x35
3684:  CLRF   x36
3686:  CLRF   x37
3688:  CLRF   x38
368A:  MOVLW  65
368C:  MOVWF  x39
368E:  CLRF   x3A
3690:  CLRF   x3B
3692:  CLRF   x3C
3694:  CLRF   x3D
3696:  CLRF   x3E
3698:  CLRF   x3F
369A:  CLRF   x40
369C:  CLRF   x41
369E:  CLRF   x42
36A0:  CLRF   x43
36A2:  CLRF   x44
36A4:  CLRF   x45
36A6:  CLRF   x46
36A8:  CLRF   x47
36AA:  CLRF   x48
36AC:  CLRF   x49
36AE:  CLRF   x4A
36B0:  CLRF   x4B
36B2:  CLRF   x4C
36B4:  CLRF   x4D
36B6:  CLRF   x4E
36B8:  CLRF   x4F
36BA:  CLRF   x50
36BC:  MOVLW  44
36BE:  MOVWF  x51
36C0:  MOVLW  49
36C2:  MOVWF  x52
36C4:  MOVLW  52
36C6:  MOVWF  x53
36C8:  CLRF   x54
36CA:  CLRF   x55
36CC:  CLRF   x56
36CE:  CLRF   x57
36D0:  CLRF   x58
36D2:  CLRF   x59
36D4:  CLRF   x5A
36D6:  CLRF   x5B
36D8:  CLRF   x5C
36DA:  CLRF   x5D
36DC:  CLRF   x5E
36DE:  CLRF   x5F
36E0:  CLRF   x60
36E2:  CLRF   x61
36E4:  CLRF   x62
36E6:  CLRF   x63
36E8:  CLRF   x64
36EA:  CLRF   x65
36EC:  CLRF   x66
36EE:  CLRF   x67
36F0:  CLRF   x68
36F2:  MOVLW  43
36F4:  MOVWF  x69
36F6:  MOVLW  4C
36F8:  MOVWF  x6A
36FA:  MOVLW  46
36FC:  MOVWF  x6B
36FE:  CLRF   x6C
3700:  CLRF   x6D
3702:  CLRF   x6E
3704:  CLRF   x6F
3706:  CLRF   x70
3708:  CLRF   x71
370A:  CLRF   x72
370C:  CLRF   x73
370E:  CLRF   x74
3710:  CLRF   x75
3712:  CLRF   x76
3714:  CLRF   x77
3716:  CLRF   x78
3718:  CLRF   x79
371A:  CLRF   x7A
371C:  CLRF   x7B
371E:  CLRF   x7C
3720:  CLRF   x7D
3722:  CLRF   x7E
3724:  CLRF   x7F
3726:  CLRF   x80
3728:  MOVLW  73
372A:  MOVWF  x81
372C:  MOVLW  61
372E:  MOVWF  x82
3730:  MOVLW  6C
3732:  MOVWF  x83
3734:  MOVLW  69
3736:  MOVWF  x84
3738:  MOVLW  72
373A:  MOVWF  x85
373C:  CLRF   x86
373E:  CLRF   x87
3740:  CLRF   x88
3742:  CLRF   x89
3744:  CLRF   x8A
3746:  CLRF   x8B
3748:  CLRF   x8C
374A:  CLRF   x8D
374C:  CLRF   x8E
374E:  CLRF   x8F
3750:  CLRF   x90
3752:  CLRF   x91
3754:  CLRF   x92
3756:  CLRF   x93
3758:  CLRF   x94
375A:  CLRF   x95
375C:  CLRF   x96
375E:  CLRF   x97
3760:  CLRF   x98
3762:  CLRF   x99
3764:  CLRF   x9A
3766:  CLRF   x9B
3768:  CLRF   x9C
376A:  CLRF   x9D
376C:  CLRF   x9E
376E:  CLRF   x9F
3770:  CLRF   xA0
3772:  CLRF   xA1
3774:  CLRF   xA2
3776:  CLRF   xA3
3778:  CLRF   xA4
377A:  CLRF   xA5
377C:  CLRF   xA6
377E:  CLRF   xA7
3780:  CLRF   xA8
3782:  CLRF   xA9
3784:  CLRF   xAA
3786:  CLRF   xAB
3788:  CLRF   xAC
378A:  CLRF   xAD
378C:  CLRF   xAE
378E:  CLRF   xAF
3790:  CLRF   xB0
....................    lcd_init(); 
3792:  MOVLB  0
3794:  BRA    31AE
....................    printf(lcd_putc,"\fPRUEBA 01"); 
3796:  MOVLB  2
3798:  CLRF   xB1
379A:  MOVF   xB1,W
379C:  MOVLB  0
379E:  CALL   2230
37A2:  MOVLB  2
37A4:  INCF   xB1,F
37A6:  MOVWF  00
37A8:  MOVWF  xBE
37AA:  MOVLB  0
37AC:  RCALL  3252
37AE:  MOVLW  0A
37B0:  MOVLB  2
37B2:  SUBWF  xB1,W
37B4:  BNZ   379A
.................... // PRINTF("SCS\r"); 
....................   PUTC(0x11); 
37B6:  MOVLW  11
37B8:  MOVWF  xB1
37BA:  MOVLB  0
37BC:  RCALL  32C0
....................   PUTC(0x0D); 
37BE:  MOVLW  0D
37C0:  MOVLB  2
37C2:  MOVWF  xB1
37C4:  MOVLB  0
37C6:  RCALL  32C0
....................   obtenerDato(); 
37C8:  RCALL  32E6
....................   display_dato(dato,500); 
37CA:  MOVLB  2
37CC:  CLRF   xB2
37CE:  MOVLW  8B
37D0:  MOVWF  xB1
37D2:  MOVLW  01
37D4:  MOVWF  xB4
37D6:  MOVLW  F4
37D8:  MOVWF  xB3
37DA:  MOVLB  0
37DC:  RCALL  33BE
....................   PUTC(0x91); 
37DE:  MOVLW  91
37E0:  MOVLB  2
37E2:  MOVWF  xB1
37E4:  MOVLB  0
37E6:  RCALL  32C0
....................   PUTC(0x0D); 
37E8:  MOVLW  0D
37EA:  MOVLB  2
37EC:  MOVWF  xB1
37EE:  MOVLB  0
37F0:  RCALL  32C0
....................   obtenerDato(); 
37F2:  RCALL  32E6
....................   display_dato(dato,500); 
37F4:  MOVLB  2
37F6:  CLRF   xB2
37F8:  MOVLW  8B
37FA:  MOVWF  xB1
37FC:  MOVLW  01
37FE:  MOVWF  xB4
3800:  MOVLW  F4
3802:  MOVWF  xB3
3804:  MOVLB  0
3806:  RCALL  33BE
....................   PUTC(0x09); 
3808:  MOVLW  09
380A:  MOVLB  2
380C:  MOVWF  xB1
380E:  MOVLB  0
3810:  RCALL  32C0
....................   PUTC(0x20); 
3812:  MOVLW  20
3814:  MOVLB  2
3816:  MOVWF  xB1
3818:  MOVLB  0
381A:  RCALL  32C0
....................   delay_ms(1); 
381C:  MOVLW  01
381E:  MOVLB  2
3820:  MOVWF  xBF
3822:  MOVLB  0
3824:  RCALL  30C4
....................   PUTC(0x48);PUTC(0x4F);PUTC(0X4C);PUTC(0x41);PUTC(0x2E);PUTC(0x54);PUTC(0x58);PUTC(0x54); 
3826:  MOVLW  48
3828:  MOVLB  2
382A:  MOVWF  xB1
382C:  MOVLB  0
382E:  RCALL  32C0
3830:  MOVLW  4F
3832:  MOVLB  2
3834:  MOVWF  xB1
3836:  MOVLB  0
3838:  RCALL  32C0
383A:  MOVLW  4C
383C:  MOVLB  2
383E:  MOVWF  xB1
3840:  MOVLB  0
3842:  RCALL  32C0
3844:  MOVLW  41
3846:  MOVLB  2
3848:  MOVWF  xB1
384A:  MOVLB  0
384C:  RCALL  32C0
384E:  MOVLW  2E
3850:  MOVLB  2
3852:  MOVWF  xB1
3854:  MOVLB  0
3856:  RCALL  32C0
3858:  MOVLW  54
385A:  MOVLB  2
385C:  MOVWF  xB1
385E:  MOVLB  0
3860:  RCALL  32C0
3862:  MOVLW  58
3864:  MOVLB  2
3866:  MOVWF  xB1
3868:  MOVLB  0
386A:  RCALL  32C0
386C:  MOVLW  54
386E:  MOVLB  2
3870:  MOVWF  xB1
3872:  MOVLB  0
3874:  RCALL  32C0
....................   PUTC(0x0D); 
3876:  MOVLW  0D
3878:  MOVLB  2
387A:  MOVWF  xB1
387C:  MOVLB  0
387E:  RCALL  32C0
....................   obtenerDato(); 
3880:  RCALL  32E6
....................   display_dato(dato,500); 
3882:  MOVLB  2
3884:  CLRF   xB2
3886:  MOVLW  8B
3888:  MOVWF  xB1
388A:  MOVLW  01
388C:  MOVWF  xB4
388E:  MOVLW  F4
3890:  MOVWF  xB3
3892:  MOVLB  0
3894:  RCALL  33BE
....................   PUTC(0X08);  
3896:  MOVLW  08
3898:  MOVLB  2
389A:  MOVWF  xB1
389C:  MOVLB  0
389E:  RCALL  32C0
....................   PUTC(0X20);  
38A0:  MOVLW  20
38A2:  MOVLB  2
38A4:  MOVWF  xB1
38A6:  MOVLB  0
38A8:  RCALL  32C0
....................   PUTC(0X4F); 
38AA:  MOVLW  4F
38AC:  MOVLB  2
38AE:  MOVWF  xB1
38B0:  MOVLB  0
38B2:  RCALL  32C0
....................   obtenerDato(); 
38B4:  RCALL  32E6
....................   display_dato(dato,500); 
38B6:  MOVLB  2
38B8:  CLRF   xB2
38BA:  MOVLW  8B
38BC:  MOVWF  xB1
38BE:  MOVLW  01
38C0:  MOVWF  xB4
38C2:  MOVLW  F4
38C4:  MOVWF  xB3
38C6:  MOVLB  0
38C8:  RCALL  33BE
....................   PUTC(0x0A); 
38CA:  MOVLW  0A
38CC:  MOVLB  2
38CE:  MOVWF  xB1
38D0:  MOVLB  0
38D2:  RCALL  32C0
....................   PUTC(0x20); 
38D4:  MOVLW  20
38D6:  MOVLB  2
38D8:  MOVWF  xB1
38DA:  MOVLB  0
38DC:  RCALL  32C0
....................   delay_ms(1); 
38DE:  MOVLW  01
38E0:  MOVLB  2
38E2:  MOVWF  xBF
38E4:  MOVLB  0
38E6:  CALL   30C4
....................   PUTC(0X48);PUTC(0x4F);PUTC(0X4C);PUTC(0x41);PUTC(0x2E);PUTC(0x54);PUTC(0x58);PUTC(0x54); 
38EA:  MOVLW  48
38EC:  MOVLB  2
38EE:  MOVWF  xB1
38F0:  MOVLB  0
38F2:  RCALL  32C0
38F4:  MOVLW  4F
38F6:  MOVLB  2
38F8:  MOVWF  xB1
38FA:  MOVLB  0
38FC:  RCALL  32C0
38FE:  MOVLW  4C
3900:  MOVLB  2
3902:  MOVWF  xB1
3904:  MOVLB  0
3906:  RCALL  32C0
3908:  MOVLW  41
390A:  MOVLB  2
390C:  MOVWF  xB1
390E:  MOVLB  0
3910:  RCALL  32C0
3912:  MOVLW  2E
3914:  MOVLB  2
3916:  MOVWF  xB1
3918:  MOVLB  0
391A:  RCALL  32C0
391C:  MOVLW  54
391E:  MOVLB  2
3920:  MOVWF  xB1
3922:  MOVLB  0
3924:  RCALL  32C0
3926:  MOVLW  58
3928:  MOVLB  2
392A:  MOVWF  xB1
392C:  MOVLB  0
392E:  RCALL  32C0
3930:  MOVLW  54
3932:  MOVLB  2
3934:  MOVWF  xB1
3936:  MOVLB  0
3938:  RCALL  32C0
....................   PUTC(0x0D); 
393A:  MOVLW  0D
393C:  MOVLB  2
393E:  MOVWF  xB1
3940:  MOVLB  0
3942:  RCALL  32C0
....................      obtenerDato(); 
3944:  RCALL  32E6
....................   display_dato(dato,500); 
3946:  MOVLB  2
3948:  CLRF   xB2
394A:  MOVLW  8B
394C:  MOVWF  xB1
394E:  MOVLW  01
3950:  MOVWF  xB4
3952:  MOVLW  F4
3954:  MOVWF  xB3
3956:  MOVLB  0
3958:  RCALL  33BE
....................   printf(lcd_putc,"\fCORRECTO"); 
395A:  MOVLB  2
395C:  CLRF   xB1
395E:  MOVF   xB1,W
3960:  MOVLB  0
3962:  CALL   2256
3966:  MOVLB  2
3968:  INCF   xB1,F
396A:  MOVWF  00
396C:  MOVWF  xBE
396E:  MOVLB  0
3970:  RCALL  3252
3972:  MOVLW  09
3974:  MOVLB  2
3976:  SUBWF  xB1,W
3978:  BNZ   395E
....................   PUTC(0x12);  
397A:  MOVLW  12
397C:  MOVWF  xB1
397E:  MOVLB  0
3980:  RCALL  32C0
....................   PUTC(0x0D); 
3982:  MOVLW  0D
3984:  MOVLB  2
3986:  MOVWF  xB1
3988:  MOVLB  0
398A:  RCALL  32C0
....................   obtenerDato(); 
398C:  RCALL  32E6
....................   display_Dato(dato,500); 
398E:  MOVLB  2
3990:  CLRF   xB2
3992:  MOVLW  8B
3994:  MOVWF  xB1
3996:  MOVLW  01
3998:  MOVWF  xB4
399A:  MOVLW  F4
399C:  MOVWF  xB3
399E:  MOVLB  0
39A0:  RCALL  33BE
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
39A2:  SLEEP 

Configuration Fuses:
   Word  1: 0E21   NOIESO NOFCMEN HSPLL PLL2 USBDIV CPUDIV1
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8100   NOPBADEN CCP2C1 NOLPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C007   NOPROTECT NOCPD NOCPB
   Word  6: E007   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 4007   NOEBTR NOEBTRB
