CCS PCH C Compiler, Version 4.099, 49659               18-feb-11 20:03

               Filename: D:\CURSO 2011\Entrada y Salida de Datos por Ethernet\PIC Ethernet WebServer\ex15.lst

               ROM used: 28596 bytes (87%)
                         Largest free fragment is 4170
               RAM used: 770 (38%) at main() level
                         956 (47%) worst case
               Stack:    15 worst case (14 in main + 1 for interrupts)

*
0000:  GOTO   6B1C
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   01AE
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  MOVFF  0D,FE9
0070:  MOVFF  08,FEA
0074:  BSF    08.7
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ex15.c - Example 15 from the Embedded Internet/Embedded Ethernet tutorial 
.................... // 
.................... // A webserver that accepts GET and POST commands. 
.................... // 
.................... // NOTE: Change the code in IPAddrInit() to your desired IP address, which 
.................... //       is based on your network. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define STACK_USE_ICMP  1 
.................... #define STACK_USE_ARP   1 
.................... #define STACK_USE_TCP   1 
.................... #define STACK_USE_HTTP  1 
.................... #include "tcpip/ccstcpip.h" //ALUX: 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExampleUDPPacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define STACK_USE_CCS_PICENS   1  //ALUX: SE PONE A 1 Y LOS 2 RESTANTES A CERO (PICNET Y PICEEC). 
.................... #define STACK_USE_CCS_PICNET   0   
.................... #define STACK_USE_CCS_PICEEC   0  //TODO 
....................  
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICEEC 
....................  #define STACK_USE_MCPINC 1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICENS 
....................   #include <18F2550.h>                 //ALUX: SE ESPECIFICO EL PIC18F2550 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
....................   #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL2,CPUDIV2,VREGEN,NOPBADEN   //ALUX: FUSIBLES 
....................   #use delay(clock=32000000)           //ALUX: NO SE PUEDE UTILIZAR UN RELOJ MAS VELOZ, ERROR EN RUTINA DE TIMEOUT 
*
0640:  MOVLW  03
0642:  MOVWF  FEA
0644:  MOVWF  FE9
0646:  MOVF   FEF,W
0648:  BZ    0664
064A:  MOVLW  0A
064C:  MOVWF  01
064E:  CLRF   00
0650:  DECFSZ 00,F
0652:  BRA    0650
0654:  DECFSZ 01,F
0656:  BRA    064E
0658:  MOVLW  5F
065A:  MOVWF  00
065C:  DECFSZ 00,F
065E:  BRA    065C
0660:  DECFSZ FEF,F
0662:  BRA    064A
0664:  GOTO   091A (RETURN)
*
5676:  MOVLW  02
5678:  MOVLB  3
567A:  SUBWF  x3E,F
567C:  BNC   5696
567E:  MOVLW  03
5680:  MOVWF  FEA
5682:  MOVLW  3E
5684:  MOVWF  FE9
5686:  MOVF   FEF,W
5688:  BZ    5696
568A:  BRA    5692
568C:  BRA    568E
568E:  BRA    5690
5690:  NOP   
5692:  DECFSZ FEF,F
5694:  BRA    568C
5696:  MOVLB  0
5698:  GOTO   5738 (RETURN)
.................... #endif 
....................     
....................  //ALUX: 
....................  //#include <18F4620.h> 
....................  //#use delay(clock=40000000) 
....................  //#fuses H4, NOWDT, NOLVP, NODEBUG 
....................   
.................... /*#elif STACK_USE_CCS_PICNET 
....................  #include <18F6722.h> 
....................  #use delay(clock=40000000) 
....................  #fuses H4, NOWDT, NOLVP, NODEBUG 
.................... #elif STACK_USE_CCS_PICEEC 
....................  #include <18F67J60.h> 
....................  //#use delay(clock=41666667) 
....................  //#fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY 
....................  #use delay(clock=25M) 
....................  #fuses NOWDT, NODEBUG, HS, NOIESO, NOFCMEN, PRIMARY, ETHLEDNOEMB 
.................... #elif STACK_USE_CCS_PICNET_OLD 
....................  #include <18F6720.h> 
....................  #use delay(clock=20000000) 
....................  #fuses HS, NOWDT, NOLVP, NODEBUG 
....................  #define STACK_USE_CCS_PICNET   TRUE 
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif */ 
....................  
.................... //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)      // EL C7 ESTA UTILIZADO POR EL SPI EN EL F2550. 
....................  
.................... #include "tcpip/stacktsk.c"         //include Microchip TCP/IP Stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... /*#ifndef STACK_USE_CCS_PICNET         //ALUX: 
.................... #define STACK_USE_CCS_PICNET  FALSE    //ALUX: 
.................... #endif                                 //ALUX: 
....................  
.................... #ifndef STACK_USE_CCS_PICENS           //ALUX: 
.................... #define STACK_USE_CCS_PICENS  FALSE    //ALUX: 
.................... #endif*/                               //ALUX: 
....................  
.................... #use fast_io(A)                        //ALUX: 
.................... #use fast_io(B)                        //ALUX: 
.................... #use fast_io(C)                        //ALUX: 
.................... //#use fast_io(D)                      //ALUX: 
.................... //#use fast_io(E)                      //ALUX:    
.................... /*#if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC //ALUX: 
....................  #use fast_io(F)                                   //ALUX: 
.................... #endif*/                                           //ALUX: 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS.                       //ALUX: 
.................... /*   #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   60000    //time to wait for modem to make a connection (in ms) 
.................... */ 
....................  
.................... //// VARIOUS MAC/NIC SETTINGS.               //ALUX: 
.................... /*   #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................   NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 */ 
....................   
....................                                         //SE MODIFICARON TODOS LOS PINES ORIGINALES PARA TARJETA ALUX 1.1 
....................   #ifdef STACK_USE_CCS_PICENS           //#elif se cambio por #ifdef 
....................       #define PIN_ENC_MAC_SO  PIN_B0    // PIC <<<< ENC  //ANTES C4 
....................       #define PIN_ENC_MAC_SI  PIN_C7    // PIC >>>> ENC  //ANTES C5 
....................       #define PIN_ENC_MAC_CLK PIN_B1    // ANTES C3 
....................       #define PIN_ENC_MAC_CS  PIN_C1    // ANTES D1 
....................       #define PIN_ENC_MAC_RST PIN_C0    // ANTES D0 
....................       #define PIN_ENC_MAC_INT PIN_B2    // ANTES B0 
....................       #define PIN_ENC_MAC_WOL PIN_B3    // ANTES B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()    *0xF93=(*0xF93 & 0b11111101) | 0b101; *0xF94 = *0xF94 & 0x7C;   //SE MODIFICO PARA ALUX 1.1 
....................       //#elif STACK_USE_CCS_PICEEC 
....................       //no hardware definitions - everything is internal 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
....................  
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
44E2:  MOVFF  32E,333
44E6:  MOVFF  32D,332
....................    sc2=s2; 
44EA:  MOVFF  330,335
44EE:  MOVFF  32F,334
....................    if(sc2<sc1 && sc1 <sc2 +n) 
44F2:  MOVLB  3
44F4:  MOVF   x35,W
44F6:  SUBWF  x33,W
44F8:  BNC   4560
44FA:  BNZ   4502
44FC:  MOVF   x32,W
44FE:  SUBWF  x34,W
4500:  BC    4560
4502:  MOVF   x31,W
4504:  ADDWF  x34,W
4506:  MOVWF  01
4508:  MOVLW  00
450A:  ADDWFC x35,W
450C:  MOVWF  03
450E:  MOVF   x33,W
4510:  SUBWF  03,W
4512:  BNC   4560
4514:  BNZ   451C
4516:  MOVF   01,W
4518:  SUBWF  x32,W
451A:  BC    4560
....................       for(sc1+=n,sc2+=n;0<n;--n) 
451C:  MOVF   x31,W
451E:  ADDWF  x32,F
4520:  MOVLW  00
4522:  ADDWFC x33,F
4524:  MOVF   x31,W
4526:  ADDWF  x34,F
4528:  MOVLW  00
452A:  ADDWFC x35,F
452C:  MOVF   x31,W
452E:  SUBLW  00
4530:  BC    455E
....................          *--sc1=*--sc2; 
4532:  MOVF   x32,W
4534:  BTFSC  FD8.2
4536:  DECF   x33,F
4538:  DECF   x32,F
453A:  MOVF   x34,W
453C:  BTFSC  FD8.2
453E:  DECF   x35,F
4540:  DECF   x34,F
4542:  MOVFF  334,FE9
4546:  MOVFF  335,FEA
454A:  MOVFF  FEF,338
454E:  MOVFF  333,FEA
4552:  MOVFF  332,FE9
4556:  MOVFF  338,FEF
455A:  DECF   x31,F
455C:  BRA    452C
....................    else 
455E:  BRA    459E
....................       for(;0<n;--n) 
4560:  MOVF   x31,W
4562:  SUBLW  00
4564:  BC    459E
....................          *sc1++=*sc2++; 
4566:  MOVFF  333,03
456A:  MOVF   x32,W
456C:  INCF   x32,F
456E:  BTFSC  FD8.2
4570:  INCF   x33,F
4572:  MOVWF  x36
4574:  MOVFF  03,337
4578:  MOVFF  335,03
457C:  MOVF   x34,W
457E:  INCF   x34,F
4580:  BTFSC  FD8.2
4582:  INCF   x35,F
4584:  MOVWF  FE9
4586:  MOVFF  03,FEA
458A:  MOVFF  FEF,338
458E:  MOVFF  337,FEA
4592:  MOVFF  336,FE9
4596:  MOVFF  338,FEF
459A:  DECF   x31,F
459C:  BRA    4560
....................   return s1; 
459E:  MOVFF  32D,01
45A2:  MOVFF  32E,02
....................   } 
45A6:  MOVLB  0
45A8:  GOTO   467E (RETURN)
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
405E:  MOVLB  3
4060:  MOVFF  310,FE9
4064:  MOVFF  311,FEA
4068:  MOVFF  FEF,314
406C:  MOVFF  313,03
4070:  MOVFF  312,FE9
4074:  MOVFF  313,FEA
4078:  MOVF   FEF,W
407A:  SUBWF  x14,W
407C:  BNZ   40A8
....................       if (*s1 == '\0') 
407E:  MOVFF  311,03
4082:  MOVFF  310,FE9
4086:  MOVFF  03,FEA
408A:  MOVF   FEF,F
408C:  BNZ   4094
....................          return(0); 
408E:  MOVLW  00
4090:  MOVWF  01
4092:  BRA    40D2
4094:  MOVFF  311,03
4098:  MOVF   x10,W
409A:  INCF   x10,F
409C:  BTFSC  FD8.2
409E:  INCF   x11,F
40A0:  INCF   x12,F
40A2:  BTFSC  FD8.2
40A4:  INCF   x13,F
40A6:  BRA    4060
....................    return((*s1 < *s2) ? -1: 1); 
40A8:  MOVFF  311,03
40AC:  MOVFF  310,FE9
40B0:  MOVFF  311,FEA
40B4:  MOVFF  FEF,314
40B8:  MOVFF  313,03
40BC:  MOVFF  312,FE9
40C0:  MOVFF  313,FEA
40C4:  MOVF   FEF,W
40C6:  SUBWF  x14,W
40C8:  BC    40CE
40CA:  MOVLW  FF
40CC:  BRA    40D0
40CE:  MOVLW  01
40D0:  MOVWF  01
.................... } 
40D2:  MOVLB  0
40D4:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
40D6:  MOVFF  35F,361
....................    for(su=s;0<n;++su,--n) 
40DA:  MOVFF  35E,363
40DE:  MOVFF  35D,362
40E2:  MOVLB  3
40E4:  MOVF   x60,W
40E6:  SUBLW  00
40E8:  BC    4110
....................       if(*su==uc) 
40EA:  MOVFF  363,03
40EE:  MOVFF  362,FE9
40F2:  MOVFF  363,FEA
40F6:  MOVF   x61,W
40F8:  SUBWF  FEF,W
40FA:  BNZ   4106
....................       return su; 
40FC:  MOVFF  362,01
4100:  MOVFF  363,02
4104:  BRA    4116
4106:  INCF   x62,F
4108:  BTFSC  FD8.2
410A:  INCF   x63,F
410C:  DECF   x60,F
410E:  BRA    40E4
....................    return NULL; 
4110:  MOVLW  00
4112:  MOVWF  01
4114:  MOVWF  02
.................... } 
4116:  MOVLB  0
4118:  RETLW  00
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3F34:  MOVFF  31B,31F
3F38:  MOVFF  31A,31E
3F3C:  MOVFF  31F,03
3F40:  MOVLB  3
3F42:  MOVFF  31E,FE9
3F46:  MOVFF  31F,FEA
3F4A:  MOVF   FEF,F
3F4C:  BZ    3FA2
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
3F4E:  MOVFF  31D,321
3F52:  MOVFF  31C,320
3F56:  MOVFF  321,03
3F5A:  MOVFF  320,FE9
3F5E:  MOVFF  321,FEA
3F62:  MOVF   FEF,F
3F64:  BZ    3F96
....................          if (*sc1 == *sc2) 
3F66:  MOVFF  31E,FE9
3F6A:  MOVFF  31F,FEA
3F6E:  MOVFF  FEF,322
3F72:  MOVFF  321,03
3F76:  MOVFF  320,FE9
3F7A:  MOVFF  321,FEA
3F7E:  MOVF   FEF,W
3F80:  SUBWF  x22,W
3F82:  BNZ   3F8E
....................             return(sc1); 
3F84:  MOVFF  31E,01
3F88:  MOVFF  31F,02
3F8C:  BRA    3FA8
3F8E:  INCF   x20,F
3F90:  BTFSC  FD8.2
3F92:  INCF   x21,F
3F94:  BRA    3F56
3F96:  INCF   x1E,F
3F98:  BTFSC  FD8.2
3F9A:  INCF   x1F,F
3F9C:  MOVLB  0
3F9E:  BRA    3F3C
3FA0:  MOVLB  3
....................    return(0); 
3FA2:  MOVLW  00
3FA4:  MOVWF  01
3FA6:  MOVWF  02
.................... } 
3FA8:  MOVLB  0
3FAA:  GOTO   4020 (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3EA4:  MOVFF  31B,31F
3EA8:  MOVFF  31A,31E
3EAC:  MOVFF  31F,03
3EB0:  MOVLB  3
3EB2:  MOVFF  31E,FE9
3EB6:  MOVFF  31F,FEA
3EBA:  MOVF   FEF,F
3EBC:  BZ    3F1E
....................       for (sc2 = s2; ; sc2++) 
3EBE:  MOVFF  31D,321
3EC2:  MOVFF  31C,320
....................     if (*sc2 == '\0') 
3EC6:  MOVFF  321,03
3ECA:  MOVFF  320,FE9
3ECE:  MOVFF  321,FEA
3ED2:  MOVF   FEF,F
3ED4:  BNZ   3EEA
....................        return(sc1 - s1); 
3ED6:  MOVF   x1A,W
3ED8:  SUBWF  x1E,W
3EDA:  MOVWF  00
3EDC:  MOVF   x1B,W
3EDE:  SUBWFB x1F,W
3EE0:  MOVWF  03
3EE2:  MOVFF  00,01
3EE6:  BRA    3F2E
....................          else if (*sc1 == *sc2) 
3EE8:  BRA    3F0A
3EEA:  MOVFF  31E,FE9
3EEE:  MOVFF  31F,FEA
3EF2:  MOVFF  FEF,322
3EF6:  MOVFF  321,03
3EFA:  MOVFF  320,FE9
3EFE:  MOVFF  321,FEA
3F02:  MOVF   FEF,W
3F04:  SUBWF  x22,W
3F06:  BNZ   3F0A
....................             break; 
3F08:  BRA    3F12
3F0A:  INCF   x20,F
3F0C:  BTFSC  FD8.2
3F0E:  INCF   x21,F
3F10:  BRA    3EC6
3F12:  INCF   x1E,F
3F14:  BTFSC  FD8.2
3F16:  INCF   x1F,F
3F18:  MOVLB  0
3F1A:  BRA    3EAC
3F1C:  MOVLB  3
....................    return(sc1 - s1); 
3F1E:  MOVF   x1A,W
3F20:  SUBWF  x1E,W
3F22:  MOVWF  00
3F24:  MOVF   x1B,W
3F26:  SUBWFB x1F,W
3F28:  MOVWF  03
3F2A:  MOVFF  00,01
.................... } 
3F2E:  MOVLB  0
3F30:  GOTO   3FDE (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
3FAE:  MOVLB  3
3FB0:  MOVF   x12,W
3FB2:  IORWF  x13,W
3FB4:  BZ    3FBE
3FB6:  MOVFF  313,03
3FBA:  MOVF   x12,W
3FBC:  BRA    3FC4
3FBE:  MOVFF  4A,03
3FC2:  MOVF   49,W
3FC4:  MOVWF  x16
3FC6:  MOVFF  03,317
....................    beg += strspn(beg, s2); 
3FCA:  MOVFF  317,31B
3FCE:  MOVFF  316,31A
3FD2:  MOVFF  315,31D
3FD6:  MOVFF  314,31C
3FDA:  MOVLB  0
3FDC:  BRA    3EA4
3FDE:  MOVF   01,W
3FE0:  MOVLB  3
3FE2:  ADDWF  x16,F
3FE4:  MOVLW  00
3FE6:  ADDWFC x17,F
....................    if (*beg == '\0') 
3FE8:  MOVFF  317,03
3FEC:  MOVFF  316,FE9
3FF0:  MOVFF  317,FEA
3FF4:  MOVF   FEF,F
3FF6:  BNZ   400C
....................    { 
....................       *save = ' '; 
3FF8:  MOVFF  49,FE9
3FFC:  MOVFF  4A,FEA
4000:  MOVLW  20
4002:  MOVWF  FEF
....................       return(0); 
4004:  MOVLW  00
4006:  MOVWF  01
4008:  MOVWF  02
400A:  BRA    405A
....................    } 
....................    end = strpbrk(beg, s2); 
400C:  MOVFF  317,31B
4010:  MOVFF  316,31A
4014:  MOVFF  315,31D
4018:  MOVFF  314,31C
401C:  MOVLB  0
401E:  BRA    3F34
4020:  MOVFF  02,319
4024:  MOVFF  01,318
....................    if (*end != '\0') 
4028:  MOVFF  319,03
402C:  MOVLB  3
402E:  MOVFF  318,FE9
4032:  MOVFF  319,FEA
4036:  MOVF   FEF,F
4038:  BZ    404A
....................    { 
....................       *end = '\0'; 
403A:  MOVFF  318,FE9
403E:  MOVFF  319,FEA
4042:  CLRF   FEF
....................       end++; 
4044:  INCF   x18,F
4046:  BTFSC  FD8.2
4048:  INCF   x19,F
....................    } 
....................    save = end; 
404A:  MOVFF  319,4A
404E:  MOVFF  318,49
....................    return(beg); 
4052:  MOVFF  316,01
4056:  MOVFF  317,02
.................... } 
405A:  MOVLB  0
405C:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
44A8:  MOVFF  33F,341
44AC:  MOVFF  33E,340
44B0:  MOVFF  341,03
44B4:  MOVLB  3
44B6:  MOVFF  340,FE9
44BA:  MOVFF  341,FEA
44BE:  MOVF   FEF,F
44C0:  BZ    44CE
44C2:  INCF   x40,F
44C4:  BTFSC  FD8.2
44C6:  INCF   x41,F
44C8:  MOVLB  0
44CA:  BRA    44B0
44CC:  MOVLB  3
....................    return(sc - s); 
44CE:  MOVF   x3E,W
44D0:  SUBWF  x40,W
44D2:  MOVWF  00
44D4:  MOVF   x3F,W
44D6:  SUBWFB x41,W
44D8:  MOVWF  03
44DA:  MOVFF  00,01
.................... } 
44DE:  MOVLB  0
44E0:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
4698:  MOVLB  3
469A:  MOVFF  32A,FE9
469E:  MOVFF  32B,FEA
46A2:  MOVFF  FEF,32E
46A6:  MOVFF  32D,03
46AA:  MOVFF  32C,FE9
46AE:  MOVFF  32D,FEA
46B2:  MOVF   FEF,W
46B4:  SUBWF  x2E,W
46B6:  BZ    4748
46B8:  MOVFF  32B,03
46BC:  MOVFF  32A,FE9
46C0:  MOVFF  32B,FEA
46C4:  MOVFF  FEF,32E
46C8:  MOVF   x2E,W
46CA:  SUBLW  40
46CC:  BC    46D4
46CE:  MOVF   x2E,W
46D0:  SUBLW  5A
46D2:  BC    46E0
46D4:  MOVF   x2E,W
46D6:  SUBLW  60
46D8:  BC    4772
46DA:  MOVF   x2E,W
46DC:  SUBLW  7A
46DE:  BNC   4772
46E0:  MOVFF  32D,03
46E4:  MOVFF  32C,FE9
46E8:  MOVFF  32D,FEA
46EC:  MOVFF  FEF,32E
46F0:  MOVF   x2E,W
46F2:  SUBLW  40
46F4:  BC    46FC
46F6:  MOVF   x2E,W
46F8:  SUBLW  5A
46FA:  BC    4708
46FC:  MOVF   x2E,W
46FE:  SUBLW  60
4700:  BC    4772
4702:  MOVF   x2E,W
4704:  SUBLW  7A
4706:  BNC   4772
4708:  MOVFF  32A,FE9
470C:  MOVFF  32B,FEA
4710:  MOVFF  FEF,32E
4714:  MOVFF  32D,03
4718:  MOVFF  32C,FE9
471C:  MOVFF  32D,FEA
4720:  MOVLW  20
4722:  ADDWF  FEF,W
4724:  SUBWF  x2E,W
4726:  BZ    4748
4728:  MOVFF  32C,FE9
472C:  MOVFF  32D,FEA
4730:  MOVFF  FEF,32E
4734:  MOVFF  32B,03
4738:  MOVFF  32A,FE9
473C:  MOVFF  32B,FEA
4740:  MOVLW  20
4742:  ADDWF  FEF,W
4744:  SUBWF  x2E,W
4746:  BNZ   4772
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
4748:  MOVFF  32B,03
474C:  MOVFF  32A,FE9
4750:  MOVFF  32B,FEA
4754:  MOVF   FEF,F
4756:  BNZ   475E
....................        return(0); 
4758:  MOVLW  00
475A:  MOVWF  01
475C:  BRA    479C
475E:  MOVFF  32B,03
4762:  MOVF   x2A,W
4764:  INCF   x2A,F
4766:  BTFSC  FD8.2
4768:  INCF   x2B,F
476A:  INCF   x2C,F
476C:  BTFSC  FD8.2
476E:  INCF   x2D,F
4770:  BRA    469A
....................  return((*s1 < *s2) ? -1: 1); 
4772:  MOVFF  32B,03
4776:  MOVFF  32A,FE9
477A:  MOVFF  32B,FEA
477E:  MOVFF  FEF,32E
4782:  MOVFF  32D,03
4786:  MOVFF  32C,FE9
478A:  MOVFF  32D,FEA
478E:  MOVF   FEF,W
4790:  SUBWF  x2E,W
4792:  BC    4798
4794:  MOVLW  FF
4796:  BRA    479A
4798:  MOVLW  01
479A:  MOVWF  01
.................... } 
479C:  MOVLB  0
479E:  RETLW  00
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
4868:  MOVLB  3
486A:  CLRF   x2F
....................    sign = 0; 
486C:  CLRF   x2D
....................    base = 10; 
486E:  MOVLW  0A
4870:  MOVWF  x2E
....................    result = 0; 
4872:  CLRF   x2C
....................  
....................    if (!s) 
4874:  MOVF   x2A,W
4876:  IORWF  x2B,W
4878:  BNZ   4880
....................       return 0; 
487A:  MOVLW  00
487C:  MOVWF  01
487E:  BRA    4A06
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
4880:  MOVF   x2F,W
4882:  INCF   x2F,F
4884:  CLRF   03
4886:  ADDWF  x2A,W
4888:  MOVWF  FE9
488A:  MOVF   x2B,W
488C:  ADDWFC 03,W
488E:  MOVWF  FEA
4890:  MOVFF  FEF,330
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
4894:  MOVF   x30,W
4896:  SUBLW  2D
4898:  BNZ   48B4
....................    { 
....................       sign = 1;         // Set the sign to negative 
489A:  MOVLW  01
489C:  MOVWF  x2D
....................       c = s[index++]; 
489E:  MOVF   x2F,W
48A0:  INCF   x2F,F
48A2:  CLRF   03
48A4:  ADDWF  x2A,W
48A6:  MOVWF  FE9
48A8:  MOVF   x2B,W
48AA:  ADDWFC 03,W
48AC:  MOVWF  FEA
48AE:  MOVFF  FEF,330
....................    } 
....................    else if (c == '+') 
48B2:  BRA    48CE
48B4:  MOVF   x30,W
48B6:  SUBLW  2B
48B8:  BNZ   48CE
....................    { 
....................       c = s[index++]; 
48BA:  MOVF   x2F,W
48BC:  INCF   x2F,F
48BE:  CLRF   03
48C0:  ADDWF  x2A,W
48C2:  MOVWF  FE9
48C4:  MOVF   x2B,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  MOVFF  FEF,330
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
48CE:  MOVF   x30,W
48D0:  SUBLW  2F
48D2:  BTFSC  FD8.0
48D4:  BRA    49F6
48D6:  MOVF   x30,W
48D8:  SUBLW  39
48DA:  BTFSS  FD8.0
48DC:  BRA    49F6
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
48DE:  MOVF   x30,W
48E0:  SUBLW  30
48E2:  BNZ   4926
48E4:  CLRF   03
48E6:  MOVF   x2F,W
48E8:  ADDWF  x2A,W
48EA:  MOVWF  FE9
48EC:  MOVF   x2B,W
48EE:  ADDWFC 03,W
48F0:  MOVWF  FEA
48F2:  MOVF   FEF,W
48F4:  SUBLW  78
48F6:  BZ    490C
48F8:  CLRF   03
48FA:  MOVF   x2F,W
48FC:  ADDWF  x2A,W
48FE:  MOVWF  FE9
4900:  MOVF   x2B,W
4902:  ADDWFC 03,W
4904:  MOVWF  FEA
4906:  MOVF   FEF,W
4908:  SUBLW  58
490A:  BNZ   4926
....................       { 
....................          base = 16; 
490C:  MOVLW  10
490E:  MOVWF  x2E
....................          index++; 
4910:  INCF   x2F,F
....................          c = s[index++]; 
4912:  MOVF   x2F,W
4914:  INCF   x2F,F
4916:  CLRF   03
4918:  ADDWF  x2A,W
491A:  MOVWF  FE9
491C:  MOVF   x2B,W
491E:  ADDWFC 03,W
4920:  MOVWF  FEA
4922:  MOVFF  FEF,330
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
4926:  MOVF   x2E,W
4928:  SUBLW  0A
492A:  BNZ   4966
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
492C:  MOVF   x30,W
492E:  SUBLW  2F
4930:  BC    4964
4932:  MOVF   x30,W
4934:  SUBLW  39
4936:  BNC   4964
....................             result = 10*result + (c - '0'); 
4938:  MOVLW  0A
493A:  MOVWF  x31
493C:  MOVFF  32C,332
4940:  MOVLB  0
4942:  BRA    4818
4944:  MOVLW  30
4946:  MOVLB  3
4948:  SUBWF  x30,W
494A:  ADDWF  01,W
494C:  MOVWF  x2C
....................             c = s[index++]; 
494E:  MOVF   x2F,W
4950:  INCF   x2F,F
4952:  CLRF   03
4954:  ADDWF  x2A,W
4956:  MOVWF  FE9
4958:  MOVF   x2B,W
495A:  ADDWFC 03,W
495C:  MOVWF  FEA
495E:  MOVFF  FEF,330
....................          } 
4962:  BRA    492C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
4964:  BRA    49F6
4966:  MOVF   x2E,W
4968:  SUBLW  10
496A:  BNZ   49F6
....................       { 
....................          c = toupper(c); 
496C:  MOVF   x30,W
496E:  SUBLW  60
4970:  BC    497E
4972:  MOVF   x30,W
4974:  SUBLW  7A
4976:  BNC   497E
4978:  MOVF   x30,W
497A:  ANDLW  DF
497C:  BRA    4980
497E:  MOVF   x30,W
4980:  MOVWF  x30
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
4982:  MOVF   x30,W
4984:  SUBLW  2F
4986:  BC    498E
4988:  MOVF   x30,W
498A:  SUBLW  39
498C:  BC    499A
498E:  MOVF   x30,W
4990:  SUBLW  40
4992:  BC    49F6
4994:  MOVF   x30,W
4996:  SUBLW  46
4998:  BNC   49F6
....................             if (c >= '0' && c <= '9') 
499A:  MOVF   x30,W
499C:  SUBLW  2F
499E:  BC    49B8
49A0:  MOVF   x30,W
49A2:  SUBLW  39
49A4:  BNC   49B8
....................                result = (result << 4) + (c - '0'); 
49A6:  SWAPF  x2C,W
49A8:  MOVWF  x31
49AA:  MOVLW  F0
49AC:  ANDWF  x31,F
49AE:  MOVLW  30
49B0:  SUBWF  x30,W
49B2:  ADDWF  x31,W
49B4:  MOVWF  x2C
....................             else 
49B6:  BRA    49CA
....................                result = (result << 4) + (c - 'A' + 10); 
49B8:  SWAPF  x2C,W
49BA:  MOVWF  x31
49BC:  MOVLW  F0
49BE:  ANDWF  x31,F
49C0:  MOVLW  41
49C2:  SUBWF  x30,W
49C4:  ADDLW  0A
49C6:  ADDWF  x31,W
49C8:  MOVWF  x2C
....................  
....................             c = s[index++]; 
49CA:  MOVF   x2F,W
49CC:  INCF   x2F,F
49CE:  CLRF   03
49D0:  ADDWF  x2A,W
49D2:  MOVWF  FE9
49D4:  MOVF   x2B,W
49D6:  ADDWFC 03,W
49D8:  MOVWF  FEA
49DA:  MOVFF  FEF,330
....................             c = toupper(c); 
49DE:  MOVF   x30,W
49E0:  SUBLW  60
49E2:  BC    49F0
49E4:  MOVF   x30,W
49E6:  SUBLW  7A
49E8:  BNC   49F0
49EA:  MOVF   x30,W
49EC:  ANDLW  DF
49EE:  BRA    49F2
49F0:  MOVF   x30,W
49F2:  MOVWF  x30
....................          } 
49F4:  BRA    4982
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
49F6:  DECFSZ x2D,W
49F8:  BRA    4A02
49FA:  MOVF   x2E,W
49FC:  SUBLW  0A
49FE:  BNZ   4A02
....................        result = -result; 
4A00:  NEGF   x2C
....................  
....................    return(result); 
4A02:  MOVFF  32C,01
.................... } 
4A06:  MOVLB  0
4A08:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
4B38:  MOVLB  3
4B3A:  CLRF   x18
....................    sign = 0; 
4B3C:  CLRF   x16
....................    base = 10; 
4B3E:  MOVLW  0A
4B40:  MOVWF  x17
....................    result = 0; 
4B42:  CLRF   x15
4B44:  CLRF   x14
....................  
....................    if (!s) 
4B46:  MOVF   x12,W
4B48:  IORWF  x13,W
4B4A:  BNZ   4B54
....................       return 0; 
4B4C:  MOVLW  00
4B4E:  MOVWF  01
4B50:  MOVWF  02
4B52:  BRA    4D26
....................    c = s[index++]; 
4B54:  MOVF   x18,W
4B56:  INCF   x18,F
4B58:  CLRF   03
4B5A:  ADDWF  x12,W
4B5C:  MOVWF  FE9
4B5E:  MOVF   x13,W
4B60:  ADDWFC 03,W
4B62:  MOVWF  FEA
4B64:  MOVFF  FEF,319
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
4B68:  MOVF   x19,W
4B6A:  SUBLW  2D
4B6C:  BNZ   4B88
....................    { 
....................       sign = 1;         // Set the sign to negative 
4B6E:  MOVLW  01
4B70:  MOVWF  x16
....................       c = s[index++]; 
4B72:  MOVF   x18,W
4B74:  INCF   x18,F
4B76:  CLRF   03
4B78:  ADDWF  x12,W
4B7A:  MOVWF  FE9
4B7C:  MOVF   x13,W
4B7E:  ADDWFC 03,W
4B80:  MOVWF  FEA
4B82:  MOVFF  FEF,319
....................    } 
....................    else if (c == '+') 
4B86:  BRA    4BA2
4B88:  MOVF   x19,W
4B8A:  SUBLW  2B
4B8C:  BNZ   4BA2
....................    { 
....................       c = s[index++]; 
4B8E:  MOVF   x18,W
4B90:  INCF   x18,F
4B92:  CLRF   03
4B94:  ADDWF  x12,W
4B96:  MOVWF  FE9
4B98:  MOVF   x13,W
4B9A:  ADDWFC 03,W
4B9C:  MOVWF  FEA
4B9E:  MOVFF  FEF,319
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
4BA2:  MOVF   x19,W
4BA4:  SUBLW  2F
4BA6:  BTFSC  FD8.0
4BA8:  BRA    4D0A
4BAA:  MOVF   x19,W
4BAC:  SUBLW  39
4BAE:  BTFSS  FD8.0
4BB0:  BRA    4D0A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
4BB2:  MOVF   x19,W
4BB4:  SUBLW  30
4BB6:  BNZ   4BFA
4BB8:  CLRF   03
4BBA:  MOVF   x18,W
4BBC:  ADDWF  x12,W
4BBE:  MOVWF  FE9
4BC0:  MOVF   x13,W
4BC2:  ADDWFC 03,W
4BC4:  MOVWF  FEA
4BC6:  MOVF   FEF,W
4BC8:  SUBLW  78
4BCA:  BZ    4BE0
4BCC:  CLRF   03
4BCE:  MOVF   x18,W
4BD0:  ADDWF  x12,W
4BD2:  MOVWF  FE9
4BD4:  MOVF   x13,W
4BD6:  ADDWFC 03,W
4BD8:  MOVWF  FEA
4BDA:  MOVF   FEF,W
4BDC:  SUBLW  58
4BDE:  BNZ   4BFA
....................       { 
....................          base = 16; 
4BE0:  MOVLW  10
4BE2:  MOVWF  x17
....................          index++; 
4BE4:  INCF   x18,F
....................          c = s[index++]; 
4BE6:  MOVF   x18,W
4BE8:  INCF   x18,F
4BEA:  CLRF   03
4BEC:  ADDWF  x12,W
4BEE:  MOVWF  FE9
4BF0:  MOVF   x13,W
4BF2:  ADDWFC 03,W
4BF4:  MOVWF  FEA
4BF6:  MOVFF  FEF,319
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
4BFA:  MOVF   x17,W
4BFC:  SUBLW  0A
4BFE:  BNZ   4C48
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
4C00:  MOVF   x19,W
4C02:  SUBLW  2F
4C04:  BC    4C46
4C06:  MOVF   x19,W
4C08:  SUBLW  39
4C0A:  BNC   4C46
....................             result = 10*result + (c - '0'); 
4C0C:  CLRF   x5F
4C0E:  MOVLW  0A
4C10:  MOVWF  x5E
4C12:  MOVFF  315,361
4C16:  MOVFF  314,360
4C1A:  MOVLB  0
4C1C:  CALL   411A
4C20:  MOVLW  30
4C22:  MOVLB  3
4C24:  SUBWF  x19,W
4C26:  ADDWF  01,W
4C28:  MOVWF  x14
4C2A:  MOVLW  00
4C2C:  ADDWFC 02,W
4C2E:  MOVWF  x15
....................             c = s[index++]; 
4C30:  MOVF   x18,W
4C32:  INCF   x18,F
4C34:  CLRF   03
4C36:  ADDWF  x12,W
4C38:  MOVWF  FE9
4C3A:  MOVF   x13,W
4C3C:  ADDWFC 03,W
4C3E:  MOVWF  FEA
4C40:  MOVFF  FEF,319
....................          } 
4C44:  BRA    4C00
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
4C46:  BRA    4D0A
4C48:  MOVF   x17,W
4C4A:  SUBLW  10
4C4C:  BNZ   4D0A
....................       { 
....................          c = toupper(c); 
4C4E:  MOVF   x19,W
4C50:  SUBLW  60
4C52:  BC    4C60
4C54:  MOVF   x19,W
4C56:  SUBLW  7A
4C58:  BNC   4C60
4C5A:  MOVF   x19,W
4C5C:  ANDLW  DF
4C5E:  BRA    4C62
4C60:  MOVF   x19,W
4C62:  MOVWF  x19
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
4C64:  MOVF   x19,W
4C66:  SUBLW  2F
4C68:  BC    4C70
4C6A:  MOVF   x19,W
4C6C:  SUBLW  39
4C6E:  BC    4C7C
4C70:  MOVF   x19,W
4C72:  SUBLW  40
4C74:  BC    4D0A
4C76:  MOVF   x19,W
4C78:  SUBLW  46
4C7A:  BNC   4D0A
....................             if (c >= '0' && c <= '9') 
4C7C:  MOVF   x19,W
4C7E:  SUBLW  2F
4C80:  BC    4CB4
4C82:  MOVF   x19,W
4C84:  SUBLW  39
4C86:  BNC   4CB4
....................                result = (result << 4) + (c - '0'); 
4C88:  RLCF   x14,W
4C8A:  MOVWF  x1A
4C8C:  RLCF   x15,W
4C8E:  MOVWF  x1B
4C90:  RLCF   x1A,F
4C92:  RLCF   x1B,F
4C94:  RLCF   x1A,F
4C96:  RLCF   x1B,F
4C98:  RLCF   x1A,F
4C9A:  RLCF   x1B,F
4C9C:  MOVLW  F0
4C9E:  ANDWF  x1A,F
4CA0:  MOVLW  30
4CA2:  SUBWF  x19,W
4CA4:  ADDWF  x1A,W
4CA6:  MOVWF  01
4CA8:  MOVLW  00
4CAA:  ADDWFC x1B,W
4CAC:  MOVFF  01,314
4CB0:  MOVWF  x15
....................             else 
4CB2:  BRA    4CE0
....................                result = (result << 4) + (c - 'A' + 10); 
4CB4:  RLCF   x14,W
4CB6:  MOVWF  x1A
4CB8:  RLCF   x15,W
4CBA:  MOVWF  x1B
4CBC:  RLCF   x1A,F
4CBE:  RLCF   x1B,F
4CC0:  RLCF   x1A,F
4CC2:  RLCF   x1B,F
4CC4:  RLCF   x1A,F
4CC6:  RLCF   x1B,F
4CC8:  MOVLW  F0
4CCA:  ANDWF  x1A,F
4CCC:  MOVLW  41
4CCE:  SUBWF  x19,W
4CD0:  ADDLW  0A
4CD2:  ADDWF  x1A,W
4CD4:  MOVWF  01
4CD6:  MOVLW  00
4CD8:  ADDWFC x1B,W
4CDA:  MOVFF  01,314
4CDE:  MOVWF  x15
....................  
....................             c = s[index++];c = toupper(c); 
4CE0:  MOVF   x18,W
4CE2:  INCF   x18,F
4CE4:  CLRF   03
4CE6:  ADDWF  x12,W
4CE8:  MOVWF  FE9
4CEA:  MOVF   x13,W
4CEC:  ADDWFC 03,W
4CEE:  MOVWF  FEA
4CF0:  MOVF   FEF,W
4CF2:  MOVWF  x19
4CF4:  SUBLW  60
4CF6:  BC    4D04
4CF8:  MOVF   x19,W
4CFA:  SUBLW  7A
4CFC:  BNC   4D04
4CFE:  MOVF   x19,W
4D00:  ANDLW  DF
4D02:  BRA    4D06
4D04:  MOVF   x19,W
4D06:  MOVWF  x19
....................          } 
4D08:  BRA    4C64
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
4D0A:  MOVF   x17,W
4D0C:  SUBLW  0A
4D0E:  BNZ   4D1E
4D10:  DECFSZ x16,W
4D12:  BRA    4D1E
....................       result = -result; 
4D14:  COMF   x14,F
4D16:  COMF   x15,F
4D18:  INCF   x14,F
4D1A:  BTFSC  FD8.2
4D1C:  INCF   x15,F
....................  
....................    return(result); 
4D1E:  MOVFF  314,01
4D22:  MOVFF  315,02
.................... } 
4D26:  MOVLB  0
4D28:  GOTO   6196 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
*
413C:  MOVLB  3
413E:  CLRF   x35
4140:  CLRF   x36
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
4142:  MOVLW  30
4144:  MOVWF  x38
4146:  MOVLW  31
4148:  MOVWF  x39
414A:  MOVLW  32
414C:  MOVWF  x3A
414E:  MOVLW  33
4150:  MOVWF  x3B
4152:  MOVLW  34
4154:  MOVWF  x3C
4156:  MOVLW  35
4158:  MOVWF  x3D
415A:  MOVLW  36
415C:  MOVWF  x3E
415E:  MOVLW  37
4160:  MOVWF  x3F
4162:  MOVLW  38
4164:  MOVWF  x40
4166:  MOVLW  39
4168:  MOVWF  x41
416A:  MOVLW  61
416C:  MOVWF  x42
416E:  MOVLW  62
4170:  MOVWF  x43
4172:  MOVLW  63
4174:  MOVWF  x44
4176:  MOVLW  64
4178:  MOVWF  x45
417A:  MOVLW  65
417C:  MOVWF  x46
417E:  MOVLW  66
4180:  MOVWF  x47
4182:  MOVLW  67
4184:  MOVWF  x48
4186:  MOVLW  68
4188:  MOVWF  x49
418A:  MOVLW  69
418C:  MOVWF  x4A
418E:  MOVLW  6A
4190:  MOVWF  x4B
4192:  MOVLW  6B
4194:  MOVWF  x4C
4196:  MOVLW  6C
4198:  MOVWF  x4D
419A:  MOVLW  6D
419C:  MOVWF  x4E
419E:  MOVLW  6E
41A0:  MOVWF  x4F
41A2:  MOVLW  6F
41A4:  MOVWF  x50
41A6:  MOVLW  70
41A8:  MOVWF  x51
41AA:  MOVLW  71
41AC:  MOVWF  x52
41AE:  MOVLW  73
41B0:  MOVWF  x53
41B2:  MOVLW  74
41B4:  MOVWF  x54
41B6:  MOVLW  75
41B8:  MOVWF  x55
41BA:  MOVLW  76
41BC:  MOVWF  x56
41BE:  MOVLW  77
41C0:  MOVWF  x57
41C2:  MOVLW  78
41C4:  MOVWF  x58
41C6:  MOVLW  79
41C8:  MOVWF  x59
41CA:  MOVLW  7A
41CC:  MOVWF  x5A
41CE:  CLRF   x5B
....................    for(sc=s;isspace(*sc);++sc); 
41D0:  MOVFF  32B,330
41D4:  MOVFF  32A,32F
41D8:  MOVFF  330,03
41DC:  MOVFF  32F,FE9
41E0:  MOVFF  330,FEA
41E4:  MOVF   FEF,W
41E6:  SUBLW  20
41E8:  BNZ   41F2
41EA:  INCF   x2F,F
41EC:  BTFSC  FD8.2
41EE:  INCF   x30,F
41F0:  BRA    41D8
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
41F2:  MOVFF  330,03
41F6:  MOVFF  32F,FE9
41FA:  MOVFF  330,FEA
41FE:  MOVF   FEF,W
4200:  SUBLW  2D
4202:  BZ    4216
4204:  MOVFF  330,03
4208:  MOVFF  32F,FE9
420C:  MOVFF  330,FEA
4210:  MOVF   FEF,W
4212:  SUBLW  2B
4214:  BNZ   422C
4216:  MOVFF  330,03
421A:  MOVF   x2F,W
421C:  INCF   x2F,F
421E:  BTFSC  FD8.2
4220:  INCF   x30,F
4222:  MOVWF  FE9
4224:  MOVFF  03,FEA
4228:  MOVF   FEF,W
422A:  BRA    422E
422C:  MOVLW  2B
422E:  MOVWF  x37
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
4230:  MOVF   x37,W
4232:  SUBLW  2D
4234:  BZ    424A
4236:  BTFSC  x2E.7
4238:  BRA    424A
423A:  DECFSZ x2E,W
423C:  BRA    4240
423E:  BRA    424A
4240:  BTFSC  x2E.7
4242:  BRA    424E
4244:  MOVF   x2E,W
4246:  SUBLW  24
4248:  BC    424E
....................    goto StrtoulGO; 
424A:  BRA    4462
....................  
....................    else if (base) 
424C:  BRA    4356
424E:  MOVF   x2E,F
4250:  BZ    42EA
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
4252:  MOVF   x2E,W
4254:  SUBLW  10
4256:  BNZ   4296
4258:  MOVFF  330,03
425C:  MOVFF  32F,FE9
4260:  MOVFF  330,FEA
4264:  MOVF   FEF,W
4266:  SUBLW  30
4268:  BNZ   4296
426A:  MOVLW  01
426C:  ADDWF  x2F,W
426E:  MOVWF  FE9
4270:  MOVLW  00
4272:  ADDWFC x30,W
4274:  MOVWF  FEA
4276:  MOVF   FEF,W
4278:  SUBLW  78
427A:  BZ    428E
427C:  MOVLW  01
427E:  ADDWF  x2F,W
4280:  MOVWF  FE9
4282:  MOVLW  00
4284:  ADDWFC x30,W
4286:  MOVWF  FEA
4288:  MOVF   FEF,W
428A:  SUBLW  58
428C:  BNZ   4296
....................          sc+=2; 
428E:  MOVLW  02
4290:  ADDWF  x2F,F
4292:  MOVLW  00
4294:  ADDWFC x30,F
....................       if(base==8 && *sc =='0') 
4296:  MOVF   x2E,W
4298:  SUBLW  08
429A:  BNZ   42B6
429C:  MOVFF  330,03
42A0:  MOVFF  32F,FE9
42A4:  MOVFF  330,FEA
42A8:  MOVF   FEF,W
42AA:  SUBLW  30
42AC:  BNZ   42B6
....................          sc+=1; 
42AE:  MOVLW  01
42B0:  ADDWF  x2F,F
42B2:  MOVLW  00
42B4:  ADDWFC x30,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
42B6:  MOVF   x2E,W
42B8:  SUBLW  02
42BA:  BNZ   42E8
42BC:  MOVFF  330,03
42C0:  MOVFF  32F,FE9
42C4:  MOVFF  330,FEA
42C8:  MOVF   FEF,W
42CA:  SUBLW  30
42CC:  BNZ   42E8
42CE:  MOVLW  01
42D0:  ADDWF  x2F,W
42D2:  MOVWF  FE9
42D4:  MOVLW  00
42D6:  ADDWFC x30,W
42D8:  MOVWF  FEA
42DA:  MOVF   FEF,W
42DC:  SUBLW  62
42DE:  BNZ   42E8
....................          sc+=2; 
42E0:  MOVLW  02
42E2:  ADDWF  x2F,F
42E4:  MOVLW  00
42E6:  ADDWFC x30,F
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
42E8:  BRA    4356
42EA:  MOVFF  330,03
42EE:  MOVFF  32F,FE9
42F2:  MOVFF  330,FEA
42F6:  MOVF   FEF,W
42F8:  SUBLW  30
42FA:  BZ    4302
....................       base=10; 
42FC:  MOVLW  0A
42FE:  MOVWF  x2E
....................    else if (sc[1]=='x' || sc[1]=='X') 
4300:  BRA    4356
4302:  MOVLW  01
4304:  ADDWF  x2F,W
4306:  MOVWF  FE9
4308:  MOVLW  00
430A:  ADDWFC x30,W
430C:  MOVWF  FEA
430E:  MOVF   FEF,W
4310:  SUBLW  78
4312:  BZ    4326
4314:  MOVLW  01
4316:  ADDWF  x2F,W
4318:  MOVWF  FE9
431A:  MOVLW  00
431C:  ADDWFC x30,W
431E:  MOVWF  FEA
4320:  MOVF   FEF,W
4322:  SUBLW  58
4324:  BNZ   4334
....................       base =16,sc+=2; 
4326:  MOVLW  10
4328:  MOVWF  x2E
432A:  MOVLW  02
432C:  ADDWF  x2F,F
432E:  MOVLW  00
4330:  ADDWFC x30,F
....................    else if(sc[1]=='b') 
4332:  BRA    4356
4334:  MOVLW  01
4336:  ADDWF  x2F,W
4338:  MOVWF  FE9
433A:  MOVLW  00
433C:  ADDWFC x30,W
433E:  MOVWF  FEA
4340:  MOVF   FEF,W
4342:  SUBLW  62
4344:  BNZ   4352
....................       base=2,sc+=2; 
4346:  MOVLW  02
4348:  MOVWF  x2E
434A:  ADDWF  x2F,F
434C:  MOVLW  00
434E:  ADDWFC x30,F
....................    else 
4350:  BRA    4356
....................       base=8; 
4352:  MOVLW  08
4354:  MOVWF  x2E
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
4356:  MOVFF  330,332
435A:  MOVFF  32F,331
435E:  MOVFF  330,03
4362:  MOVFF  32F,FE9
4366:  MOVFF  330,FEA
436A:  MOVF   FEF,W
436C:  SUBLW  30
436E:  BNZ   4378
4370:  INCF   x2F,F
4372:  BTFSC  FD8.2
4374:  INCF   x30,F
4376:  BRA    435E
....................    sd=memchr(digits,tolower(*sc),base); 
4378:  MOVFF  330,03
437C:  MOVFF  32F,FE9
4380:  MOVFF  330,FEA
4384:  MOVFF  FEF,35C
4388:  MOVF   x5C,W
438A:  SUBLW  40
438C:  BC    439A
438E:  MOVF   x5C,W
4390:  SUBLW  5A
4392:  BNC   439A
4394:  MOVF   x5C,W
4396:  IORLW  20
4398:  BRA    439C
439A:  MOVF   x5C,W
439C:  MOVWF  x5C
439E:  MOVLW  03
43A0:  MOVWF  x5E
43A2:  MOVLW  38
43A4:  MOVWF  x5D
43A6:  MOVFF  35C,35F
43AA:  MOVFF  32E,360
43AE:  MOVLB  0
43B0:  RCALL  40D6
43B2:  MOVFF  02,334
43B6:  MOVFF  01,333
....................    for(; sd!=0; ) 
43BA:  MOVLB  3
43BC:  MOVF   x33,F
43BE:  BNZ   43C4
43C0:  MOVF   x34,F
43C2:  BZ    4456
....................    { 
....................       x=x*base+(int16)(sd-digits); 
43C4:  CLRF   03
43C6:  MOVF   x2E,W
43C8:  MOVWF  00
43CA:  BTFSC  FE8.7
43CC:  DECF   03,F
43CE:  MOVWF  x5C
43D0:  MOVFF  03,35D
43D4:  MOVFF  336,35F
43D8:  MOVFF  335,35E
43DC:  MOVFF  03,361
43E0:  MOVWF  x60
43E2:  MOVLB  0
43E4:  RCALL  411A
43E6:  MOVFF  01,35C
43EA:  MOVLW  38
43EC:  MOVLB  3
43EE:  SUBWF  x33,W
43F0:  MOVWF  00
43F2:  MOVLW  03
43F4:  SUBWFB x34,W
43F6:  MOVWF  03
43F8:  MOVF   00,W
43FA:  ADDWF  01,W
43FC:  MOVWF  01
43FE:  MOVF   02,W
4400:  ADDWFC 03,F
4402:  MOVFF  01,335
4406:  MOVFF  03,336
....................       ++sc; 
440A:  INCF   x2F,F
440C:  BTFSC  FD8.2
440E:  INCF   x30,F
....................       sd=memchr(digits,tolower(*sc),base); 
4410:  MOVFF  330,03
4414:  MOVFF  32F,FE9
4418:  MOVFF  330,FEA
441C:  MOVFF  FEF,35C
4420:  MOVF   x5C,W
4422:  SUBLW  40
4424:  BC    4432
4426:  MOVF   x5C,W
4428:  SUBLW  5A
442A:  BNC   4432
442C:  MOVF   x5C,W
442E:  IORLW  20
4430:  BRA    4434
4432:  MOVF   x5C,W
4434:  MOVWF  x5C
4436:  MOVLW  03
4438:  MOVWF  x5E
443A:  MOVLW  38
443C:  MOVWF  x5D
443E:  MOVFF  35C,35F
4442:  MOVFF  32E,360
4446:  MOVLB  0
4448:  RCALL  40D6
444A:  MOVFF  02,334
444E:  MOVFF  01,333
....................    } 
4452:  BRA    43BA
4454:  MOVLB  3
....................    if(s1==sc) 
4456:  MOVF   x2F,W
4458:  SUBWF  x31,W
445A:  BNZ   4482
445C:  MOVF   x30,W
445E:  SUBWF  x32,W
4460:  BNZ   4482
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
4462:  MOVF   x2C,W
4464:  IORWF  x2D,W
4466:  BZ    447A
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
4468:  MOVFF  32C,FE9
446C:  MOVFF  32D,FEA
4470:  MOVFF  32B,FEC
4474:  MOVF   FED,F
4476:  MOVFF  32A,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
447A:  MOVLW  00
447C:  MOVWF  01
447E:  MOVWF  02
4480:  BRA    44A2
....................    } 
....................    if (endptr) 
4482:  MOVF   x2C,W
4484:  IORWF  x2D,W
4486:  BZ    449A
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
4488:  MOVFF  32C,FE9
448C:  MOVFF  32D,FEA
4490:  MOVFF  330,FEC
4494:  MOVF   FED,F
4496:  MOVFF  32F,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
449A:  MOVFF  335,01
449E:  MOVFF  336,02
.................... } 
44A2:  MOVLB  0
44A4:  GOTO   462C (RETURN)
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0B8C:  MOVFF  4E,308
0B90:  MOVFF  4D,307
0B94:  MOVFF  4C,306
0B98:  MOVFF  4B,305
0B9C:  MOVLW  41
0B9E:  MOVLB  3
0BA0:  MOVWF  x0C
0BA2:  MOVLW  C6
0BA4:  MOVWF  x0B
0BA6:  MOVLW  4E
0BA8:  MOVWF  x0A
0BAA:  MOVLW  6D
0BAC:  MOVWF  x09
0BAE:  MOVLB  0
0BB0:  BRA    0AE6
0BB2:  MOVLW  39
0BB4:  MOVLB  3
0BB6:  ADDWF  00,W
0BB8:  MOVWF  4B
0BBA:  MOVLW  30
0BBC:  ADDWFC 01,W
0BBE:  MOVWF  4C
0BC0:  MOVLW  00
0BC2:  ADDWFC 02,W
0BC4:  MOVWF  4D
0BC6:  MOVLW  00
0BC8:  ADDWFC 03,W
0BCA:  MOVWF  4E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0BCC:  MOVFF  4D,00
0BD0:  MOVFF  4E,01
0BD4:  CLRF   02
0BD6:  CLRF   03
0BD8:  MOVFF  4E,307
0BDC:  MOVFF  4D,306
0BE0:  MOVFF  4E,309
0BE4:  MOVFF  4D,308
0BE8:  MOVLW  7F
0BEA:  MOVWF  x0B
0BEC:  MOVLW  FF
0BEE:  MOVWF  x0A
0BF0:  MOVLB  0
0BF2:  BRA    0B44
0BF4:  MOVFF  00,01
0BF8:  MOVFF  03,02
.................... } 
0BFC:  GOTO   0D12 (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0AD2:  MOVFF  308,4E
0AD6:  MOVFF  307,4D
0ADA:  MOVFF  306,4C
0ADE:  MOVFF  305,4B
.................... } 
0AE2:  GOTO   0D10 (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
0F8E:  MOVFF  3B1,3B2
....................     new.v[1]=v.v[0]; 
0F92:  MOVFF  3B0,3B3
....................  
....................     return(new.Val); 
0F96:  MOVLB  3
0F98:  MOVFF  3B2,01
0F9C:  MOVFF  3B3,02
.................... } 
0FA0:  MOVLB  0
0FA2:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
1EAA:  MOVFF  39C,39D
....................     new.v[1]=v.v[2]; 
1EAE:  MOVFF  39B,39E
....................     new.v[2]=v.v[1]; 
1EB2:  MOVFF  39A,39F
....................     new.v[3]=v.v[0]; 
1EB6:  MOVFF  399,3A0
....................  
....................     return(new.Val); 
1EBA:  MOVFF  39D,00
1EBE:  MOVFF  39E,01
1EC2:  MOVFF  39F,02
1EC6:  MOVFF  3A0,03
.................... } 
1ECA:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
1C22:  MOVLB  3
1C24:  CLRF   xA2
1C26:  CLRF   xA1
1C28:  CLRF   xA0
1C2A:  CLRF   x9F
....................  
.................... 	i = count >> 1; 
1C2C:  BCF    FD8.0
1C2E:  RRCF   x96,W
1C30:  MOVWF  x98
1C32:  RRCF   x95,W
1C34:  MOVWF  x97
.................... 	val = (WORD *)buffer; 
1C36:  MOVFF  394,39A
1C3A:  MOVFF  393,399
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
1C3E:  MOVFF  398,03
1C42:  MOVF   x97,W
1C44:  BTFSC  FD8.2
1C46:  DECF   x98,F
1C48:  DECF   x97,F
1C4A:  IORWF  03,W
1C4C:  BZ    1C7C
1C4E:  MOVFF  39A,03
1C52:  MOVFF  399,00
1C56:  MOVLW  02
1C58:  ADDWF  x99,F
1C5A:  BTFSC  FD8.0
1C5C:  INCF   x9A,F
1C5E:  MOVFF  00,FE9
1C62:  MOVFF  03,FEA
1C66:  MOVFF  FEC,03
1C6A:  MOVF   FED,F
1C6C:  MOVF   FEF,W
1C6E:  ADDWF  x9F,F
1C70:  MOVF   03,W
1C72:  ADDWFC xA0,F
1C74:  MOVLW  00
1C76:  ADDWFC xA1,F
1C78:  ADDWFC xA2,F
1C7A:  BRA    1C3E
....................  
.................... 	if ( count & 1 ) 
1C7C:  MOVF   x95,W
1C7E:  ANDLW  01
1C80:  MOVWF  00
1C82:  CLRF   03
1C84:  MOVF   00,W
1C86:  IORWF  03,W
1C88:  BZ    1C9E
.................... 		sum.Val += *(BYTE *)val; 
1C8A:  MOVFF  399,FE9
1C8E:  MOVFF  39A,FEA
1C92:  MOVF   FEF,W
1C94:  ADDWF  x9F,F
1C96:  MOVLW  00
1C98:  ADDWFC xA0,F
1C9A:  ADDWFC xA1,F
1C9C:  ADDWFC xA2,F
....................  
.................... 	tempSum.Val = sum.Val; 
1C9E:  MOVFF  3A2,39E
1CA2:  MOVFF  3A1,39D
1CA6:  MOVFF  3A0,39C
1CAA:  MOVFF  39F,39B
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
1CAE:  MOVFF  39E,398
1CB2:  MOVFF  39D,397
1CB6:  MOVF   x97,F
1CB8:  BNZ   1CBE
1CBA:  MOVF   x98,F
1CBC:  BZ    1CFC
.................... 		sum.words.MSB.Val = 0; 
1CBE:  CLRF   xA2
1CC0:  CLRF   xA1
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
1CC2:  CLRF   xA6
1CC4:  CLRF   xA5
1CC6:  MOVFF  3A0,3A4
1CCA:  MOVFF  39F,3A3
1CCE:  CLRF   02
1CD0:  CLRF   03
1CD2:  MOVF   x97,W
1CD4:  ADDWF  x9F,W
1CD6:  MOVWF  x9F
1CD8:  MOVF   x98,W
1CDA:  ADDWFC xA0,W
1CDC:  MOVWF  xA0
1CDE:  MOVF   02,W
1CE0:  ADDWFC xA5,W
1CE2:  MOVWF  xA1
1CE4:  MOVF   03,W
1CE6:  ADDWFC xA6,W
1CE8:  MOVWF  xA2
.................... 		tempSum.Val = sum.Val; 
1CEA:  MOVFF  3A2,39E
1CEE:  MOVFF  3A1,39D
1CF2:  MOVFF  3A0,39C
1CF6:  MOVFF  39F,39B
.................... 	} 
1CFA:  BRA    1CAE
....................  
.................... 	return (~sum.words.LSB.Val); 
1CFC:  MOVFF  3A0,03
1D00:  COMF   03,F
1D02:  MOVF   x9F,W
1D04:  XORLW  FF
1D06:  MOVWF  01
1D08:  MOVFF  03,02
.................... } 
1D0C:  MOVLB  0
1D0E:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
05C4:  MOVLW  83
05C6:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
05C8:  MOVLW  3C
05CA:  MOVWF  FD7
05CC:  MOVLW  AF
05CE:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
05D0:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
05D2:  MOVLW  C0
05D4:  IORWF  FF2,F
.................... } 
05D6:  GOTO   0EB6 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
22D0:  BCF    FF2.5
....................     ret=TickCount; 
22D2:  MOVFF  51,355
22D6:  MOVFF  50,354
....................     enable_interrupts(INT_TIMER0); 
22DA:  BSF    FF2.5
....................     return ret; 
22DC:  MOVLB  3
22DE:  MOVFF  354,01
22E2:  MOVFF  355,02
.................... } 
22E6:  MOVLB  0
22E8:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
01AE:  INCF   50,F
01B0:  BTFSC  FD8.2
01B2:  INCF   51,F
....................  
....................         second_counter_intermediate++; 
01B4:  INCF   53,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
01B6:  MOVF   53,W
01B8:  SUBLW  09
01BA:  BC    01C0
....................             second_counter++; //increment this ever 1s 
01BC:  INCF   52,F
....................             second_counter_intermediate=0; 
01BE:  CLRF   53
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
01C0:  MOVLW  3C
01C2:  MOVWF  FD7
01C4:  MOVLW  AF
01C6:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO               //SE MODIFICARON TODOS LOS PINES PARA TRABAJO CON ALUX 1.1 
....................       #define PIN_ENC_MAC_SO  PIN_B0    //PIC <<<< ENC  //ANTES C4 
....................       #define PIN_ENC_MAC_SI  PIN_C7    //PIC >>>> ENC  //ANTES C5 
....................       #define PIN_ENC_MAC_CLK PIN_B1    //ANTES C3 
....................       #define PIN_ENC_MAC_CS  PIN_C1    //ANTES D1 
....................       #define PIN_ENC_MAC_RST PIN_C0    //ANTES D0 
....................       #define PIN_ENC_MAC_INT PIN_B2    //ANTES B0 
....................       #define PIN_ENC_MAC_WOL PIN_B3    //ANTES B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()    *0xF93=(*0xF93 & 0b11111101) | 0b101; *0xF94 = *0xF94 & 0x7C;  //MODIFICADO PARA ALUX 1.1 
....................    #endif  
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
01C8:  BCF    FF2.2
01CA:  GOTO   0058
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
*
05DA:  MOVF   F93,W
05DC:  ANDLW  FD
05DE:  IORLW  05
05E0:  MOVWF  F93
05E2:  MOVLW  7C
05E4:  ANDWF  F94,F
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
05E6:  BCF    FC6.5
05E8:  MOVLW  20
05EA:  MOVWF  FC6
05EC:  MOVLW  40
05EE:  MOVWF  FC7
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
05F0:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
05F2:  BSF    F8B.0
.................... } 
05F4:  GOTO   08E6 (RETURN)
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
05F8:  MOVF   FC9,W
05FA:  MOVFF  3BB,FC9
05FE:  RRCF   FC7,W
0600:  BNC   05FE
0602:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
0606:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
08E4:  BRA    05DA
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
08E6:  MOVLW  1D
08E8:  MOVLB  3
08EA:  MOVWF  xB0
08EC:  MOVLB  0
08EE:  RCALL  0608
08F0:  MOVFF  01,302
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
08F4:  MOVLB  3
08F6:  BTFSS  x02.3
08F8:  BRA    08FE
08FA:  MOVLB  0
08FC:  BRA    08E6
08FE:  MOVF   x02,W
0900:  XORLW  FF
0902:  ANDLW  01
0904:  BTFSC  FD8.2
0906:  BRA    090C
0908:  MOVLB  0
090A:  BRA    08E6
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
090C:  MOVLB  0
090E:  BRA    062E
....................     delay_ms(1); 
0910:  MOVLW  01
0912:  MOVLB  3
0914:  MOVWF  x03
0916:  MOVLB  0
0918:  BRA    0640
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
091A:  CLRF   4F
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
091C:  BSF    58.0
....................    NextPacketLocation.Val = RXSTART; 
091E:  CLRF   55
0920:  CLRF   54
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0922:  MOVLW  08
0924:  MOVLB  3
0926:  MOVWF  xB6
0928:  CLRF   xB7
092A:  MOVLB  0
092C:  RCALL  0668
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
092E:  MOVLW  09
0930:  MOVLB  3
0932:  MOVWF  xB6
0934:  CLRF   xB7
0936:  MOVLB  0
0938:  RCALL  0668
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
093A:  MOVLW  0C
093C:  MOVLB  3
093E:  MOVWF  xB6
0940:  MOVLW  F7
0942:  MOVWF  xB7
0944:  MOVLB  0
0946:  RCALL  0668
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0948:  MOVLW  0D
094A:  MOVLB  3
094C:  MOVWF  xB6
094E:  MOVLW  1B
0950:  MOVWF  xB7
0952:  MOVLB  0
0954:  RCALL  0668
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0956:  MOVLW  0A
0958:  MOVLB  3
095A:  MOVWF  xB6
095C:  MOVLW  F7
095E:  MOVWF  xB7
0960:  MOVLB  0
0962:  RCALL  0668
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0964:  MOVLW  0B
0966:  MOVLB  3
0968:  MOVWF  xB6
096A:  MOVLW  1B
096C:  MOVWF  xB7
096E:  MOVLB  0
0970:  RCALL  0668
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0972:  MOVLW  04
0974:  MOVLB  3
0976:  MOVWF  xB6
0978:  MOVLW  F8
097A:  MOVWF  xB7
097C:  MOVLB  0
097E:  RCALL  0668
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
0980:  MOVLW  05
0982:  MOVLB  3
0984:  MOVWF  xB6
0986:  MOVLW  1B
0988:  MOVWF  xB7
098A:  MOVLB  0
098C:  RCALL  0668
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
098E:  MOVLW  02
0990:  MOVLB  3
0992:  MOVWF  xB4
0994:  CLRF   xB3
0996:  MOVLB  0
0998:  RCALL  06B6
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
099A:  MOVLB  3
099C:  CLRF   xB6
099E:  MOVLW  0D
09A0:  MOVWF  xB7
09A2:  MOVLB  0
09A4:  RCALL  0668
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
09A6:  MOVLW  02
09A8:  MOVLB  3
09AA:  MOVWF  xB6
09AC:  MOVLW  32
09AE:  MOVWF  xB7
09B0:  MOVLB  0
09B2:  RCALL  0668
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
09B4:  MOVLW  03
09B6:  MOVLB  3
09B8:  MOVWF  xB6
09BA:  MOVLW  40
09BC:  MOVWF  xB7
09BE:  MOVLB  0
09C0:  RCALL  0668
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
09C2:  MOVLW  09
09C4:  MOVLB  3
09C6:  MOVWF  xB6
09C8:  MOVLW  3F
09CA:  MOVWF  xB7
09CC:  MOVLB  0
09CE:  RCALL  0668
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
09D0:  MOVLW  06
09D2:  MOVLB  3
09D4:  MOVWF  xB6
09D6:  MOVLW  12
09D8:  MOVWF  xB7
09DA:  MOVLB  0
09DC:  RCALL  0668
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
09DE:  MOVLW  07
09E0:  MOVLB  3
09E2:  MOVWF  xB6
09E4:  MOVLW  0C
09E6:  MOVWF  xB7
09E8:  MOVLB  0
09EA:  RCALL  0668
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
09EC:  MOVLW  0A
09EE:  MOVLB  3
09F0:  MOVWF  xB6
09F2:  MOVLW  EE
09F4:  MOVWF  xB7
09F6:  MOVLB  0
09F8:  RCALL  0668
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
09FA:  MOVLW  0B
09FC:  MOVLB  3
09FE:  MOVWF  xB6
0A00:  MOVLW  05
0A02:  MOVWF  xB7
0A04:  MOVLB  0
0A06:  RCALL  0668
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0A08:  MOVLW  03
0A0A:  MOVLB  3
0A0C:  MOVWF  xB4
0A0E:  MOVLW  04
0A10:  MOVWF  xB3
0A12:  MOVLB  0
0A14:  RCALL  06B6
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0A16:  MOVLW  04
0A18:  MOVLB  3
0A1A:  MOVWF  xB6
0A1C:  MOVFF  1C,3B7
0A20:  MOVLB  0
0A22:  RCALL  0668
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0A24:  MOVLW  05
0A26:  MOVLB  3
0A28:  MOVWF  xB6
0A2A:  MOVFF  1D,3B7
0A2E:  MOVLB  0
0A30:  RCALL  0668
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0A32:  MOVLW  02
0A34:  MOVLB  3
0A36:  MOVWF  xB6
0A38:  MOVFF  1E,3B7
0A3C:  MOVLB  0
0A3E:  RCALL  0668
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0A40:  MOVLW  03
0A42:  MOVLB  3
0A44:  MOVWF  xB6
0A46:  MOVFF  1F,3B7
0A4A:  MOVLB  0
0A4C:  RCALL  0668
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
0A4E:  MOVLB  3
0A50:  CLRF   xB6
0A52:  MOVFF  20,3B7
0A56:  MOVLB  0
0A58:  RCALL  0668
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
0A5A:  MOVLW  01
0A5C:  MOVLB  3
0A5E:  MOVWF  xB6
0A60:  MOVFF  21,3B7
0A64:  MOVLB  0
0A66:  RCALL  0668
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0A68:  MOVLW  12
0A6A:  MOVLB  3
0A6C:  MOVWF  xB0
0A6E:  MOVLB  0
0A70:  RCALL  0608
0A72:  MOVFF  01,59
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0A76:  MOVLW  10
0A78:  MOVLB  3
0A7A:  MOVWF  x07
0A7C:  MOVLW  01
0A7E:  MOVWF  x09
0A80:  CLRF   x08
0A82:  MOVLB  0
0A84:  RCALL  071A
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0A86:  MOVLW  14
0A88:  MOVLB  3
0A8A:  MOVWF  x07
0A8C:  MOVLW  04
0A8E:  MOVWF  x09
0A90:  MOVLW  72
0A92:  MOVWF  x08
0A94:  MOVLB  0
0A96:  RCALL  071A
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
0A98:  MOVLB  3
0A9A:  CLRF   x03
0A9C:  MOVLB  0
0A9E:  BRA    0848
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
0AA0:  MOVLW  1F
0AA2:  MOVLB  3
0AA4:  MOVWF  xB8
0AA6:  MOVLW  04
0AA8:  MOVWF  xB9
0AAA:  MOVLB  0
0AAC:  RCALL  069C
.................... }//end MACInit 
0AAE:  GOTO   0EB8 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
23EE:  MOVLW  1F
23F0:  MOVLB  3
23F2:  MOVWF  xB0
23F4:  MOVLB  0
23F6:  CALL   0608
23FA:  MOVFF  01,392
23FE:  MOVLW  00
2400:  MOVLB  3
2402:  BTFSC  01.3
2404:  MOVLW  01
2406:  XORLW  00
2408:  BZ    240E
240A:  MOVLW  00
240C:  BRA    2410
240E:  MOVLW  01
2410:  MOVWF  01
2412:  BRA    2414
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
2414:  MOVLB  0
2416:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
1290:  MOVLW  1F
1292:  MOVLB  3
1294:  MOVWF  xB0
1296:  MOVLB  0
1298:  CALL   0608
129C:  MOVFF  01,392
12A0:  MOVLW  00
12A2:  MOVLB  3
12A4:  BTFSC  01.3
12A6:  MOVLW  01
12A8:  XORLW  00
12AA:  BNZ   12B0
12AC:  MOVLW  00
12AE:  BRA    12B2
12B0:  MOVLW  FF
12B2:  MOVWF  01
12B4:  BRA    12B6
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
12B6:  MOVLB  0
12B8:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
0004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
0EC2:  BTFSS  58.0
0EC4:  BRA    0EC8
....................       return; 
0EC6:  BRA    0F2C
....................    WasDiscarded = TRUE; 
0EC8:  BSF    58.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
0ECA:  MOVLW  01
0ECC:  SUBWF  54,W
0ECE:  MOVLB  3
0ED0:  MOVWF  x54
0ED2:  MOVLW  00
0ED4:  SUBWFB 55,W
0ED6:  MOVWF  x55
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
0ED8:  MOVF   x55,W
0EDA:  SUBLW  1A
0EDC:  BC    0EF0
0EDE:  XORLW  FF
0EE0:  BNZ   0EE8
0EE2:  MOVF   x54,W
0EE4:  SUBLW  F7
0EE6:  BC    0EF0
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
0EE8:  MOVLW  1B
0EEA:  MOVWF  x55
0EEC:  MOVLW  F7
0EEE:  MOVWF  x54
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
0EF0:  MOVLW  1E
0EF2:  MOVWF  xB8
0EF4:  MOVLW  40
0EF6:  MOVWF  xB9
0EF8:  MOVLB  0
0EFA:  CALL   069C
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
0EFE:  MOVLB  3
0F00:  CLRF   xB4
0F02:  MOVLW  0C
0F04:  MOVWF  xB3
0F06:  MOVLB  0
0F08:  CALL   06B6
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
0F0C:  MOVLW  0C
0F0E:  MOVLB  3
0F10:  MOVWF  xB6
0F12:  MOVFF  354,3B7
0F16:  MOVLB  0
0F18:  CALL   0668
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
0F1C:  MOVLW  0D
0F1E:  MOVLB  3
0F20:  MOVWF  xB6
0F22:  MOVFF  355,3B7
0F26:  MOVLB  0
0F28:  CALL   0668
.................... } 
0F2C:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
2418:  MOVLW  01
241A:  MOVLB  3
241C:  MOVWF  xB4
241E:  MOVLW  19
2420:  MOVWF  xB3
2422:  MOVLB  0
2424:  CALL   06B6
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
2428:  MOVLW  19
242A:  MOVLB  3
242C:  MOVWF  xB0
242E:  MOVLB  0
2430:  CALL   0608
2434:  MOVFF  01,391
....................  
....................       BankSel(ERXWRPTL); 
2438:  MOVLB  3
243A:  CLRF   xB4
243C:  MOVLW  0E
243E:  MOVWF  xB3
2440:  MOVLB  0
2442:  CALL   06B6
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
2446:  MOVLW  0E
2448:  MOVLB  3
244A:  MOVWF  xB0
244C:  MOVLB  0
244E:  CALL   0608
2452:  MOVFF  01,393
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
2456:  MOVLW  0F
2458:  MOVLB  3
245A:  MOVWF  xB0
245C:  MOVLB  0
245E:  CALL   0608
2462:  MOVFF  01,394
....................  
....................       BankSel(EPKTCNT); 
2466:  MOVLW  01
2468:  MOVLB  3
246A:  MOVWF  xB4
246C:  MOVLW  19
246E:  MOVWF  xB3
2470:  MOVLB  0
2472:  CALL   06B6
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
2476:  MOVLW  19
2478:  MOVLB  3
247A:  MOVWF  xB0
247C:  MOVLB  0
247E:  CALL   0608
2482:  MOVFF  01,395
2486:  MOVLB  3
2488:  MOVF   x91,W
248A:  SUBWF  01,W
248C:  BTFSC  FD8.2
248E:  BRA    2494
2490:  MOVLB  0
2492:  BRA    2428
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
2494:  CLRF   xB4
2496:  MOVLW  0C
2498:  MOVWF  xB3
249A:  MOVLB  0
249C:  CALL   06B6
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
24A0:  MOVLW  0C
24A2:  MOVLB  3
24A4:  MOVWF  xB0
24A6:  MOVLB  0
24A8:  CALL   0608
24AC:  MOVFF  01,391
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
24B0:  MOVLW  0D
24B2:  MOVLB  3
24B4:  MOVWF  xB0
24B6:  MOVLB  0
24B8:  CALL   0608
24BC:  MOVFF  01,392
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
24C0:  MOVLB  3
24C2:  MOVF   x92,W
24C4:  SUBWF  x94,W
24C6:  BNC   24F4
24C8:  BNZ   24D0
24CA:  MOVF   x93,W
24CC:  SUBWF  x91,W
24CE:  BC    24F4
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
24D0:  MOVF   x91,W
24D2:  SUBWF  x93,W
24D4:  MOVWF  00
24D6:  MOVF   x92,W
24D8:  SUBWFB x94,W
24DA:  MOVWF  03
24DC:  MOVF   00,W
24DE:  XORLW  FF
24E0:  ADDLW  F8
24E2:  MOVWF  00
24E4:  MOVLW  1B
24E6:  SUBFWB 03,F
24E8:  MOVFF  00,01
24EC:  MOVFF  03,02
24F0:  BRA    252C
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
24F2:  BRA    252C
24F4:  MOVF   x91,W
24F6:  SUBWF  x93,W
24F8:  BNZ   250C
24FA:  MOVF   x92,W
24FC:  SUBWF  x94,W
24FE:  BNZ   250C
....................    { 
....................       return RXSIZE - 1; 
2500:  MOVLW  F7
2502:  MOVWF  01
2504:  MOVLW  1B
2506:  MOVWF  02
2508:  BRA    252C
....................    } 
....................    else 
250A:  BRA    252C
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
250C:  MOVF   x93,W
250E:  SUBWF  x91,W
2510:  MOVWF  x95
2512:  MOVF   x94,W
2514:  SUBWFB x92,W
2516:  MOVWF  x96
2518:  MOVLW  01
251A:  SUBWF  x95,W
251C:  MOVWF  00
251E:  MOVLW  00
2520:  SUBWFB x96,W
2522:  MOVWF  03
2524:  MOVFF  00,01
2528:  MOVWF  02
252A:  BRA    252C
....................    } 
.................... } 
252C:  MOVLB  0
252E:  GOTO   27B6 (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
0FA4:  MOVLW  01
0FA6:  MOVLB  3
0FA8:  MOVWF  xB4
0FAA:  MOVLW  19
0FAC:  MOVWF  xB3
0FAE:  MOVLB  0
0FB0:  CALL   06B6
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
0FB4:  MOVLW  19
0FB6:  MOVLB  3
0FB8:  MOVWF  xB0
0FBA:  MOVLB  0
0FBC:  CALL   0608
0FC0:  MOVFF  01,320
0FC4:  MOVLB  3
0FC6:  MOVF   x20,F
0FC8:  BNZ   0FD0
....................       return FALSE; 
0FCA:  MOVLW  00
0FCC:  MOVWF  01
0FCE:  BRA    10D4
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
0FD0:  BTFSC  58.0
0FD2:  BRA    0FE0
....................    { 
....................       MACDiscardRx(); 
0FD4:  MOVLB  0
0FD6:  RCALL  0EC2
....................       return FALSE; 
0FD8:  MOVLW  00
0FDA:  MOVWF  01
0FDC:  MOVLB  3
0FDE:  BRA    10D4
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
0FE0:  MOVFF  55,57
0FE4:  MOVFF  54,56
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
0FE8:  CLRF   xB4
0FEA:  CLRF   xB3
0FEC:  MOVLB  0
0FEE:  CALL   06B6
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
0FF2:  MOVLB  3
0FF4:  CLRF   xB6
0FF6:  MOVFF  54,3B7
0FFA:  MOVLB  0
0FFC:  CALL   0668
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
1000:  MOVLW  01
1002:  MOVLB  3
1004:  MOVWF  xB6
1006:  MOVFF  55,3B7
100A:  MOVLB  0
100C:  CALL   0668
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
1010:  MOVLW  03
1012:  MOVLB  3
1014:  MOVWF  x21
1016:  MOVLW  0C
1018:  MOVFF  321,3A0
101C:  MOVWF  x9F
101E:  CLRF   xA2
1020:  MOVLW  14
1022:  MOVWF  xA1
1024:  MOVLB  0
1026:  RCALL  0F2E
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
1028:  MOVFF  31F,3B1
102C:  MOVFF  31E,3B0
1030:  RCALL  0F8E
1032:  MOVFF  02,31F
1036:  MOVFF  01,31E
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
103A:  MOVLB  3
103C:  MOVF   x0D,W
103E:  SUBLW  1A
1040:  BC    104C
1042:  XORLW  FF
1044:  BNZ   1078
1046:  MOVF   x0C,W
1048:  SUBLW  F7
104A:  BNC   1078
104C:  MOVLW  03
104E:  MOVWF  x21
1050:  MOVLW  0C
1052:  MOVWF  FE9
1054:  MOVFF  321,FEA
1058:  BTFSC  FEF.0
105A:  BRA    1078
105C:  BTFSC  x11.7
105E:  BRA    1078
1060:  BTFSC  x10.4
1062:  BRA    1078
1064:  MOVF   x0F,W
1066:  SUBLW  04
1068:  BC    1074
106A:  XORLW  FF
106C:  BNZ   1078
106E:  MOVF   x0E,W
1070:  SUBLW  EE
1072:  BNC   1078
1074:  BTFSC  x10.7
1076:  BRA    107A
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
1078:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
107A:  MOVFF  30D,55
107E:  MOVFF  30C,54
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
1082:  MOVFF  308,320
1086:  MOVFF  309,321
108A:  MOVFF  309,FEA
108E:  MOVFF  308,FE9
1092:  MOVLW  03
1094:  MOVWF  FE2
1096:  MOVLW  18
1098:  MOVWF  FE1
109A:  MOVLW  06
109C:  MOVWF  01
109E:  MOVFF  FE6,FEE
10A2:  DECFSZ 01,F
10A4:  BRA    109E
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
10A6:  MOVFF  30A,FE9
10AA:  MOVFF  30B,FEA
10AE:  MOVLW  FF
10B0:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
10B2:  MOVF   x1F,W
10B4:  SUBLW  08
10B6:  BNZ   10CE
10B8:  MOVF   x1E,F
10BA:  BZ    10C2
10BC:  MOVF   x1E,W
10BE:  SUBLW  06
10C0:  BNZ   10CE
....................     { 
....................        *type = header.Type.v[0]; 
10C2:  MOVFF  30A,FE9
10C6:  MOVFF  30B,FEA
10CA:  MOVFF  31E,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
10CE:  BCF    58.0
....................    return TRUE; 
10D0:  MOVLW  01
10D2:  MOVWF  01
.................... } 
10D4:  MOVLB  0
10D6:  GOTO   6954 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
13C8:  MOVLB  3
13CA:  CLRF   xB4
13CC:  MOVLW  02
13CE:  MOVWF  xB3
13D0:  MOVLB  0
13D2:  CALL   06B6
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
13D6:  MOVLW  02
13D8:  MOVLB  3
13DA:  MOVWF  xB6
13DC:  MOVLW  F8
13DE:  MOVWF  xB7
13E0:  MOVLB  0
13E2:  CALL   0668
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
13E6:  MOVLW  03
13E8:  MOVLB  3
13EA:  MOVWF  xB6
13EC:  MOVLW  1B
13EE:  MOVWF  xB7
13F0:  MOVLB  0
13F2:  CALL   0668
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
13F6:  MOVLW  06
13F8:  MOVLB  3
13FA:  ADDWF  xB1,F
13FC:  MOVLW  1C
13FE:  ADDWFC xB2,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
1400:  MOVLW  03
1402:  MOVWF  xB4
1404:  MOVLW  B1
1406:  MOVWF  FE9
1408:  MOVFF  3B4,FEA
140C:  MOVFF  FEF,3B5
1410:  MOVLW  06
1412:  MOVWF  xB6
1414:  MOVFF  3B5,3B7
1418:  MOVLB  0
141A:  CALL   0668
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
141E:  MOVLW  03
1420:  MOVLB  3
1422:  MOVWF  xB4
1424:  MOVLW  B1
1426:  MOVWF  xB3
1428:  MOVLW  01
142A:  ADDWF  xB3,W
142C:  MOVWF  FE9
142E:  MOVLW  00
1430:  ADDWFC xB4,W
1432:  MOVWF  FEA
1434:  MOVFF  FEF,3B5
1438:  MOVLW  07
143A:  MOVWF  xB6
143C:  MOVFF  3B5,3B7
1440:  MOVLB  0
1442:  CALL   0668
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
1446:  MOVLB  3
1448:  CLRF   xB4
144A:  MOVLB  0
144C:  RCALL  1364
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
144E:  MOVFF  3AF,3B6
1452:  MOVFF  3AE,3B5
1456:  MOVLB  3
1458:  CLRF   xB8
145A:  MOVLW  06
145C:  MOVWF  xB7
145E:  MOVLB  0
1460:  RCALL  137E
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
1462:  MOVLB  3
1464:  CLRF   xB4
1466:  MOVLW  1C
1468:  MOVFF  3B4,3B6
146C:  MOVWF  xB5
146E:  CLRF   xB8
1470:  MOVLW  06
1472:  MOVWF  xB7
1474:  MOVLB  0
1476:  RCALL  137E
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
1478:  MOVLW  08
147A:  MOVLB  3
147C:  MOVWF  xB4
147E:  MOVLB  0
1480:  RCALL  1364
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
1482:  MOVLB  3
1484:  MOVF   xB0,F
1486:  BNZ   148C
1488:  MOVLW  00
148A:  BRA    148E
148C:  MOVLW  06
148E:  MOVWF  xB4
1490:  MOVLB  0
1492:  RCALL  1364
.................... } 
1494:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
1496:  MOVLW  1C
1498:  MOVLB  3
149A:  MOVWF  xB0
149C:  MOVLB  0
149E:  CALL   0608
14A2:  MOVFF  01,39D
14A6:  MOVLW  00
14A8:  MOVLB  3
14AA:  BTFSC  01.1
14AC:  MOVLW  01
14AE:  XORLW  00
14B0:  BZ    14D2
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
14B2:  MOVLW  1F
14B4:  MOVWF  xB8
14B6:  MOVLW  80
14B8:  MOVWF  xB9
14BA:  MOVLB  0
14BC:  CALL   069C
....................       BFCReg(ECON1, ECON1_TXRST); 
14C0:  MOVLW  1F
14C2:  MOVLB  3
14C4:  MOVWF  xB5
14C6:  MOVLW  80
14C8:  MOVWF  xB6
14CA:  MOVLB  0
14CC:  CALL   0682
14D0:  MOVLB  3
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
14D2:  MOVLW  1C
14D4:  MOVWF  xB5
14D6:  MOVLW  0A
14D8:  MOVWF  xB6
14DA:  MOVLB  0
14DC:  CALL   0682
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
14E0:  MOVLW  1F
14E2:  MOVLB  3
14E4:  MOVWF  xB8
14E6:  MOVLW  08
14E8:  MOVWF  xB9
14EA:  MOVLB  0
14EC:  CALL   069C
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
14F0:  MOVF   59,W
14F2:  SUBLW  05
14F4:  BTFSS  FD8.2
14F6:  BRA    16B8
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
14F8:  MOVLW  1C
14FA:  MOVLB  3
14FC:  MOVWF  xB0
14FE:  MOVLB  0
1500:  CALL   0608
1504:  MOVFF  01,39D
1508:  MOVLB  3
150A:  MOVF   01,W
150C:  ANDLW  0A
150E:  BTFSS  FD8.2
1510:  BRA    1516
1512:  MOVLB  0
1514:  BRA    14F8
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
1516:  MOVLW  1C
1518:  MOVWF  xB0
151A:  MOVLB  0
151C:  CALL   0608
1520:  MOVFF  01,39D
1524:  MOVLW  00
1526:  MOVLB  3
1528:  BTFSC  01.1
152A:  MOVLW  01
152C:  XORLW  00
152E:  BTFSC  FD8.2
1530:  BRA    16BA
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
1532:  MOVLW  1F
1534:  MOVWF  xB5
1536:  MOVLW  08
1538:  MOVWF  xB6
153A:  MOVLB  0
153C:  CALL   0682
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
1540:  MOVLB  3
1542:  CLRF   xB4
1544:  CLRF   xB3
1546:  MOVLB  0
1548:  CALL   06B6
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
154C:  MOVLB  3
154E:  CLRF   xB0
1550:  MOVLB  0
1552:  CALL   0608
1556:  MOVFF  01,391
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
155A:  MOVLW  01
155C:  MOVLB  3
155E:  MOVWF  xB0
1560:  MOVLB  0
1562:  CALL   0608
1566:  MOVFF  01,392
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
156A:  MOVLW  06
156C:  MOVLB  3
156E:  MOVWF  xB0
1570:  MOVLB  0
1572:  CALL   0608
1576:  MOVFF  01,393
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
157A:  MOVLW  07
157C:  MOVLB  3
157E:  MOVWF  xB0
1580:  MOVLB  0
1582:  CALL   0608
1586:  MOVFF  01,394
....................          TXEnd.Val++; 
158A:  MOVLB  3
158C:  INCF   x93,F
158E:  BTFSC  FD8.2
1590:  INCF   x94,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
1592:  CLRF   xB6
1594:  MOVFF  393,3B7
1598:  MOVLB  0
159A:  CALL   0668
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
159E:  MOVLW  01
15A0:  MOVLB  3
15A2:  MOVWF  xB6
15A4:  MOVFF  394,3B7
15A8:  MOVLB  0
15AA:  CALL   0668
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
15AE:  MOVLW  03
15B0:  MOVLB  3
15B2:  MOVWF  x9E
15B4:  MOVLW  95
15B6:  MOVFF  39E,3A0
15BA:  MOVWF  x9F
15BC:  CLRF   xA2
15BE:  MOVLW  07
15C0:  MOVWF  xA1
15C2:  MOVLB  0
15C4:  RCALL  0F2E
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
15C6:  MOVLB  3
15C8:  CLRF   x9C
15CA:  MOVF   x9C,W
15CC:  SUBLW  0F
15CE:  BNC   169C
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
15D0:  MOVLW  1C
15D2:  MOVWF  xB0
15D4:  MOVLB  0
15D6:  CALL   0608
15DA:  MOVFF  01,39D
15DE:  MOVLW  00
15E0:  MOVLB  3
15E2:  BTFSC  01.1
15E4:  MOVLW  01
15E6:  XORLW  00
15E8:  BZ    1692
15EA:  BTFSS  x98.5
15EC:  BRA    1692
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
15EE:  MOVLW  1F
15F0:  MOVWF  xB8
15F2:  MOVLW  80
15F4:  MOVWF  xB9
15F6:  MOVLB  0
15F8:  CALL   069C
....................                BFCReg(ECON1, ECON1_TXRST); 
15FC:  MOVLW  1F
15FE:  MOVLB  3
1600:  MOVWF  xB5
1602:  MOVLW  80
1604:  MOVWF  xB6
1606:  MOVLB  0
1608:  CALL   0682
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
160C:  MOVLW  1C
160E:  MOVLB  3
1610:  MOVWF  xB5
1612:  MOVLW  0A
1614:  MOVWF  xB6
1616:  MOVLB  0
1618:  CALL   0682
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
161C:  MOVLW  1F
161E:  MOVLB  3
1620:  MOVWF  xB8
1622:  MOVLW  08
1624:  MOVWF  xB9
1626:  MOVLB  0
1628:  CALL   069C
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
162C:  MOVLW  1C
162E:  MOVLB  3
1630:  MOVWF  xB0
1632:  MOVLB  0
1634:  CALL   0608
1638:  MOVFF  01,39D
163C:  MOVLB  3
163E:  MOVF   01,W
1640:  ANDLW  0A
1642:  BTFSS  FD8.2
1644:  BRA    164A
1646:  MOVLB  0
1648:  BRA    162C
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
164A:  MOVLW  1F
164C:  MOVWF  xB5
164E:  MOVLW  08
1650:  MOVWF  xB6
1652:  MOVLB  0
1654:  CALL   0682
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
1658:  MOVLB  3
165A:  CLRF   xB6
165C:  MOVFF  393,3B7
1660:  MOVLB  0
1662:  CALL   0668
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
1666:  MOVLW  01
1668:  MOVLB  3
166A:  MOVWF  xB6
166C:  MOVFF  394,3B7
1670:  MOVLB  0
1672:  CALL   0668
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
1676:  MOVLW  03
1678:  MOVLB  3
167A:  MOVWF  x9E
167C:  MOVLW  95
167E:  MOVFF  39E,3A0
1682:  MOVWF  x9F
1684:  CLRF   xA2
1686:  MOVLW  07
1688:  MOVWF  xA1
168A:  MOVLB  0
168C:  RCALL  0F2E
....................             } 
....................             else 
168E:  BRA    1696
1690:  MOVLB  3
....................             { 
....................                break; 
1692:  BRA    169C
1694:  MOVLB  0
....................             } 
....................          } 
1696:  MOVLB  3
1698:  INCF   x9C,F
169A:  BRA    15CA
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
169C:  CLRF   xB6
169E:  MOVFF  391,3B7
16A2:  MOVLB  0
16A4:  CALL   0668
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
16A8:  MOVLW  01
16AA:  MOVLB  3
16AC:  MOVWF  xB6
16AE:  MOVFF  392,3B7
16B2:  MOVLB  0
16B4:  CALL   0668
16B8:  MOVLB  3
....................       } 
....................    } 
.................... } 
16BA:  MOVLB  0
16BC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
19E6:  MOVLW  14
19E8:  ADDWF  56,W
19EA:  MOVLB  3
19EC:  MOVWF  x3D
19EE:  MOVLW  00
19F0:  ADDWFC 57,W
19F2:  MOVWF  x3E
19F4:  MOVF   x39,W
19F6:  ADDWF  x3D,W
19F8:  MOVWF  x3B
19FA:  MOVF   x3A,W
19FC:  ADDWFC x3E,W
19FE:  MOVWF  x3C
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
1A00:  MOVF   x3C,W
1A02:  SUBLW  1A
1A04:  BC    1A18
1A06:  XORLW  FF
1A08:  BNZ   1A10
1A0A:  MOVF   x3B,W
1A0C:  SUBLW  F7
1A0E:  BC    1A18
....................       ReadPT.Val -= RXSIZE; 
1A10:  MOVLW  F8
1A12:  SUBWF  x3B,F
1A14:  MOVLW  1B
1A16:  SUBWFB x3C,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
1A18:  CLRF   xB4
1A1A:  CLRF   xB3
1A1C:  MOVLB  0
1A1E:  CALL   06B6
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
1A22:  MOVLB  3
1A24:  CLRF   xB6
1A26:  MOVFF  33B,3B7
1A2A:  MOVLB  0
1A2C:  CALL   0668
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
1A30:  MOVLW  01
1A32:  MOVLB  3
1A34:  MOVWF  xB6
1A36:  MOVFF  33C,3B7
1A3A:  MOVLB  0
1A3C:  CALL   0668
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
1A40:  MOVLW  02
1A42:  MOVLB  3
1A44:  MOVWF  xB6
1A46:  MOVFF  33B,3B7
1A4A:  MOVLB  0
1A4C:  CALL   0668
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
1A50:  MOVLW  03
1A52:  MOVLB  3
1A54:  MOVWF  xB6
1A56:  MOVFF  33C,3B7
1A5A:  MOVLB  0
1A5C:  CALL   0668
.................... } 
1A60:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
12BA:  MOVFF  3AA,4F
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
12BE:  MOVLW  07
12C0:  MOVLB  3
12C2:  ADDWF  xAB,F
12C4:  MOVLW  1C
12C6:  ADDWFC xAC,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
12C8:  CLRF   xB4
12CA:  MOVLW  02
12CC:  MOVWF  xB3
12CE:  MOVLB  0
12D0:  CALL   06B6
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
12D4:  MOVLW  03
12D6:  MOVLB  3
12D8:  MOVWF  xAE
12DA:  MOVLW  AB
12DC:  MOVWF  FE9
12DE:  MOVFF  3AE,FEA
12E2:  MOVFF  FEF,3AF
12E6:  CLRF   xB6
12E8:  MOVFF  3AF,3B7
12EC:  MOVLB  0
12EE:  CALL   0668
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
12F2:  MOVLW  03
12F4:  MOVLB  3
12F6:  MOVWF  xAE
12F8:  MOVLW  AB
12FA:  MOVWF  xAD
12FC:  MOVLW  01
12FE:  ADDWF  xAD,W
1300:  MOVWF  FE9
1302:  MOVLW  00
1304:  ADDWFC xAE,W
1306:  MOVWF  FEA
1308:  MOVFF  FEF,3AF
130C:  MOVLW  01
130E:  MOVWF  xB6
1310:  MOVFF  3AF,3B7
1314:  MOVLB  0
1316:  CALL   0668
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
131A:  MOVLW  03
131C:  MOVLB  3
131E:  MOVWF  xAE
1320:  MOVLW  AB
1322:  MOVWF  FE9
1324:  MOVFF  3AE,FEA
1328:  MOVFF  FEF,3AF
132C:  MOVLW  02
132E:  MOVWF  xB6
1330:  MOVFF  3AF,3B7
1334:  MOVLB  0
1336:  CALL   0668
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
133A:  MOVLW  03
133C:  MOVLB  3
133E:  MOVWF  xAE
1340:  MOVLW  AB
1342:  MOVWF  xAD
1344:  MOVLW  01
1346:  ADDWF  xAD,W
1348:  MOVWF  FE9
134A:  MOVLW  00
134C:  ADDWFC xAE,W
134E:  MOVWF  FEA
1350:  MOVFF  FEF,3AF
1354:  MOVLW  03
1356:  MOVWF  xB6
1358:  MOVFF  3AF,3B7
135C:  MOVLB  0
135E:  CALL   0668
.................... } 
1362:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
18DE:  MOVLW  14
18E0:  ADDWF  56,W
18E2:  MOVLB  3
18E4:  MOVWF  x67
18E6:  MOVLW  00
18E8:  ADDWFC 57,W
18EA:  MOVWF  x68
18EC:  MOVF   x61,W
18EE:  ADDWF  x67,W
18F0:  MOVWF  x65
18F2:  MOVF   x62,W
18F4:  ADDWFC x68,W
18F6:  MOVWF  x66
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
18F8:  MOVF   x66,W
18FA:  SUBLW  1A
18FC:  BC    1910
18FE:  XORLW  FF
1900:  BNZ   1908
1902:  MOVF   x65,W
1904:  SUBLW  F7
1906:  BC    1910
....................    { 
....................       temp.Val -= RXSIZE; 
1908:  MOVLW  F8
190A:  SUBWF  x65,F
190C:  MOVLW  1B
190E:  SUBWFB x66,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
1910:  CLRF   xB4
1912:  MOVLW  10
1914:  MOVWF  xB3
1916:  MOVLB  0
1918:  CALL   06B6
....................    WriteReg(EDMASTL, temp.v[0]); 
191C:  MOVLW  10
191E:  MOVLB  3
1920:  MOVWF  xB6
1922:  MOVFF  365,3B7
1926:  MOVLB  0
1928:  CALL   0668
....................    WriteReg(EDMASTH, temp.v[1]); 
192C:  MOVLW  11
192E:  MOVLB  3
1930:  MOVWF  xB6
1932:  MOVFF  366,3B7
1936:  MOVLB  0
1938:  CALL   0668
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
193C:  MOVLW  01
193E:  MOVLB  3
1940:  SUBWF  x63,W
1942:  MOVWF  00
1944:  MOVLW  00
1946:  SUBWFB x64,W
1948:  MOVWF  03
194A:  MOVF   00,W
194C:  ADDWF  x65,F
194E:  MOVF   03,W
1950:  ADDWFC x66,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1952:  MOVF   x66,W
1954:  SUBLW  1A
1956:  BC    196A
1958:  XORLW  FF
195A:  BNZ   1962
195C:  MOVF   x65,W
195E:  SUBLW  F7
1960:  BC    196A
....................    { 
....................       temp.Val -= RXSIZE; 
1962:  MOVLW  F8
1964:  SUBWF  x65,F
1966:  MOVLW  1B
1968:  SUBWFB x66,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
196A:  MOVLW  12
196C:  MOVWF  xB6
196E:  MOVFF  365,3B7
1972:  MOVLB  0
1974:  CALL   0668
....................    WriteReg(EDMANDH, temp.v[1]); 
1978:  MOVLW  13
197A:  MOVLB  3
197C:  MOVWF  xB6
197E:  MOVFF  366,3B7
1982:  MOVLB  0
1984:  CALL   0668
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1988:  MOVLW  1F
198A:  MOVLB  3
198C:  MOVWF  xB8
198E:  MOVLW  30
1990:  MOVWF  xB9
1992:  MOVLB  0
1994:  CALL   069C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1998:  MOVLW  1F
199A:  MOVLB  3
199C:  MOVWF  xB0
199E:  MOVLB  0
19A0:  CALL   0608
19A4:  MOVFF  01,367
19A8:  MOVLW  00
19AA:  MOVLB  3
19AC:  BTFSC  01.5
19AE:  MOVLW  01
19B0:  XORLW  00
19B2:  BTFSC  FD8.2
19B4:  BRA    19BA
19B6:  MOVLB  0
19B8:  BRA    1998
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
19BA:  MOVLW  16
19BC:  MOVWF  xB0
19BE:  MOVLB  0
19C0:  CALL   0608
19C4:  MOVFF  01,366
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
19C8:  MOVLW  17
19CA:  MOVLB  3
19CC:  MOVWF  xB0
19CE:  MOVLB  0
19D0:  CALL   0608
19D4:  MOVFF  01,365
....................    return temp.Val; 
19D8:  MOVLB  3
19DA:  MOVFF  365,01
19DE:  MOVFF  366,02
.................... } 
19E2:  MOVLB  0
19E4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
2532:  MOVLW  06
2534:  MOVLB  3
2536:  ADDWF  xAA,W
2538:  MOVWF  xB0
253A:  MOVLW  1C
253C:  ADDWFC xAB,W
253E:  MOVWF  xB1
2540:  MOVLW  01
2542:  ADDWF  xB0,W
2544:  MOVWF  xAE
2546:  MOVLW  00
2548:  ADDWFC xB1,W
254A:  MOVWF  xAF
.................... #endif 
....................    BankSel(EDMASTL); 
254C:  CLRF   xB4
254E:  MOVLW  10
2550:  MOVWF  xB3
2552:  MOVLB  0
2554:  CALL   06B6
....................    WriteReg(EDMASTL, temp.v[0]); 
2558:  MOVLW  10
255A:  MOVLB  3
255C:  MOVWF  xB6
255E:  MOVFF  3AE,3B7
2562:  MOVLB  0
2564:  CALL   0668
....................    WriteReg(EDMASTH, temp.v[1]); 
2568:  MOVLW  11
256A:  MOVLB  3
256C:  MOVWF  xB6
256E:  MOVFF  3AF,3B7
2572:  MOVLB  0
2574:  CALL   0668
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
2578:  MOVLW  01
257A:  MOVLB  3
257C:  SUBWF  xAC,W
257E:  MOVWF  00
2580:  MOVLW  00
2582:  SUBWFB xAD,W
2584:  MOVWF  03
2586:  MOVF   00,W
2588:  ADDWF  xAE,F
258A:  MOVF   03,W
258C:  ADDWFC xAF,F
....................    WriteReg(EDMANDL, temp.v[0]); 
258E:  MOVLW  12
2590:  MOVWF  xB6
2592:  MOVFF  3AE,3B7
2596:  MOVLB  0
2598:  CALL   0668
....................    WriteReg(EDMANDH, temp.v[1]); 
259C:  MOVLW  13
259E:  MOVLB  3
25A0:  MOVWF  xB6
25A2:  MOVFF  3AF,3B7
25A6:  MOVLB  0
25A8:  CALL   0668
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
25AC:  MOVLW  1F
25AE:  MOVLB  3
25B0:  MOVWF  xB8
25B2:  MOVLW  30
25B4:  MOVWF  xB9
25B6:  MOVLB  0
25B8:  CALL   069C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
25BC:  MOVLW  1F
25BE:  MOVLB  3
25C0:  MOVWF  xB0
25C2:  MOVLB  0
25C4:  CALL   0608
25C8:  MOVFF  01,3B0
25CC:  MOVLW  00
25CE:  MOVLB  3
25D0:  BTFSC  01.5
25D2:  MOVLW  01
25D4:  XORLW  00
25D6:  BTFSC  FD8.2
25D8:  BRA    25DE
25DA:  MOVLB  0
25DC:  BRA    25BC
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
25DE:  MOVLW  16
25E0:  MOVWF  xB0
25E2:  MOVLB  0
25E4:  CALL   0608
25E8:  MOVFF  01,3AF
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
25EC:  MOVLW  17
25EE:  MOVLB  3
25F0:  MOVWF  xB0
25F2:  MOVLB  0
25F4:  CALL   0608
25F8:  MOVFF  01,3AE
....................    return temp.Val; 
25FC:  MOVLB  3
25FE:  MOVFF  3AE,01
2602:  MOVFF  3AF,02
.................... } 
2606:  MOVLB  0
2608:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
1D38:  MOVLB  3
1D3A:  MOVF   x91,F
1D3C:  BNZ   1D4C
1D3E:  MOVF   x92,F
1D40:  BNZ   1D4C
....................    { 
....................       return 0xFFFF; 
1D42:  MOVLW  FF
1D44:  MOVWF  01
1D46:  MOVWF  02
1D48:  BRA    1E8C
....................    } 
....................    else if(len == 1u) 
1D4A:  BRA    1D7A
1D4C:  DECFSZ x91,W
1D4E:  BRA    1D7A
1D50:  MOVF   x92,F
1D52:  BNZ   1D7A
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
1D54:  MOVLB  0
1D56:  RCALL  1D10
1D58:  MOVLB  3
1D5A:  CLRF   x96
1D5C:  MOVFF  01,395
1D60:  MOVFF  01,03
1D64:  MOVLW  00
1D66:  CLRF   00
1D68:  DECF   00,F
1D6A:  XORWF  00,F
1D6C:  MOVLW  FF
1D6E:  XORWF  03,F
1D70:  MOVFF  00,01
1D74:  MOVFF  03,02
1D78:  BRA    1E8C
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
1D7A:  CLRF   xB4
1D7C:  CLRF   xB3
1D7E:  MOVLB  0
1D80:  CALL   06B6
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
1D84:  MOVLB  3
1D86:  CLRF   xB0
1D88:  MOVLB  0
1D8A:  CALL   0608
1D8E:  MOVFF  01,393
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
1D92:  MOVLW  01
1D94:  MOVLB  3
1D96:  MOVWF  xB0
1D98:  MOVLB  0
1D9A:  CALL   0608
1D9E:  MOVFF  01,394
....................    WriteReg(EDMASTL, temp.v[0]); 
1DA2:  MOVLW  10
1DA4:  MOVLB  3
1DA6:  MOVWF  xB6
1DA8:  MOVFF  393,3B7
1DAC:  MOVLB  0
1DAE:  CALL   0668
....................    WriteReg(EDMASTH, temp.v[1]); 
1DB2:  MOVLW  11
1DB4:  MOVLB  3
1DB6:  MOVWF  xB6
1DB8:  MOVFF  394,3B7
1DBC:  MOVLB  0
1DBE:  CALL   0668
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
1DC2:  MOVLB  3
1DC4:  MOVF   x94,W
1DC6:  SUBLW  1B
1DC8:  BNC   1E00
1DCA:  BNZ   1DD2
1DCC:  MOVF   x93,W
1DCE:  SUBLW  F7
1DD0:  BNC   1E00
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
1DD2:  MOVLW  01
1DD4:  SUBWF  x91,W
1DD6:  MOVWF  00
1DD8:  MOVLW  00
1DDA:  SUBWFB x92,W
1DDC:  MOVWF  03
1DDE:  MOVF   00,W
1DE0:  ADDWF  x93,F
1DE2:  MOVF   03,W
1DE4:  ADDWFC x94,F
....................       if(temp.Val > RXSTOP) 
1DE6:  MOVF   x94,W
1DE8:  SUBLW  1A
1DEA:  BC    1DFE
1DEC:  XORLW  FF
1DEE:  BNZ   1DF6
1DF0:  MOVF   x93,W
1DF2:  SUBLW  F7
1DF4:  BC    1DFE
....................       { 
....................          temp.Val -= RXSIZE; 
1DF6:  MOVLW  F8
1DF8:  SUBWF  x93,F
1DFA:  MOVLW  1B
1DFC:  SUBWFB x94,F
....................       } 
....................    } 
....................    else 
1DFE:  BRA    1E14
....................    { 
....................       temp.Val += len-1; 
1E00:  MOVLW  01
1E02:  SUBWF  x91,W
1E04:  MOVWF  00
1E06:  MOVLW  00
1E08:  SUBWFB x92,W
1E0A:  MOVWF  03
1E0C:  MOVF   00,W
1E0E:  ADDWF  x93,F
1E10:  MOVF   03,W
1E12:  ADDWFC x94,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
1E14:  MOVLW  12
1E16:  MOVWF  xB6
1E18:  MOVFF  393,3B7
1E1C:  MOVLB  0
1E1E:  CALL   0668
....................    WriteReg(EDMANDH, temp.v[1]); 
1E22:  MOVLW  13
1E24:  MOVLB  3
1E26:  MOVWF  xB6
1E28:  MOVFF  394,3B7
1E2C:  MOVLB  0
1E2E:  CALL   0668
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1E32:  MOVLW  1F
1E34:  MOVLB  3
1E36:  MOVWF  xB8
1E38:  MOVLW  30
1E3A:  MOVWF  xB9
1E3C:  MOVLB  0
1E3E:  CALL   069C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1E42:  MOVLW  1F
1E44:  MOVLB  3
1E46:  MOVWF  xB0
1E48:  MOVLB  0
1E4A:  CALL   0608
1E4E:  MOVFF  01,395
1E52:  MOVLW  00
1E54:  MOVLB  3
1E56:  BTFSC  01.5
1E58:  MOVLW  01
1E5A:  XORLW  00
1E5C:  BTFSC  FD8.2
1E5E:  BRA    1E64
1E60:  MOVLB  0
1E62:  BRA    1E42
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
1E64:  MOVLW  16
1E66:  MOVWF  xB0
1E68:  MOVLB  0
1E6A:  CALL   0608
1E6E:  MOVFF  01,393
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
1E72:  MOVLW  17
1E74:  MOVLB  3
1E76:  MOVWF  xB0
1E78:  MOVLB  0
1E7A:  CALL   0608
1E7E:  MOVFF  01,394
....................    return temp.Val; 
1E82:  MOVLB  3
1E84:  MOVFF  393,01
1E88:  MOVFF  394,02
.................... } 
1E8C:  MOVLB  0
1E8E:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
1D10:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
1D12:  MOVLW  3A
1D14:  MOVLB  3
1D16:  MOVWF  xBB
1D18:  MOVLB  0
1D1A:  CALL   05F8
....................    c=ENCSPIXfer(0); 
1D1E:  MOVLB  3
1D20:  CLRF   xBB
1D22:  MOVLB  0
1D24:  CALL   05F8
1D28:  MOVFF  01,395
....................    SPIUnselectEthernet(); 
1D2C:  BSF    F8B.1
....................    return(c); 
1D2E:  MOVLB  3
1D30:  MOVFF  395,01
.................... }//end MACGet 
1D34:  MOVLB  0
1D36:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
0F2E:  MOVLB  3
0F30:  CLRF   xA3
0F32:  CLRF   xA4
....................  
....................    SPISelectEthernet(); 
0F34:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
0F36:  MOVLW  3A
0F38:  MOVWF  xBB
0F3A:  MOVLB  0
0F3C:  CALL   05F8
....................    while(i<len) 
....................    { 
0F40:  MOVLB  3
0F42:  MOVF   xA4,W
0F44:  SUBWF  xA2,W
0F46:  BNC   0F80
0F48:  BNZ   0F50
0F4A:  MOVF   xA1,W
0F4C:  SUBWF  xA3,W
0F4E:  BC    0F80
....................       *val=ENCSPIXfer(0); 
0F50:  MOVFF  3A0,03
0F54:  MOVFF  39F,3A5
0F58:  MOVFF  3A0,3A6
0F5C:  CLRF   xBB
0F5E:  MOVLB  0
0F60:  CALL   05F8
0F64:  MOVFF  3A6,FEA
0F68:  MOVFF  3A5,FE9
0F6C:  MOVFF  01,FEF
....................       val++; 
0F70:  MOVLB  3
0F72:  INCF   x9F,F
0F74:  BTFSC  FD8.2
0F76:  INCF   xA0,F
....................       i++; 
0F78:  INCF   xA3,F
0F7A:  BTFSC  FD8.2
0F7C:  INCF   xA4,F
....................    } 
0F7E:  BRA    0F42
....................    SPIUnselectEthernet(); 
0F80:  BSF    F8B.1
....................  
....................    return(i); 
0F82:  MOVFF  3A3,01
0F86:  MOVFF  3A4,02
.................... }//end MACGetArray 
0F8A:  MOVLB  0
0F8C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
1364:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
1366:  MOVLW  7A
1368:  MOVLB  3
136A:  MOVWF  xBB
136C:  MOVLB  0
136E:  CALL   05F8
....................    ENCSPIXfer(val); 
1372:  MOVFF  3B4,3BB
1376:  CALL   05F8
....................    SPIUnselectEthernet(); 
137A:  BSF    F8B.1
.................... }//end MACPut 
137C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
137E:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
1380:  MOVLW  7A
1382:  MOVLB  3
1384:  MOVWF  xBB
1386:  MOVLB  0
1388:  CALL   05F8
....................    while(len--) 
....................    { 
138C:  MOVLB  3
138E:  MOVFF  3B8,03
1392:  MOVF   xB7,W
1394:  BTFSC  FD8.2
1396:  DECF   xB8,F
1398:  DECF   xB7,F
139A:  IORWF  03,W
139C:  BZ    13C2
....................       ENCSPIXfer(*val); 
139E:  MOVFF  3B6,03
13A2:  MOVFF  3B5,FE9
13A6:  MOVFF  3B6,FEA
13AA:  MOVFF  FEF,3B9
13AE:  MOVFF  3B9,3BB
13B2:  MOVLB  0
13B4:  CALL   05F8
....................       val++; 
13B8:  MOVLB  3
13BA:  INCF   xB5,F
13BC:  BTFSC  FD8.2
13BE:  INCF   xB6,F
....................    } 
13C0:  BRA    138E
....................    SPIUnselectEthernet(); 
13C2:  BSF    F8B.1
.................... }//end MACPutArray 
13C4:  MOVLB  0
13C6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
062E:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
0630:  MOVLW  FF
0632:  MOVLB  3
0634:  MOVWF  xBB
0636:  MOVLB  0
0638:  RCALL  05F8
....................    SPIUnselectEthernet(); 
063A:  BSF    F8B.1
.................... }//end SendSystemReset 
063C:  GOTO   0910 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
0608:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
060A:  MOVFF  3B0,3B2
060E:  MOVFF  3B0,3BB
0612:  MOVLB  0
0614:  RCALL  05F8
....................    c=ENCSPIXfer(0); 
0616:  MOVLB  3
0618:  CLRF   xBB
061A:  MOVLB  0
061C:  RCALL  05F8
061E:  MOVFF  01,3B1
....................    SPIUnselectEthernet(); 
0622:  BSF    F8B.1
....................    return(c); 
0624:  MOVLB  3
0626:  MOVFF  3B1,01
.................... }//end ReadETHReg 
062A:  MOVLB  0
062C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
06EC:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
06EE:  MOVFF  30A,30C
06F2:  MOVFF  30A,3BB
06F6:  MOVLB  0
06F8:  RCALL  05F8
....................    ENCSPIXfer(0); 
06FA:  MOVLB  3
06FC:  CLRF   xBB
06FE:  MOVLB  0
0700:  RCALL  05F8
....................    c=ENCSPIXfer(0); 
0702:  MOVLB  3
0704:  CLRF   xBB
0706:  MOVLB  0
0708:  RCALL  05F8
070A:  MOVFF  01,30B
....................  
....................    SPIUnselectEthernet(); 
070E:  BSF    F8B.1
....................  
....................    return(c); 
0710:  MOVLB  3
0712:  MOVFF  30B,01
.................... }//end ReadMACReg 
0716:  MOVLB  0
0718:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
07AC:  MOVLW  02
07AE:  MOVLB  3
07B0:  MOVWF  xB4
07B2:  MOVLW  14
07B4:  MOVWF  xB3
07B6:  MOVLB  0
07B8:  RCALL  06B6
....................    WriteReg(MIREGADR, Register); 
07BA:  MOVLW  14
07BC:  MOVLB  3
07BE:  MOVWF  xB6
07C0:  MOVFF  307,3B7
07C4:  MOVLB  0
07C6:  RCALL  0668
....................    WriteReg(MICMD, MICMD_MIIRD); 
07C8:  MOVLW  12
07CA:  MOVLB  3
07CC:  MOVWF  xB6
07CE:  MOVLW  01
07D0:  MOVWF  xB7
07D2:  MOVLB  0
07D4:  RCALL  0668
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
07D6:  MOVLW  03
07D8:  MOVLB  3
07DA:  MOVWF  xB4
07DC:  MOVLW  0A
07DE:  MOVWF  xB3
07E0:  MOVLB  0
07E2:  RCALL  06B6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
07E4:  MOVLW  0A
07E6:  MOVLB  3
07E8:  MOVWF  x0A
07EA:  MOVLB  0
07EC:  RCALL  06EC
07EE:  MOVFF  01,30A
07F2:  MOVLW  00
07F4:  MOVLB  3
07F6:  BTFSC  01.0
07F8:  MOVLW  01
07FA:  XORLW  00
07FC:  BTFSC  FD8.2
07FE:  BRA    0804
0800:  MOVLB  0
0802:  BRA    07E4
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
0804:  MOVLW  02
0806:  MOVWF  xB4
0808:  MOVLW  14
080A:  MOVWF  xB3
080C:  MOVLB  0
080E:  RCALL  06B6
....................    WriteReg(MICMD, 0x00); 
0810:  MOVLW  12
0812:  MOVLB  3
0814:  MOVWF  xB6
0816:  CLRF   xB7
0818:  MOVLB  0
081A:  RCALL  0668
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
081C:  MOVLW  18
081E:  MOVLB  3
0820:  MOVWF  x0A
0822:  MOVLB  0
0824:  RCALL  06EC
0826:  MOVFF  01,308
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
082A:  MOVLW  19
082C:  MOVLB  3
082E:  MOVWF  x0A
0830:  MOVLB  0
0832:  RCALL  06EC
0834:  MOVFF  01,309
....................    return Result; 
0838:  MOVLB  3
083A:  MOVFF  308,01
083E:  MOVFF  309,02
.................... }//end ReadPHYReg 
0842:  MOVLB  0
0844:  GOTO   085E (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0668:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
066A:  MOVLB  3
066C:  MOVF   xB6,W
066E:  IORLW  40
0670:  MOVWF  xB8
0672:  MOVWF  xBB
0674:  MOVLB  0
0676:  RCALL  05F8
....................    ENCSPIXfer(Data); 
0678:  MOVFF  3B7,3BB
067C:  RCALL  05F8
....................    SPIUnselectEthernet(); 
067E:  BSF    F8B.1
.................... }//end WriteReg 
0680:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0682:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
0684:  MOVLB  3
0686:  MOVF   xB5,W
0688:  IORLW  A0
068A:  MOVWF  xB7
068C:  MOVWF  xBB
068E:  MOVLB  0
0690:  RCALL  05F8
....................    ENCSPIXfer(Data); 
0692:  MOVFF  3B6,3BB
0696:  RCALL  05F8
....................    SPIUnselectEthernet(); 
0698:  BSF    F8B.1
.................... }//end BFCReg 
069A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
069C:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
069E:  MOVLB  3
06A0:  MOVF   xB8,W
06A2:  IORLW  80
06A4:  MOVWF  xBA
06A6:  MOVWF  xBB
06A8:  MOVLB  0
06AA:  RCALL  05F8
....................    ENCSPIXfer(Data); 
06AC:  MOVFF  3B9,3BB
06B0:  RCALL  05F8
....................    SPIUnselectEthernet(); 
06B2:  BSF    F8B.1
.................... }//end BFSReg 
06B4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
071A:  MOVLW  02
071C:  MOVLB  3
071E:  MOVWF  xB4
0720:  MOVLW  14
0722:  MOVWF  xB3
0724:  MOVLB  0
0726:  RCALL  06B6
....................    WriteReg(MIREGADR, Register); 
0728:  MOVLW  14
072A:  MOVLB  3
072C:  MOVWF  xB6
072E:  MOVFF  307,3B7
0732:  MOVLB  0
0734:  RCALL  0668
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
0736:  MOVLW  03
0738:  MOVLB  3
073A:  MOVWF  x0B
073C:  MOVLW  08
073E:  MOVWF  FE9
0740:  MOVFF  30B,FEA
0744:  MOVFF  FEF,30C
0748:  MOVLW  16
074A:  MOVWF  xB6
074C:  MOVFF  30C,3B7
0750:  MOVLB  0
0752:  RCALL  0668
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0754:  MOVLW  03
0756:  MOVLB  3
0758:  MOVWF  x0B
075A:  MOVLW  08
075C:  MOVWF  x0A
075E:  MOVLW  01
0760:  ADDWF  x0A,W
0762:  MOVWF  FE9
0764:  MOVLW  00
0766:  ADDWFC x0B,W
0768:  MOVWF  FEA
076A:  MOVFF  FEF,30C
076E:  MOVLW  17
0770:  MOVWF  xB6
0772:  MOVFF  30C,3B7
0776:  MOVLB  0
0778:  RCALL  0668
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
077A:  MOVLW  03
077C:  MOVLB  3
077E:  MOVWF  xB4
0780:  MOVLW  0A
0782:  MOVWF  xB3
0784:  MOVLB  0
0786:  RCALL  06B6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0788:  MOVLW  0A
078A:  MOVLB  3
078C:  MOVWF  x0A
078E:  MOVLB  0
0790:  RCALL  06EC
0792:  MOVFF  01,30A
0796:  MOVLW  00
0798:  MOVLB  3
079A:  BTFSC  01.0
079C:  MOVLW  01
079E:  XORLW  00
07A0:  BTFSC  FD8.2
07A2:  BRA    07A8
07A4:  MOVLB  0
07A6:  BRA    0788
.................... }//end WritePHYReg 
07A8:  MOVLB  0
07AA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
06B6:  MOVLW  1F
06B8:  MOVLB  3
06BA:  MOVWF  xB5
06BC:  MOVLW  03
06BE:  MOVWF  xB6
06C0:  MOVLB  0
06C2:  RCALL  0682
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
06C4:  MOVLW  03
06C6:  MOVLB  3
06C8:  MOVWF  xB6
06CA:  MOVLW  B3
06CC:  MOVWF  xB5
06CE:  MOVLW  01
06D0:  ADDWF  xB5,W
06D2:  MOVWF  FE9
06D4:  MOVLW  00
06D6:  ADDWFC xB6,W
06D8:  MOVWF  FEA
06DA:  MOVFF  FEF,3B7
06DE:  MOVLW  1F
06E0:  MOVWF  xB8
06E2:  MOVFF  3B7,3B9
06E6:  MOVLB  0
06E8:  RCALL  069C
.................... }//end BankSel 
06EA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0848:  MOVLW  1F
084A:  MOVLB  3
084C:  MOVWF  xB5
084E:  MOVLW  0C
0850:  MOVWF  xB6
0852:  MOVLB  0
0854:  RCALL  0682
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0856:  MOVLB  3
0858:  CLRF   x07
085A:  MOVLB  0
085C:  BRA    07AC
085E:  MOVFF  02,306
0862:  MOVFF  01,305
....................    if(DuplexState == USE_PHY) 
0866:  MOVLB  3
0868:  MOVF   x03,W
086A:  SUBLW  02
086C:  BNZ   0876
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
086E:  CLRF   x03
0870:  BTFSC  x06.0
0872:  INCF   x03,F
....................    } 
....................    else 
0874:  BRA    088C
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0876:  BCF    x06.0
0878:  BTFSC  x03.0
087A:  BSF    x06.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
087C:  CLRF   x07
087E:  MOVFF  306,309
0882:  MOVFF  305,308
0886:  MOVLB  0
0888:  RCALL  071A
088A:  MOVLB  3
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
088C:  MOVLW  02
088E:  MOVWF  xB4
0890:  MOVWF  xB3
0892:  MOVLB  0
0894:  RCALL  06B6
....................    Register = ReadMACReg(MACON3); 
0896:  MOVLW  02
0898:  MOVLB  3
089A:  MOVWF  x0A
089C:  MOVLB  0
089E:  RCALL  06EC
08A0:  MOVFF  01,304
....................    Register.MACON3bits.FULDPX = DuplexState; 
08A4:  MOVLB  3
08A6:  BCF    x04.0
08A8:  BTFSC  x03.0
08AA:  BSF    x04.0
....................    WriteReg(MACON3, Register.Val); 
08AC:  MOVLW  02
08AE:  MOVWF  xB6
08B0:  MOVFF  304,3B7
08B4:  MOVLB  0
08B6:  RCALL  0668
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
08B8:  MOVLB  3
08BA:  MOVF   x03,F
08BC:  BZ    08C2
08BE:  MOVLW  15
08C0:  BRA    08C4
08C2:  MOVLW  12
08C4:  MOVWF  x07
08C6:  MOVLW  04
08C8:  MOVWF  xB6
08CA:  MOVFF  307,3B7
08CE:  MOVLB  0
08D0:  RCALL  0668
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
08D2:  MOVLW  1F
08D4:  MOVLB  3
08D6:  MOVWF  xB8
08D8:  MOVLW  04
08DA:  MOVWF  xB9
08DC:  MOVLB  0
08DE:  RCALL  069C
.................... }//end MACSetDuplex 
08E0:  GOTO   0AA0 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
1B42:  MOVLW  03
1B44:  MOVLB  3
1B46:  MOVWF  x27
1B48:  MOVLW  12
1B4A:  MOVFF  327,3A0
1B4E:  MOVWF  x9F
1B50:  CLRF   xA2
1B52:  MOVLW  14
1B54:  MOVWF  xA1
1B56:  MOVLB  0
1B58:  CALL   0F2E
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
1B5C:  MOVLB  3
1B5E:  MOVF   x12,W
1B60:  ANDLW  F0
1B62:  SUBLW  40
1B64:  BZ    1B6C
....................     	return FALSE; 
1B66:  MOVLW  00
1B68:  MOVWF  01
1B6A:  BRA    1C1C
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
1B6C:  MOVF   x12,W
1B6E:  ANDLW  0F
1B70:  MOVWF  00
1B72:  RLCF   00,W
1B74:  MOVWF  5C
1B76:  RLCF   5C,F
1B78:  MOVLW  FC
1B7A:  ANDWF  5C,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
1B7C:  CLRF   x62
1B7E:  CLRF   x61
1B80:  CLRF   x64
1B82:  MOVFF  5C,363
1B86:  MOVLB  0
1B88:  RCALL  18DE
1B8A:  MOVFF  02,311
1B8E:  MOVFF  01,310
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
1B92:  MOVLB  3
1B94:  CLRF   x3A
1B96:  MOVFF  5C,339
1B9A:  MOVLB  0
1B9C:  RCALL  19E6
....................  
....................     if(CalcChecksum.Val) 
1B9E:  MOVLB  3
1BA0:  MOVF   x10,W
1BA2:  IORWF  x11,W
1BA4:  BZ    1BAC
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
1BA6:  MOVLW  00
1BA8:  MOVWF  01
1BAA:  BRA    1C1C
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
1BAC:  MOVLW  03
1BAE:  MOVWF  xAB
1BB0:  MOVLW  12
1BB2:  MOVWF  xAA
1BB4:  MOVLB  0
1BB6:  RCALL  1A62
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
1BB8:  MOVLB  3
1BBA:  MOVF   x08,W
1BBC:  IORWF  x09,W
1BBE:  BZ    1BD8
....................         localIP->Val    = header.DestAddress.Val; 
1BC0:  MOVFF  308,FE9
1BC4:  MOVFF  309,FEA
1BC8:  MOVFF  322,FEF
1BCC:  MOVFF  323,FEC
1BD0:  MOVFF  324,FEC
1BD4:  MOVFF  325,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
1BD8:  MOVLW  06
1BDA:  ADDWF  x0A,W
1BDC:  MOVWF  FE9
1BDE:  MOVLW  00
1BE0:  ADDWFC x0B,W
1BE2:  MOVWF  FEA
1BE4:  MOVFF  31E,FEF
1BE8:  MOVFF  31F,FEC
1BEC:  MOVFF  320,FEC
1BF0:  MOVFF  321,FEC
....................     *protocol           = header.Protocol; 
1BF4:  MOVFF  30C,FE9
1BF8:  MOVFF  30D,FEA
1BFC:  MOVFF  31B,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
1C00:  MOVFF  30E,FE9
1C04:  MOVFF  30F,FEA
1C08:  MOVF   5C,W
1C0A:  SUBWF  x14,W
1C0C:  MOVWF  00
1C0E:  MOVLW  00
1C10:  SUBWFB x15,W
1C12:  MOVFF  00,FEF
1C16:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
1C18:  MOVLW  01
1C1A:  MOVWF  01
.................... } 
1C1C:  MOVLB  0
1C1E:  GOTO   69BE (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
260A:  MOVLW  14
260C:  MOVWF  5C
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
260E:  MOVLW  45
2610:  MOVLB  3
2612:  MOVWF  x96
....................     header.TypeOfService    = IP_SERVICE; 
2614:  CLRF   x97
....................     header.TotalLength      = sizeof(header) + len; 
2616:  MOVLW  14
2618:  ADDWF  x94,W
261A:  MOVWF  x98
261C:  MOVLW  00
261E:  ADDWFC x95,W
2620:  MOVWF  x99
....................     header.Identification   = ++_Identifier; 
2622:  INCF   5A,F
2624:  BTFSC  FD8.2
2626:  INCF   5B,F
2628:  MOVFF  5B,39B
262C:  MOVFF  5A,39A
....................     header.FragmentInfo     = 0; 
2630:  CLRF   x9D
2632:  CLRF   x9C
....................     header.TimeToLive       = MY_IP_TTL; 
2634:  MOVLW  64
2636:  MOVWF  x9E
....................     header.Protocol         = protocol; 
2638:  MOVFF  393,39F
....................     header.HeaderChecksum   = 0; 
263C:  CLRF   xA1
263E:  CLRF   xA0
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
2640:  MOVFF  1B,3A5
2644:  MOVFF  1A,3A4
2648:  MOVFF  19,3A3
264C:  MOVFF  18,3A2
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
2650:  MOVLW  06
2652:  ADDWF  x91,W
2654:  MOVWF  FE9
2656:  MOVLW  00
2658:  ADDWFC x92,W
265A:  MOVWF  FEA
265C:  MOVFF  FEF,00
2660:  MOVFF  FEC,01
2664:  MOVFF  FEC,02
2668:  MOVFF  FEC,03
266C:  MOVFF  03,3A9
2670:  MOVFF  02,3A8
2674:  MOVFF  01,3A7
2678:  MOVFF  00,3A6
....................  
....................     SwapIPHeader(&header); 
267C:  MOVLW  03
267E:  MOVWF  xAB
2680:  MOVLW  96
2682:  MOVWF  xAA
2684:  MOVLB  0
2686:  CALL   1A62
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
268A:  MOVLB  3
268C:  MOVFF  391,01
2690:  MOVFF  392,03
2694:  MOVFF  391,3AA
2698:  MOVFF  392,3AB
269C:  MOVLW  14
269E:  ADDWF  x94,W
26A0:  MOVWF  xAC
26A2:  MOVLW  00
26A4:  ADDWFC x95,W
26A6:  MOVWF  xAD
26A8:  MOVFF  392,3AF
26AC:  MOVFF  391,3AE
26B0:  CLRF   xB0
26B2:  MOVWF  xB2
26B4:  MOVFF  3AC,3B1
26B8:  MOVLB  0
26BA:  CALL   13C8
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
26BE:  MOVLW  03
26C0:  MOVLB  3
26C2:  MOVWF  xAB
26C4:  MOVLW  96
26C6:  MOVFF  3AB,3B6
26CA:  MOVWF  xB5
26CC:  CLRF   xB8
26CE:  MOVLW  14
26D0:  MOVWF  xB7
26D2:  MOVLB  0
26D4:  CALL   137E
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
26D8:  MOVLB  3
26DA:  CLRF   xAB
26DC:  CLRF   xAA
26DE:  CLRF   xAD
26E0:  MOVLW  14
26E2:  MOVWF  xAC
26E4:  MOVLB  0
26E6:  RCALL  2532
26E8:  MOVFF  02,3A1
26EC:  MOVFF  01,3A0
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
26F0:  MOVFF  4F,3AA
26F4:  MOVLB  3
26F6:  CLRF   xAC
26F8:  MOVLW  0A
26FA:  MOVWF  xAB
26FC:  MOVLB  0
26FE:  CALL   12BA
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
2702:  MOVLW  03
2704:  MOVLB  3
2706:  MOVWF  xAB
2708:  MOVLW  A0
270A:  MOVFF  3AB,3B6
270E:  MOVWF  xB5
2710:  CLRF   xB8
2712:  MOVLW  02
2714:  MOVWF  xB7
2716:  MOVLB  0
2718:  CALL   137E
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
271C:  MOVFF  4F,3AA
2720:  MOVLB  3
2722:  CLRF   xAC
2724:  MOVLW  14
2726:  MOVWF  xAB
2728:  MOVLB  0
272A:  CALL   12BA
.................... #endif 
....................  
....................     return 0x0; 
272E:  MOVLW  00
2730:  MOVWF  01
2732:  MOVWF  02
.................... } 
2734:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
1E90:  MOVF   5C,W
1E92:  MOVLB  3
1E94:  ADDWF  x35,W
1E96:  MOVWF  x37
1E98:  MOVLW  00
1E9A:  ADDWFC x36,W
1E9C:  MOVWF  x38
1E9E:  MOVWF  x3A
1EA0:  MOVFF  337,339
1EA4:  MOVLB  0
1EA6:  RCALL  19E6
.................... } 
1EA8:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1A62:  MOVLW  02
1A64:  MOVLB  3
1A66:  ADDWF  xAA,W
1A68:  MOVWF  01
1A6A:  MOVLW  00
1A6C:  ADDWFC xAB,W
1A6E:  MOVWF  03
1A70:  MOVFF  01,3AC
1A74:  MOVWF  xAD
1A76:  MOVLW  02
1A78:  ADDWF  xAA,W
1A7A:  MOVWF  FE9
1A7C:  MOVLW  00
1A7E:  ADDWFC xAB,W
1A80:  MOVWF  FEA
1A82:  MOVFF  FEC,3AF
1A86:  MOVF   FED,F
1A88:  MOVFF  FEF,3AE
1A8C:  MOVFF  3AF,3B1
1A90:  MOVFF  3AE,3B0
1A94:  MOVLB  0
1A96:  CALL   0F8E
1A9A:  MOVFF  3AD,FEA
1A9E:  MOVFF  3AC,FE9
1AA2:  MOVFF  02,FEC
1AA6:  MOVF   FED,F
1AA8:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1AAC:  MOVLW  04
1AAE:  MOVLB  3
1AB0:  ADDWF  xAA,W
1AB2:  MOVWF  01
1AB4:  MOVLW  00
1AB6:  ADDWFC xAB,W
1AB8:  MOVWF  03
1ABA:  MOVFF  01,3AC
1ABE:  MOVWF  xAD
1AC0:  MOVLW  04
1AC2:  ADDWF  xAA,W
1AC4:  MOVWF  FE9
1AC6:  MOVLW  00
1AC8:  ADDWFC xAB,W
1ACA:  MOVWF  FEA
1ACC:  MOVFF  FEC,3AF
1AD0:  MOVF   FED,F
1AD2:  MOVFF  FEF,3AE
1AD6:  MOVFF  3AF,3B1
1ADA:  MOVFF  3AE,3B0
1ADE:  MOVLB  0
1AE0:  CALL   0F8E
1AE4:  MOVFF  3AD,FEA
1AE8:  MOVFF  3AC,FE9
1AEC:  MOVFF  02,FEC
1AF0:  MOVF   FED,F
1AF2:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
1AF6:  MOVLW  0A
1AF8:  MOVLB  3
1AFA:  ADDWF  xAA,W
1AFC:  MOVWF  01
1AFE:  MOVLW  00
1B00:  ADDWFC xAB,W
1B02:  MOVWF  03
1B04:  MOVFF  01,3AC
1B08:  MOVWF  xAD
1B0A:  MOVLW  0A
1B0C:  ADDWF  xAA,W
1B0E:  MOVWF  FE9
1B10:  MOVLW  00
1B12:  ADDWFC xAB,W
1B14:  MOVWF  FEA
1B16:  MOVFF  FEC,3AF
1B1A:  MOVF   FED,F
1B1C:  MOVFF  FEF,3AE
1B20:  MOVFF  3AF,3B1
1B24:  MOVFF  3AE,3B0
1B28:  MOVLB  0
1B2A:  CALL   0F8E
1B2E:  MOVFF  3AD,FEA
1B32:  MOVFF  3AC,FE9
1B36:  MOVFF  02,FEC
1B3A:  MOVF   FED,F
1B3C:  MOVFF  01,FEF
.................... } 
1B40:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
0C00:  MOVLB  3
0C02:  CLRF   x02
0C04:  MOVF   x02,W
0C06:  SUBLW  04
0C08:  BNC   0CDC
....................     { 
....................         ps = &TCB[s]; 
0C0A:  MOVF   x02,W
0C0C:  MULLW  24
0C0E:  MOVF   FF3,W
0C10:  CLRF   03
0C12:  ADDLW  5F
0C14:  MOVWF  01
0C16:  MOVLW  00
0C18:  ADDWFC 03,F
0C1A:  MOVFF  01,303
0C1E:  MOVFF  03,304
....................  
....................         ps->smState             = TCP_CLOSED; 
0C22:  MOVFF  303,FE9
0C26:  MOVFF  304,FEA
0C2A:  MOVLW  0A
0C2C:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
0C2E:  MOVLW  23
0C30:  ADDWF  x03,W
0C32:  MOVWF  FE9
0C34:  MOVLW  00
0C36:  ADDWFC x04,W
0C38:  MOVWF  FEA
0C3A:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
0C3C:  MOVLW  23
0C3E:  ADDWF  x03,W
0C40:  MOVWF  FE9
0C42:  MOVLW  00
0C44:  ADDWFC x04,W
0C46:  MOVWF  FEA
0C48:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
0C4A:  MOVLW  23
0C4C:  ADDWF  x03,W
0C4E:  MOVWF  FE9
0C50:  MOVLW  00
0C52:  ADDWFC x04,W
0C54:  MOVWF  FEA
0C56:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
0C58:  MOVLW  23
0C5A:  ADDWF  x03,W
0C5C:  MOVWF  FE9
0C5E:  MOVLW  00
0C60:  ADDWFC x04,W
0C62:  MOVWF  FEA
0C64:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
0C66:  MOVLW  23
0C68:  ADDWF  x03,W
0C6A:  MOVWF  FE9
0C6C:  MOVLW  00
0C6E:  ADDWFC x04,W
0C70:  MOVWF  FEA
0C72:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
0C74:  MOVLW  0F
0C76:  ADDWF  x03,W
0C78:  MOVWF  FE9
0C7A:  MOVLW  00
0C7C:  ADDWFC x04,W
0C7E:  MOVWF  FEA
0C80:  INCFSZ FEF,W
0C82:  BRA    0C86
0C84:  BRA    0CB2
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
0C86:  MOVLW  0F
0C88:  ADDWF  x03,W
0C8A:  MOVWF  FE9
0C8C:  MOVLW  00
0C8E:  ADDWFC x04,W
0C90:  MOVWF  FEA
0C92:  MOVFF  FEF,305
0C96:  MOVFF  305,355
0C9A:  MOVLB  0
0C9C:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
0CA0:  MOVLW  0F
0CA2:  MOVLB  3
0CA4:  ADDWF  x03,W
0CA6:  MOVWF  FE9
0CA8:  MOVLW  00
0CAA:  ADDWFC x04,W
0CAC:  MOVWF  FEA
0CAE:  MOVLW  FF
0CB0:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
0CB2:  MOVLW  21
0CB4:  ADDWF  x03,W
0CB6:  MOVWF  FE9
0CB8:  MOVLW  00
0CBA:  ADDWFC x04,W
0CBC:  MOVWF  FEA
0CBE:  CLRF   FEC
0CC0:  MOVF   FED,F
0CC2:  MOVLW  1E
0CC4:  MOVWF  FEF
....................       ps->TxCount            = 0; 
0CC6:  MOVLW  10
0CC8:  ADDWF  x03,W
0CCA:  MOVWF  FE9
0CCC:  MOVLW  00
0CCE:  ADDWFC x04,W
0CD0:  MOVWF  FEA
0CD2:  CLRF   FEC
0CD4:  MOVF   FED,F
0CD6:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
0CD8:  INCF   x02,F
0CDA:  BRA    0C04
....................     TCPInit_RandSeed+=get_timer0(); 
0CDC:  MOVF   FD6,W
0CDE:  MOVLB  1
0CE0:  ADDWF  x13,F
0CE2:  MOVF   FD7,W
0CE4:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0CE6:  MOVF   FCE,W
0CE8:  ADDWF  x13,F
0CEA:  MOVF   FCF,W
0CEC:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0CEE:  MOVF   FCC,W
0CF0:  ADDWF  x13,F
0CF2:  MOVLW  00
0CF4:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0CF6:  MOVF   FB2,W
0CF8:  ADDWF  x13,F
0CFA:  MOVF   FB3,W
0CFC:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
0CFE:  MOVLB  3
0D00:  CLRF   x08
0D02:  CLRF   x07
0D04:  MOVFF  114,306
0D08:  MOVFF  113,305
0D0C:  MOVLB  0
0D0E:  BRA    0AD2
....................     _NextPort=rand(); 
0D10:  BRA    0B8C
0D12:  MOVFF  02,5E
0D16:  MOVFF  01,5D
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
0D1A:  MOVLW  04
0D1C:  ADDWF  5E,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
0D1E:  MOVF   5E,W
0D20:  SUBLW  12
0D22:  BC    0D38
0D24:  XORLW  FF
0D26:  BNZ   0D2E
0D28:  MOVF   5D,W
0D2A:  SUBLW  87
0D2C:  BC    0D38
0D2E:  MOVLW  88
0D30:  SUBWF  5D,F
0D32:  MOVLW  13
0D34:  SUBWFB 5E,F
0D36:  BRA    0D1E
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
0D38:  MOVF   5E,W
0D3A:  SUBLW  03
0D3C:  BNC   0D42
0D3E:  MOVLW  04
0D40:  ADDWF  5E,F
.................... } 
0D42:  GOTO   0EBC (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0D46:  MOVLB  3
0D48:  CLRF   x07
0D4A:  MOVF   x07,W
0D4C:  SUBLW  04
0D4E:  BNC   0E38
....................    { 
....................       ps = &TCB[s]; 
0D50:  MOVF   x07,W
0D52:  MULLW  24
0D54:  MOVF   FF3,W
0D56:  CLRF   03
0D58:  ADDLW  5F
0D5A:  MOVWF  01
0D5C:  MOVLW  00
0D5E:  ADDWFC 03,F
0D60:  MOVFF  01,308
0D64:  MOVFF  03,309
....................  
....................       if(ps->smState == TCP_CLOSED) 
0D68:  MOVFF  308,FE9
0D6C:  MOVFF  309,FEA
0D70:  MOVF   FEF,W
0D72:  SUBLW  0A
0D74:  BNZ   0E34
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
0D76:  MOVFF  308,FE9
0D7A:  MOVFF  309,FEA
0D7E:  CLRF   FEF
....................          ps->localPort           = port; 
0D80:  MOVLW  0B
0D82:  ADDWF  x08,W
0D84:  MOVWF  FE9
0D86:  MOVLW  00
0D88:  ADDWFC x09,W
0D8A:  MOVWF  FEA
0D8C:  MOVFF  306,FEC
0D90:  MOVF   FED,F
0D92:  MOVFF  305,FEF
....................          ps->remotePort          = 0; 
0D96:  MOVLW  0D
0D98:  ADDWF  x08,W
0D9A:  MOVWF  FE9
0D9C:  MOVLW  00
0D9E:  ADDWFC x09,W
0DA0:  MOVWF  FEA
0DA2:  CLRF   FEC
0DA4:  MOVF   FED,F
0DA6:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
0DA8:  MOVLW  07
0DAA:  ADDWF  x08,W
0DAC:  MOVWF  FE9
0DAE:  MOVLW  00
0DB0:  ADDWFC x09,W
0DB2:  MOVWF  FEA
0DB4:  MOVF   FEE,F
0DB6:  MOVF   FEE,F
0DB8:  CLRF   FEC
0DBA:  MOVF   FED,F
0DBC:  CLRF   FEF
0DBE:  MOVF   FED,F
0DC0:  CLRF   FEF
0DC2:  MOVF   FED,F
0DC4:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
0DC6:  MOVLW  23
0DC8:  ADDWF  x08,W
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC x09,W
0DD0:  MOVWF  FEA
0DD2:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
0DD4:  MOVLW  23
0DD6:  ADDWF  x08,W
0DD8:  MOVWF  FE9
0DDA:  MOVLW  00
0DDC:  ADDWFC x09,W
0DDE:  MOVWF  FEA
0DE0:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
0DE2:  MOVLW  0F
0DE4:  ADDWF  x08,W
0DE6:  MOVWF  FE9
0DE8:  MOVLW  00
0DEA:  ADDWFC x09,W
0DEC:  MOVWF  FEA
0DEE:  INCFSZ FEF,W
0DF0:  BRA    0DF4
0DF2:  BRA    0E20
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
0DF4:  MOVLW  0F
0DF6:  ADDWF  x08,W
0DF8:  MOVWF  FE9
0DFA:  MOVLW  00
0DFC:  ADDWFC x09,W
0DFE:  MOVWF  FEA
0E00:  MOVFF  FEF,30A
0E04:  MOVFF  30A,355
0E08:  MOVLB  0
0E0A:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
0E0E:  MOVLW  0F
0E10:  MOVLB  3
0E12:  ADDWF  x08,W
0E14:  MOVWF  FE9
0E16:  MOVLW  00
0E18:  ADDWFC x09,W
0E1A:  MOVWF  FEA
0E1C:  MOVLW  FF
0E1E:  MOVWF  FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
0E20:  MOVLW  23
0E22:  ADDWF  x08,W
0E24:  MOVWF  FE9
0E26:  MOVLW  00
0E28:  ADDWFC x09,W
0E2A:  MOVWF  FEA
0E2C:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
0E2E:  MOVFF  307,01
0E32:  BRA    0E3C
....................       } 
....................    } 
0E34:  INCF   x07,F
0E36:  BRA    0D4A
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
0E38:  MOVLW  FE
0E3A:  MOVWF  01
.................... } 
0E3C:  MOVLB  0
0E3E:  GOTO   0E68 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
3D7A:  MOVLB  3
3D7C:  MOVF   x10,W
3D7E:  MULLW  24
3D80:  MOVF   FF3,W
3D82:  CLRF   x12
3D84:  MOVWF  x11
3D86:  MOVLW  5F
3D88:  ADDWF  x11,W
3D8A:  MOVWF  FE9
3D8C:  MOVLW  00
3D8E:  ADDWFC x12,W
3D90:  MOVWF  FEA
3D92:  MOVF   FEF,W
3D94:  SUBLW  03
3D96:  BZ    3D9C
3D98:  MOVLW  00
3D9A:  BRA    3D9E
3D9C:  MOVLW  01
3D9E:  MOVWF  01
.................... } 
3DA0:  MOVLB  0
3DA2:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
5B8C:  MOVLB  3
5B8E:  MOVF   x10,W
5B90:  MULLW  24
5B92:  MOVF   FF3,W
5B94:  CLRF   03
5B96:  ADDLW  5F
5B98:  MOVWF  01
5B9A:  MOVLW  00
5B9C:  ADDWFC 03,F
5B9E:  MOVFF  01,311
5BA2:  MOVFF  03,312
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
5BA6:  MOVFF  311,FE9
5BAA:  MOVFF  312,FEA
5BAE:  MOVF   FEF,W
5BB0:  SUBLW  03
5BB2:  BZ    5BD2
5BB4:  MOVFF  311,FE9
5BB8:  MOVFF  312,FEA
5BBC:  MOVF   FEF,W
5BBE:  SUBLW  02
5BC0:  BZ    5BD2
....................    { 
....................       CloseSocket(ps); 
5BC2:  MOVFF  312,353
5BC6:  MOVFF  311,352
5BCA:  MOVLB  0
5BCC:  CALL   22EA
....................       return; 
5BD0:  BRA    5CC4
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
5BD2:  MOVFF  310,313
5BD6:  MOVLB  0
5BD8:  CALL   4D2C
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
5BDC:  MOVLW  01
5BDE:  MOVLB  3
5BE0:  ADDWF  x11,W
5BE2:  MOVWF  01
5BE4:  MOVLW  00
5BE6:  ADDWFC x12,W
5BE8:  MOVWF  03
5BEA:  MOVFF  01,313
5BEE:  MOVWF  x14
5BF0:  MOVLW  0B
5BF2:  ADDWF  x11,W
5BF4:  MOVWF  FE9
5BF6:  MOVLW  00
5BF8:  ADDWFC x12,W
5BFA:  MOVWF  FEA
5BFC:  MOVFF  FEC,316
5C00:  MOVF   FED,F
5C02:  MOVFF  FEF,315
5C06:  MOVLW  0D
5C08:  ADDWF  x11,W
5C0A:  MOVWF  FE9
5C0C:  MOVLW  00
5C0E:  ADDWFC x12,W
5C10:  MOVWF  FEA
5C12:  MOVFF  FEC,318
5C16:  MOVF   FED,F
5C18:  MOVFF  FEF,317
5C1C:  MOVLW  16
5C1E:  ADDWF  x11,W
5C20:  MOVWF  FE9
5C22:  MOVLW  00
5C24:  ADDWFC x12,W
5C26:  MOVWF  FEA
5C28:  MOVFF  FEF,319
5C2C:  MOVFF  FEC,31A
5C30:  MOVFF  FEC,31B
5C34:  MOVFF  FEC,31C
5C38:  MOVLW  1A
5C3A:  ADDWF  x11,W
5C3C:  MOVWF  FE9
5C3E:  MOVLW  00
5C40:  ADDWFC x12,W
5C42:  MOVWF  FEA
5C44:  MOVFF  FEF,31D
5C48:  MOVFF  FEC,31E
5C4C:  MOVFF  FEC,31F
5C50:  MOVFF  FEC,320
5C54:  MOVFF  03,35A
5C58:  MOVFF  01,359
5C5C:  MOVFF  316,35C
5C60:  MOVFF  315,35B
5C64:  MOVFF  318,35E
5C68:  MOVFF  317,35D
5C6C:  MOVFF  31C,362
5C70:  MOVFF  31B,361
5C74:  MOVFF  31A,360
5C78:  MOVFF  319,35F
5C7C:  MOVFF  320,366
5C80:  MOVFF  31F,365
5C84:  MOVFF  31E,364
5C88:  MOVFF  31D,363
5C8C:  MOVLW  11
5C8E:  MOVWF  x67
5C90:  MOVLW  FF
5C92:  MOVWF  x68
5C94:  CLRF   x6A
5C96:  CLRF   x69
5C98:  MOVLB  0
5C9A:  CALL   2736
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
5C9E:  MOVLW  16
5CA0:  MOVLB  3
5CA2:  ADDWF  x11,W
5CA4:  MOVWF  FE9
5CA6:  MOVLW  00
5CA8:  ADDWFC x12,W
5CAA:  MOVWF  FEA
5CAC:  MOVLW  01
5CAE:  ADDWF  FEE,F
5CB0:  MOVLW  00
5CB2:  ADDWFC FEE,F
5CB4:  ADDWFC FEE,F
5CB6:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
5CB8:  MOVFF  311,FE9
5CBC:  MOVFF  312,FEA
5CC0:  MOVLW  04
5CC2:  MOVWF  FEF
5CC4:  MOVLB  0
....................  
....................    return; 
.................... } 
5CC6:  GOTO   68F2 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
4E20:  MOVLB  3
4E22:  MOVF   x45,W
4E24:  MULLW  24
4E26:  MOVF   FF3,W
4E28:  CLRF   03
4E2A:  ADDLW  5F
4E2C:  MOVWF  01
4E2E:  MOVLW  00
4E30:  ADDWFC 03,F
4E32:  MOVFF  01,346
4E36:  MOVFF  03,347
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
4E3A:  MOVLW  0F
4E3C:  ADDWF  x46,W
4E3E:  MOVWF  FE9
4E40:  MOVLW  00
4E42:  ADDWFC x47,W
4E44:  MOVWF  FEA
4E46:  INCFSZ FEF,W
4E48:  BRA    4E50
....................       return FALSE; 
4E4A:  MOVLW  00
4E4C:  MOVWF  01
4E4E:  BRA    4FE6
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
4E50:  MOVLW  23
4E52:  ADDWF  x46,W
4E54:  MOVWF  FE9
4E56:  MOVLW  00
4E58:  ADDWFC x47,W
4E5A:  MOVWF  FEA
4E5C:  MOVLW  00
4E5E:  BTFSC  FEF.1
4E60:  MOVLW  01
4E62:  ANDLW  01
4E64:  BNZ   4E6C
....................       return FALSE; 
4E66:  MOVLW  00
4E68:  MOVWF  01
4E6A:  BRA    4FE6
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
4E6C:  MOVLW  01
4E6E:  ADDWF  x46,W
4E70:  MOVWF  01
4E72:  MOVLW  00
4E74:  ADDWFC x47,W
4E76:  MOVWF  03
4E78:  MOVFF  01,348
4E7C:  MOVWF  x49
4E7E:  MOVLW  0B
4E80:  ADDWF  x46,W
4E82:  MOVWF  FE9
4E84:  MOVLW  00
4E86:  ADDWFC x47,W
4E88:  MOVWF  FEA
4E8A:  MOVFF  FEC,34B
4E8E:  MOVF   FED,F
4E90:  MOVFF  FEF,34A
4E94:  MOVLW  0D
4E96:  ADDWF  x46,W
4E98:  MOVWF  FE9
4E9A:  MOVLW  00
4E9C:  ADDWFC x47,W
4E9E:  MOVWF  FEA
4EA0:  MOVFF  FEC,34D
4EA4:  MOVF   FED,F
4EA6:  MOVFF  FEF,34C
4EAA:  MOVLW  16
4EAC:  ADDWF  x46,W
4EAE:  MOVWF  FE9
4EB0:  MOVLW  00
4EB2:  ADDWFC x47,W
4EB4:  MOVWF  FEA
4EB6:  MOVFF  FEF,34E
4EBA:  MOVFF  FEC,34F
4EBE:  MOVFF  FEC,350
4EC2:  MOVFF  FEC,351
4EC6:  MOVLW  1A
4EC8:  ADDWF  x46,W
4ECA:  MOVWF  FE9
4ECC:  MOVLW  00
4ECE:  ADDWFC x47,W
4ED0:  MOVWF  FEA
4ED2:  MOVFF  FEF,352
4ED6:  MOVFF  FEC,353
4EDA:  MOVFF  FEC,354
4EDE:  MOVFF  FEC,355
4EE2:  MOVLW  0F
4EE4:  ADDWF  x46,W
4EE6:  MOVWF  FE9
4EE8:  MOVLW  00
4EEA:  ADDWFC x47,W
4EEC:  MOVWF  FEA
4EEE:  MOVFF  FEF,356
4EF2:  MOVLW  10
4EF4:  ADDWF  x46,W
4EF6:  MOVWF  FE9
4EF8:  MOVLW  00
4EFA:  ADDWFC x47,W
4EFC:  MOVWF  FEA
4EFE:  MOVFF  FEC,358
4F02:  MOVF   FED,F
4F04:  MOVFF  FEF,357
4F08:  MOVFF  03,35A
4F0C:  MOVFF  01,359
4F10:  MOVFF  34B,35C
4F14:  MOVFF  34A,35B
4F18:  MOVFF  34D,35E
4F1C:  MOVFF  34C,35D
4F20:  MOVFF  351,362
4F24:  MOVFF  350,361
4F28:  MOVFF  34F,360
4F2C:  MOVFF  34E,35F
4F30:  MOVFF  355,366
4F34:  MOVFF  354,365
4F38:  MOVFF  353,364
4F3C:  MOVFF  352,363
4F40:  MOVLW  18
4F42:  MOVWF  x67
4F44:  MOVFF  356,368
4F48:  MOVFF  358,36A
4F4C:  MOVFF  357,369
4F50:  MOVLB  0
4F52:  CALL   2736
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
4F56:  MOVLW  16
4F58:  MOVLB  3
4F5A:  ADDWF  x46,W
4F5C:  MOVWF  01
4F5E:  MOVLW  00
4F60:  ADDWFC x47,W
4F62:  MOVWF  03
4F64:  MOVFF  01,348
4F68:  MOVWF  x49
4F6A:  MOVWF  FEA
4F6C:  MOVFF  01,FE9
4F70:  MOVFF  FEF,34A
4F74:  MOVFF  FEC,34B
4F78:  MOVFF  FEC,34C
4F7C:  MOVFF  FEC,34D
4F80:  MOVLW  10
4F82:  ADDWF  x46,W
4F84:  MOVWF  FE9
4F86:  MOVLW  00
4F88:  ADDWFC x47,W
4F8A:  MOVWF  FEA
4F8C:  MOVFF  FEC,03
4F90:  MOVF   FED,F
4F92:  MOVFF  FEF,00
4F96:  MOVFF  03,01
4F9A:  CLRF   02
4F9C:  CLRF   03
4F9E:  MOVF   x4A,W
4FA0:  ADDWF  00,F
4FA2:  MOVF   x4B,W
4FA4:  ADDWFC 01,F
4FA6:  MOVF   x4C,W
4FA8:  ADDWFC 02,F
4FAA:  MOVF   x4D,W
4FAC:  ADDWFC 03,F
4FAE:  MOVFF  349,FEA
4FB2:  MOVFF  348,FE9
4FB6:  MOVFF  00,FEF
4FBA:  MOVFF  01,FEC
4FBE:  MOVFF  02,FEC
4FC2:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
4FC6:  MOVLW  23
4FC8:  ADDWF  x46,W
4FCA:  MOVWF  FE9
4FCC:  MOVLW  00
4FCE:  ADDWFC x47,W
4FD0:  MOVWF  FEA
4FD2:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
4FD4:  MOVLW  23
4FD6:  ADDWF  x46,W
4FD8:  MOVWF  FE9
4FDA:  MOVLW  00
4FDC:  ADDWFC x47,W
4FDE:  MOVWF  FEA
4FE0:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
4FE2:  MOVLW  01
4FE4:  MOVWF  01
.................... } 
4FE6:  MOVLB  0
4FE8:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
4D7A:  MOVLB  3
4D7C:  MOVF   x33,W
4D7E:  MULLW  24
4D80:  MOVF   FF3,W
4D82:  CLRF   x35
4D84:  MOVWF  x34
4D86:  MOVLW  14
4D88:  ADDWF  x34,W
4D8A:  MOVWF  01
4D8C:  MOVLW  00
4D8E:  ADDWFC x35,W
4D90:  MOVWF  03
4D92:  MOVF   01,W
4D94:  ADDLW  5F
4D96:  MOVWF  FE9
4D98:  MOVLW  00
4D9A:  ADDWFC 03,W
4D9C:  MOVWF  FEA
4D9E:  MOVFF  FEC,335
4DA2:  MOVF   FED,F
4DA4:  MOVFF  FEF,334
4DA8:  MOVF   x34,F
4DAA:  BNZ   4DB6
4DAC:  MOVF   x35,F
4DAE:  BNZ   4DB6
....................       return FALSE; 
4DB0:  MOVLW  00
4DB2:  MOVWF  01
4DB4:  BRA    4E14
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
4DB6:  MOVF   x33,W
4DB8:  MULLW  24
4DBA:  MOVF   FF3,W
4DBC:  CLRF   x35
4DBE:  MOVWF  x34
4DC0:  MOVLW  0F
4DC2:  ADDWF  x34,W
4DC4:  MOVWF  01
4DC6:  MOVLW  00
4DC8:  ADDWFC x35,W
4DCA:  MOVWF  03
4DCC:  MOVF   01,W
4DCE:  ADDLW  5F
4DD0:  MOVWF  FE9
4DD2:  MOVLW  00
4DD4:  ADDWFC 03,W
4DD6:  MOVWF  FEA
4DD8:  INCFSZ FEF,W
4DDA:  BRA    4DEC
....................       return IPIsTxReady(FALSE); 
4DDC:  CLRF   x91
4DDE:  MOVLB  0
4DE0:  CALL   23EE
4DE4:  MOVF   01,W
4DE6:  MOVLB  3
4DE8:  BRA    4E14
....................    else 
4DEA:  BRA    4E14
....................       return TCB[s].Flags.bIsPutReady; 
4DEC:  MOVF   x33,W
4DEE:  MULLW  24
4DF0:  MOVF   FF3,W
4DF2:  CLRF   x35
4DF4:  MOVWF  x34
4DF6:  MOVLW  23
4DF8:  ADDWF  x34,F
4DFA:  MOVLW  00
4DFC:  ADDWFC x35,F
4DFE:  MOVLW  5F
4E00:  ADDWF  x34,W
4E02:  MOVWF  FE9
4E04:  MOVLW  00
4E06:  ADDWFC x35,W
4E08:  MOVWF  FEA
4E0A:  MOVLW  00
4E0C:  BTFSC  FEF.1
4E0E:  MOVLW  01
4E10:  MOVWF  01
4E12:  BRA    4E14
.................... } 
4E14:  MOVLB  0
4E16:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
5200:  MOVFF  32E,333
5204:  RCALL  4D7A
5206:  MOVF   01,F
5208:  BNZ   5212
....................       return(0); 
520A:  MOVLW  00
520C:  MOVWF  01
520E:  MOVWF  02
5210:  BRA    52F8
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
5212:  MOVLB  3
5214:  MOVF   x2E,W
5216:  MULLW  24
5218:  MOVF   FF3,W
521A:  CLRF   x34
521C:  MOVWF  x33
521E:  MOVLW  0F
5220:  ADDWF  x33,W
5222:  MOVWF  01
5224:  MOVLW  00
5226:  ADDWFC x34,W
5228:  MOVWF  03
522A:  MOVF   01,W
522C:  ADDLW  5F
522E:  MOVWF  FE9
5230:  MOVLW  00
5232:  ADDWFC 03,W
5234:  MOVWF  FEA
5236:  INCFSZ FEF,W
5238:  BRA    5240
....................       txCount = 0; 
523A:  CLRF   x30
523C:  CLRF   x2F
....................    else 
523E:  BRA    5270
....................       txCount = TCB[s].TxCount; 
5240:  MOVF   x2E,W
5242:  MULLW  24
5244:  MOVF   FF3,W
5246:  CLRF   x34
5248:  MOVWF  x33
524A:  MOVLW  10
524C:  ADDWF  x33,W
524E:  MOVWF  01
5250:  MOVLW  00
5252:  ADDWFC x34,W
5254:  MOVWF  03
5256:  MOVF   01,W
5258:  ADDLW  5F
525A:  MOVWF  FE9
525C:  MOVLW  00
525E:  ADDWFC 03,W
5260:  MOVWF  FEA
5262:  MOVFF  FEC,03
5266:  MOVF   FED,F
5268:  MOVFF  FEF,32F
526C:  MOVFF  03,330
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
5270:  MOVLW  CA
5272:  BSF    FD8.0
5274:  SUBFWB x2F,W
5276:  MOVWF  x31
5278:  MOVLW  03
527A:  SUBFWB x30,W
527C:  MOVWF  x32
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
527E:  MOVF   x2E,W
5280:  MULLW  24
5282:  MOVF   FF3,W
5284:  CLRF   x34
5286:  MOVWF  x33
5288:  MOVLW  14
528A:  ADDWF  x33,W
528C:  MOVWF  01
528E:  MOVLW  00
5290:  ADDWFC x34,W
5292:  MOVWF  03
5294:  MOVF   01,W
5296:  ADDLW  5F
5298:  MOVWF  FE9
529A:  MOVLW  00
529C:  ADDWFC 03,W
529E:  MOVWF  FEA
52A0:  MOVFF  FEC,03
52A4:  MOVF   FED,F
52A6:  MOVFF  FEF,01
52AA:  MOVF   03,W
52AC:  SUBWF  x32,W
52AE:  BNC   52E4
52B0:  BNZ   52B8
52B2:  MOVF   x31,W
52B4:  SUBWF  01,W
52B6:  BC    52E4
52B8:  MOVF   x2E,W
52BA:  MULLW  24
52BC:  MOVF   FF3,W
52BE:  CLRF   x34
52C0:  MOVWF  x33
52C2:  MOVLW  14
52C4:  ADDWF  x33,W
52C6:  MOVWF  01
52C8:  MOVLW  00
52CA:  ADDWFC x34,W
52CC:  MOVWF  03
52CE:  MOVF   01,W
52D0:  ADDLW  5F
52D2:  MOVWF  FE9
52D4:  MOVLW  00
52D6:  ADDWFC 03,W
52D8:  MOVWF  FEA
52DA:  MOVFF  FEC,03
52DE:  MOVF   FED,F
52E0:  MOVF   FEF,W
52E2:  BRA    52EA
52E4:  MOVFF  332,03
52E8:  MOVF   x31,W
52EA:  MOVWF  x31
52EC:  MOVFF  03,332
....................  
....................    return(txAvail); 
52F0:  MOVFF  331,01
52F4:  MOVFF  332,02
52F8:  MOVLB  0
.................... } 
52FA:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................     
....................    if (n>len) n=len; //AGREGADO 
....................     
....................    while (n--)   
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(n); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
4FEA:  MOVLB  3
4FEC:  MOVF   x3F,W
4FEE:  MULLW  24
4FF0:  MOVF   FF3,W
4FF2:  CLRF   03
4FF4:  ADDLW  5F
4FF6:  MOVWF  01
4FF8:  MOVLW  00
4FFA:  ADDWFC 03,F
4FFC:  MOVFF  01,341
5000:  MOVFF  03,342
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
5004:  MOVLW  14
5006:  ADDWF  x41,W
5008:  MOVWF  FE9
500A:  MOVLW  00
500C:  ADDWFC x42,W
500E:  MOVWF  FEA
5010:  MOVFF  FEC,346
5014:  MOVF   FED,F
5016:  MOVFF  FEF,345
501A:  MOVF   x45,F
501C:  BNZ   5028
501E:  MOVF   x46,F
5020:  BNZ   5028
....................       return FALSE; 
5022:  MOVLW  00
5024:  MOVWF  01
5026:  BRA    512E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
5028:  MOVLW  0F
502A:  ADDWF  x41,W
502C:  MOVWF  FE9
502E:  MOVLW  00
5030:  ADDWFC x42,W
5032:  MOVWF  FEA
5034:  INCFSZ FEF,W
5036:  BRA    50AA
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
5038:  MOVLW  0F
503A:  ADDWF  x41,W
503C:  MOVWF  01
503E:  MOVLW  00
5040:  ADDWFC x42,W
5042:  MOVWF  03
5044:  MOVFF  01,345
5048:  MOVWF  x46
504A:  CLRF   x91
504C:  MOVLB  0
504E:  CALL   1290
5052:  MOVFF  346,FEA
5056:  MOVFF  345,FE9
505A:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
505E:  MOVLW  0F
5060:  MOVLB  3
5062:  ADDWF  x41,W
5064:  MOVWF  FE9
5066:  MOVLW  00
5068:  ADDWFC x42,W
506A:  MOVWF  FEA
506C:  INCFSZ FEF,W
506E:  BRA    5076
....................          return FALSE; 
5070:  MOVLW  00
5072:  MOVWF  01
5074:  BRA    512E
....................  
....................       ps->TxCount = 0; 
5076:  MOVLW  10
5078:  ADDWF  x41,W
507A:  MOVWF  FE9
507C:  MOVLW  00
507E:  ADDWFC x42,W
5080:  MOVWF  FEA
5082:  CLRF   FEC
5084:  MOVF   FED,F
5086:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
5088:  MOVLW  0F
508A:  ADDWF  x41,W
508C:  MOVWF  FE9
508E:  MOVLW  00
5090:  ADDWFC x42,W
5092:  MOVWF  FEA
5094:  MOVFF  FEF,345
5098:  MOVFF  345,3AA
509C:  CLRF   xAC
509E:  MOVLW  28
50A0:  MOVWF  xAB
50A2:  MOVLB  0
50A4:  CALL   12BA
50A8:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
50AA:  MOVLW  23
50AC:  ADDWF  x41,W
50AE:  MOVWF  FE9
50B0:  MOVLW  00
50B2:  ADDWFC x42,W
50B4:  MOVWF  FEA
50B6:  BSF    FEF.4
....................  
....................    MACPut(byte); 
50B8:  MOVFF  340,3B4
50BC:  MOVLB  0
50BE:  CALL   1364
....................    ps->RemoteWindow--; 
50C2:  MOVLW  14
50C4:  MOVLB  3
50C6:  ADDWF  x41,W
50C8:  MOVWF  FE9
50CA:  MOVLW  00
50CC:  ADDWFC x42,W
50CE:  MOVWF  FEA
50D0:  MOVLW  FF
50D2:  ADDWF  FEF,F
50D4:  BC    50DA
50D6:  MOVF   FEE,F
50D8:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
50DA:  MOVLW  10
50DC:  ADDWF  x41,W
50DE:  MOVWF  FE9
50E0:  MOVLW  00
50E2:  ADDWFC x42,W
50E4:  MOVWF  FEA
50E6:  MOVFF  FEC,03
50EA:  MOVF   FED,F
50EC:  MOVFF  FEF,343
50F0:  MOVFF  03,344
....................    tempCount++; 
50F4:  INCF   x43,F
50F6:  BTFSC  FD8.2
50F8:  INCF   x44,F
....................    ps->TxCount = tempCount; 
50FA:  MOVLW  10
50FC:  ADDWF  x41,W
50FE:  MOVWF  FE9
5100:  MOVLW  00
5102:  ADDWFC x42,W
5104:  MOVWF  FEA
5106:  MOVFF  344,FEC
510A:  MOVF   FED,F
510C:  MOVFF  343,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
5110:  MOVF   x44,W
5112:  SUBLW  02
5114:  BC    512A
5116:  XORLW  FF
5118:  BNZ   5120
511A:  MOVF   x43,W
511C:  SUBLW  C9
511E:  BC    512A
....................       TCPFlush(s); 
5120:  MOVFF  33F,345
5124:  MOVLB  0
5126:  RCALL  4E20
5128:  MOVLB  3
....................  
....................    return TRUE; 
512A:  MOVLW  01
512C:  MOVWF  01
.................... } 
512E:  MOVLB  0
5130:  GOTO   513E (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
4D2C:  MOVLB  3
4D2E:  MOVF   x13,W
4D30:  MULLW  24
4D32:  MOVF   FF3,W
4D34:  CLRF   03
4D36:  ADDLW  5F
4D38:  MOVWF  01
4D3A:  MOVLW  00
4D3C:  ADDWFC 03,F
4D3E:  MOVFF  01,314
4D42:  MOVFF  03,315
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
4D46:  MOVLW  23
4D48:  ADDWF  x14,W
4D4A:  MOVWF  FE9
4D4C:  MOVLW  00
4D4E:  ADDWFC x15,W
4D50:  MOVWF  FEA
4D52:  BTFSC  FEF.3
4D54:  BRA    4D5C
....................         return FALSE; 
4D56:  MOVLW  00
4D58:  MOVWF  01
4D5A:  BRA    4D76
....................  
....................     MACDiscardRx(); 
4D5C:  MOVLB  0
4D5E:  CALL   0EC2
....................     ps->Flags.bIsGetReady = FALSE; 
4D62:  MOVLW  23
4D64:  MOVLB  3
4D66:  ADDWF  x14,W
4D68:  MOVWF  FE9
4D6A:  MOVLW  00
4D6C:  ADDWFC x15,W
4D6E:  MOVWF  FEA
4D70:  BCF    FEF.3
....................  
....................     return TRUE; 
4D72:  MOVLW  01
4D74:  MOVWF  01
.................... } 
4D76:  MOVLB  0
4D78:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
3DD0:  MOVLB  3
3DD2:  MOVF   x10,W
3DD4:  MULLW  24
3DD6:  MOVF   FF3,W
3DD8:  CLRF   03
3DDA:  ADDLW  5F
3DDC:  MOVWF  01
3DDE:  MOVLW  00
3DE0:  ADDWFC 03,F
3DE2:  MOVFF  01,313
3DE6:  MOVFF  03,314
....................  
....................     if ( ps->Flags.bIsGetReady ) 
3DEA:  MOVLW  23
3DEC:  ADDWF  x13,W
3DEE:  MOVWF  FE9
3DF0:  MOVLW  00
3DF2:  ADDWFC x14,W
3DF4:  MOVWF  FEA
3DF6:  BTFSS  FEF.3
3DF8:  BRA    3E9C
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
3DFA:  MOVLW  23
3DFC:  ADDWF  x13,W
3DFE:  MOVWF  FE9
3E00:  MOVLW  00
3E02:  ADDWFC x14,W
3E04:  MOVWF  FEA
3E06:  BTFSS  FEF.2
3E08:  BRA    3E26
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
3E0A:  CLRF   x36
3E0C:  MOVLW  14
3E0E:  MOVWF  x35
3E10:  MOVLB  0
3E12:  CALL   1E90
....................  
....................             ps->Flags.bFirstRead = FALSE; 
3E16:  MOVLW  23
3E18:  MOVLB  3
3E1A:  ADDWF  x13,W
3E1C:  MOVWF  FE9
3E1E:  MOVLW  00
3E20:  ADDWFC x14,W
3E22:  MOVWF  FEA
3E24:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
3E26:  MOVLW  12
3E28:  ADDWF  x13,W
3E2A:  MOVWF  FE9
3E2C:  MOVLW  00
3E2E:  ADDWFC x14,W
3E30:  MOVWF  FEA
3E32:  MOVFF  FEC,316
3E36:  MOVF   FED,F
3E38:  MOVFF  FEF,315
3E3C:  MOVF   x15,F
3E3E:  BNZ   3E60
3E40:  MOVF   x16,F
3E42:  BNZ   3E60
....................         { 
....................             MACDiscardRx(); 
3E44:  MOVLB  0
3E46:  CALL   0EC2
....................             ps->Flags.bIsGetReady = FALSE; 
3E4A:  MOVLW  23
3E4C:  MOVLB  3
3E4E:  ADDWF  x13,W
3E50:  MOVWF  FE9
3E52:  MOVLW  00
3E54:  ADDWFC x14,W
3E56:  MOVWF  FEA
3E58:  BCF    FEF.3
....................             return FALSE; 
3E5A:  MOVLW  00
3E5C:  MOVWF  01
3E5E:  BRA    3EA0
....................         } 
....................  
....................          ps->RxCount--; 
3E60:  MOVLW  12
3E62:  ADDWF  x13,W
3E64:  MOVWF  FE9
3E66:  MOVLW  00
3E68:  ADDWFC x14,W
3E6A:  MOVWF  FEA
3E6C:  MOVLW  FF
3E6E:  ADDWF  FEF,F
3E70:  BC    3E76
3E72:  MOVF   FEE,F
3E74:  DECF   FED,F
....................          *data = MACGet(); 
3E76:  MOVFF  312,03
3E7A:  MOVFF  311,315
3E7E:  MOVFF  312,316
3E82:  MOVLB  0
3E84:  CALL   1D10
3E88:  MOVFF  316,FEA
3E8C:  MOVFF  315,FE9
3E90:  MOVFF  01,FEF
....................         return TRUE; 
3E94:  MOVLW  01
3E96:  MOVWF  01
3E98:  MOVLB  3
3E9A:  BRA    3EA0
....................     } 
....................     return FALSE; 
3E9C:  MOVLW  00
3E9E:  MOVWF  01
.................... } 
3EA0:  MOVLB  0
3EA2:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
3DA4:  MOVLB  3
3DA6:  MOVF   x10,W
3DA8:  MULLW  24
3DAA:  MOVF   FF3,W
3DAC:  CLRF   x12
3DAE:  MOVWF  x11
3DB0:  MOVLW  23
3DB2:  ADDWF  x11,F
3DB4:  MOVLW  00
3DB6:  ADDWFC x12,F
3DB8:  MOVLW  5F
3DBA:  ADDWF  x11,W
3DBC:  MOVWF  FE9
3DBE:  MOVLW  00
3DC0:  ADDWFC x12,W
3DC2:  MOVWF  FEA
3DC4:  MOVLW  00
3DC6:  BTFSC  FEF.3
3DC8:  MOVLW  01
3DCA:  MOVWF  01
.................... } 
3DCC:  MOVLB  0
3DCE:  RETLW  00
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
38AC:  MOVLB  3
38AE:  CLRF   x13
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
38B0:  CLRF   x08
38B2:  MOVF   x08,W
38B4:  SUBLW  04
38B6:  BTFSS  FD8.0
38B8:  BRA    3D3E
....................    { 
....................       ps = &TCB[s]; 
38BA:  MOVF   x08,W
38BC:  MULLW  24
38BE:  MOVF   FF3,W
38C0:  CLRF   03
38C2:  ADDLW  5F
38C4:  MOVWF  01
38C6:  MOVLW  00
38C8:  ADDWFC 03,F
38CA:  MOVFF  01,30D
38CE:  MOVFF  03,30E
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
38D2:  MOVLW  23
38D4:  ADDWF  x0D,W
38D6:  MOVWF  FE9
38D8:  MOVLW  00
38DA:  ADDWFC x0E,W
38DC:  MOVWF  FEA
38DE:  BTFSC  FEF.3
38E0:  BRA    38F2
38E2:  MOVLW  23
38E4:  ADDWF  x0D,W
38E6:  MOVWF  FE9
38E8:  MOVLW  00
38EA:  ADDWFC x0E,W
38EC:  MOVWF  FEA
38EE:  BTFSS  FEF.4
38F0:  BRA    38F4
....................          continue; 
38F2:  BRA    3D3A
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
38F4:  MOVFF  30D,FE9
38F8:  MOVFF  30E,FEA
38FC:  MOVF   FEF,W
38FE:  SUBLW  0A
3900:  BZ    3926
3902:  MOVFF  30D,FE9
3906:  MOVFF  30E,FEA
390A:  MOVF   FEF,F
390C:  BNZ   3928
390E:  MOVLW  23
3910:  ADDWF  x0D,W
3912:  MOVWF  FE9
3914:  MOVLW  00
3916:  ADDWFC x0E,W
3918:  MOVWF  FEA
391A:  MOVLW  00
391C:  BTFSC  FEF.0
391E:  MOVLW  01
3920:  ANDLW  01
3922:  SUBLW  01
3924:  BNZ   3928
....................          continue; 
3926:  BRA    3D3A
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
3928:  MOVFF  30D,FE9
392C:  MOVFF  30E,FEA
3930:  MOVF   FEF,W
3932:  SUBLW  03
3934:  BNZ   3950
3936:  MOVLW  23
3938:  ADDWF  x0D,W
393A:  MOVWF  FE9
393C:  MOVLW  00
393E:  ADDWFC x0E,W
3940:  MOVWF  FEA
3942:  MOVLW  00
3944:  BTFSC  FEF.0
3946:  MOVLW  01
3948:  ANDLW  01
394A:  SUBLW  01
394C:  BNZ   3950
....................          continue; 
394E:  BRA    3D3A
....................  
....................  
....................       tick = TickGet(); 
3950:  MOVLB  0
3952:  CALL   22D0
3956:  MOVFF  02,30C
395A:  MOVFF  01,30B
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
395E:  MOVLW  1F
3960:  MOVLB  3
3962:  ADDWF  x0D,W
3964:  MOVWF  FE9
3966:  MOVLW  00
3968:  ADDWFC x0E,W
396A:  MOVWF  FEA
396C:  MOVFF  FEC,03
3970:  MOVF   FED,F
3972:  MOVFF  FEF,01
3976:  MOVF   x0C,W
3978:  SUBWF  03,W
397A:  BNC   3984
397C:  BNZ   3988
397E:  MOVF   01,W
3980:  SUBWF  x0B,W
3982:  BNC   3988
3984:  MOVLW  00
3986:  BRA    398A
3988:  MOVLW  01
398A:  CLRF   03
398C:  IORWF  03,W
398E:  BZ    39C6
3990:  MOVLW  1F
3992:  ADDWF  x0D,W
3994:  MOVWF  FE9
3996:  MOVLW  00
3998:  ADDWFC x0E,W
399A:  MOVWF  FEA
399C:  MOVFF  FEC,03
39A0:  MOVF   FED,F
39A2:  MOVF   FEF,W
39A4:  SUBLW  FF
39A6:  MOVWF  x14
39A8:  MOVLW  FF
39AA:  SUBFWB 03,W
39AC:  MOVWF  x15
39AE:  MOVF   x0B,W
39B0:  ADDWF  x14,F
39B2:  MOVF   x0C,W
39B4:  ADDWFC x15,F
39B6:  MOVLW  01
39B8:  ADDWF  x14,W
39BA:  MOVWF  01
39BC:  MOVLW  00
39BE:  ADDWFC x15,W
39C0:  MOVWF  03
39C2:  MOVF   01,W
39C4:  BRA    39E6
39C6:  MOVLW  1F
39C8:  ADDWF  x0D,W
39CA:  MOVWF  FE9
39CC:  MOVLW  00
39CE:  ADDWFC x0E,W
39D0:  MOVWF  FEA
39D2:  MOVFF  FEC,03
39D6:  MOVF   FED,F
39D8:  MOVF   FEF,W
39DA:  SUBWF  x0B,W
39DC:  MOVWF  00
39DE:  MOVF   03,W
39E0:  SUBWFB x0C,W
39E2:  MOVWF  03
39E4:  MOVF   00,W
39E6:  MOVWF  x09
39E8:  MOVFF  03,30A
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
39EC:  MOVLW  21
39EE:  ADDWF  x0D,W
39F0:  MOVWF  FE9
39F2:  MOVLW  00
39F4:  ADDWFC x0E,W
39F6:  MOVWF  FEA
39F8:  MOVFF  FEC,03
39FC:  MOVF   FED,F
39FE:  MOVFF  FEF,01
3A02:  MOVF   x0A,W
3A04:  SUBWF  03,W
3A06:  BNC   3A12
3A08:  BNZ   3A10
3A0A:  MOVF   x09,W
3A0C:  SUBWF  01,W
3A0E:  BNC   3A12
....................          continue; 
3A10:  BRA    3D3A
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
3A12:  MOVLW  01
3A14:  MOVWF  x91
3A16:  MOVLB  0
3A18:  CALL   23EE
3A1C:  MOVF   01,F
3A1E:  BNZ   3A22
....................          return; 
3A20:  BRA    3D3E
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
3A22:  MOVLW  1F
3A24:  MOVLB  3
3A26:  ADDWF  x0D,W
3A28:  MOVWF  01
3A2A:  MOVLW  00
3A2C:  ADDWFC x0E,W
3A2E:  MOVWF  03
3A30:  MOVFF  01,314
3A34:  MOVWF  x15
3A36:  MOVLB  0
3A38:  CALL   22D0
3A3C:  MOVFF  315,FEA
3A40:  MOVFF  314,FE9
3A44:  MOVFF  02,FEC
3A48:  MOVF   FED,F
3A4A:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
3A4E:  MOVLW  21
3A50:  MOVLB  3
3A52:  ADDWF  x0D,W
3A54:  MOVWF  FE9
3A56:  MOVLW  00
3A58:  ADDWFC x0E,W
3A5A:  MOVWF  FEA
3A5C:  BCF    FD8.0
3A5E:  RLCF   FEF,W
3A60:  MOVWF  02
3A62:  RLCF   FEC,W
3A64:  MOVWF  03
3A66:  MOVF   02,W
3A68:  MOVF   FED,F
3A6A:  MOVWF  FEF
3A6C:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
3A70:  MOVLW  1E
3A72:  ADDWF  x0D,W
3A74:  MOVWF  FE9
3A76:  MOVLW  00
3A78:  ADDWFC x0E,W
3A7A:  MOVWF  FEA
3A7C:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
3A7E:  MOVFF  30D,FE9
3A82:  MOVFF  30E,FEA
3A86:  MOVLW  01
3A88:  SUBWF  FEF,W
3A8A:  ADDLW  F7
3A8C:  BTFSC  FD8.0
3A8E:  BRA    3C1E
3A90:  ADDLW  09
3A92:  MOVLB  0
3A94:  GOTO   3D44
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
3A98:  MOVLW  02
3A9A:  MOVLB  3
3A9C:  MOVWF  x13
....................          break; 
3A9E:  BRA    3C1E
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3AA0:  MOVLW  1E
3AA2:  MOVLB  3
3AA4:  ADDWF  x0D,W
3AA6:  MOVWF  FE9
3AA8:  MOVLW  00
3AAA:  ADDWFC x0E,W
3AAC:  MOVWF  FEA
3AAE:  MOVF   FEF,W
3AB0:  SUBLW  03
3AB2:  BNC   3ABA
....................          { 
....................             flags = SYN | ACK; 
3AB4:  MOVLW  12
3AB6:  MOVWF  x13
....................          } 
....................          else 
3AB8:  BRA    3AE6
....................          { 
....................             if(ps->Flags.bServer) 
3ABA:  MOVLW  23
3ABC:  ADDWF  x0D,W
3ABE:  MOVWF  FE9
3AC0:  MOVLW  00
3AC2:  ADDWFC x0E,W
3AC4:  MOVWF  FEA
3AC6:  BTFSS  FEF.0
3AC8:  BRA    3AD6
....................             { 
....................                ps->smState = TCP_LISTEN; 
3ACA:  MOVFF  30D,FE9
3ACE:  MOVFF  30E,FEA
3AD2:  CLRF   FEF
....................             } 
....................             else 
3AD4:  BRA    3AE6
....................             { 
....................                flags = SYN; 
3AD6:  MOVLW  02
3AD8:  MOVWF  x13
....................                ps->smState = TCP_SYN_SENT; 
3ADA:  MOVFF  30D,FE9
3ADE:  MOVFF  30E,FEA
3AE2:  MOVLW  01
3AE4:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
3AE6:  BRA    3C1E
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3AE8:  MOVLW  1E
3AEA:  MOVLB  3
3AEC:  ADDWF  x0D,W
3AEE:  MOVWF  FE9
3AF0:  MOVLW  00
3AF2:  ADDWFC x0E,W
3AF4:  MOVWF  FEA
3AF6:  MOVF   FEF,W
3AF8:  SUBLW  03
3AFA:  BNC   3B3E
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3AFC:  MOVLW  0F
3AFE:  ADDWF  x0D,W
3B00:  MOVWF  FE9
3B02:  MOVLW  00
3B04:  ADDWFC x0E,W
3B06:  MOVWF  FEA
3B08:  INCFSZ FEF,W
3B0A:  BRA    3B0E
3B0C:  BRA    3B34
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
3B0E:  MOVLW  0F
3B10:  ADDWF  x0D,W
3B12:  MOVWF  FE9
3B14:  MOVLW  00
3B16:  ADDWFC x0E,W
3B18:  MOVWF  FEA
3B1A:  MOVFF  FEF,314
3B1E:  MOVFF  314,3AA
3B22:  CLRF   xAC
3B24:  CLRF   xAB
3B26:  MOVLB  0
3B28:  CALL   12BA
....................                MACFlush(); 
3B2C:  CALL   1496
....................             } 
....................             else 
3B30:  BRA    3B3A
3B32:  MOVLB  3
....................                flags = ACK; 
3B34:  MOVLW  10
3B36:  MOVWF  x13
3B38:  MOVLB  0
....................          } 
....................          else 
3B3A:  BRA    3B8C
3B3C:  MOVLB  3
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3B3E:  MOVLW  0F
3B40:  ADDWF  x0D,W
3B42:  MOVWF  FE9
3B44:  MOVLW  00
3B46:  ADDWFC x0E,W
3B48:  MOVWF  FEA
3B4A:  INCFSZ FEF,W
3B4C:  BRA    3B50
3B4E:  BRA    3B7C
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
3B50:  MOVLW  0F
3B52:  ADDWF  x0D,W
3B54:  MOVWF  FE9
3B56:  MOVLW  00
3B58:  ADDWFC x0E,W
3B5A:  MOVWF  FEA
3B5C:  MOVFF  FEF,314
3B60:  MOVFF  314,355
3B64:  MOVLB  0
3B66:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
3B6A:  MOVLW  0F
3B6C:  MOVLB  3
3B6E:  ADDWF  x0D,W
3B70:  MOVWF  FE9
3B72:  MOVLW  00
3B74:  ADDWFC x0E,W
3B76:  MOVWF  FEA
3B78:  MOVLW  FF
3B7A:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
3B7C:  MOVLW  11
3B7E:  MOVWF  x13
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
3B80:  MOVFF  30D,FE9
3B84:  MOVFF  30E,FEA
3B88:  MOVLW  04
3B8A:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
3B8C:  MOVLB  3
3B8E:  BRA    3C1E
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3B90:  MOVLW  1E
3B92:  MOVLB  3
3B94:  ADDWF  x0D,W
3B96:  MOVWF  FE9
3B98:  MOVLW  00
3B9A:  ADDWFC x0E,W
3B9C:  MOVWF  FEA
3B9E:  MOVF   FEF,W
3BA0:  SUBLW  03
3BA2:  BNC   3BAA
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
3BA4:  MOVLW  01
3BA6:  MOVWF  x13
....................          } 
....................          else 
3BA8:  BRA    3BBA
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
3BAA:  MOVFF  30E,353
3BAE:  MOVFF  30D,352
3BB2:  MOVLB  0
3BB4:  CALL   22EA
3BB8:  MOVLB  3
....................          } 
....................          break; 
3BBA:  BRA    3C1E
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
3BBC:  MOVFF  30E,353
3BC0:  MOVFF  30D,352
3BC4:  CALL   22EA
....................          break; 
3BC8:  MOVLB  3
3BCA:  BRA    3C1E
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
3BCC:  MOVFF  30E,353
3BD0:  MOVFF  30D,352
3BD4:  CALL   22EA
....................          break; 
3BD8:  MOVLB  3
3BDA:  BRA    3C1E
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
3BDC:  MOVLW  01
3BDE:  MOVLB  3
3BE0:  MOVWF  x13
....................          ps->smState = TCP_LAST_ACK; 
3BE2:  MOVFF  30D,FE9
3BE6:  MOVFF  30E,FEA
3BEA:  MOVLW  09
3BEC:  MOVWF  FEF
....................          break; 
3BEE:  BRA    3C1E
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3BF0:  MOVLW  1E
3BF2:  MOVLB  3
3BF4:  ADDWF  x0D,W
3BF6:  MOVWF  FE9
3BF8:  MOVLW  00
3BFA:  ADDWFC x0E,W
3BFC:  MOVWF  FEA
3BFE:  MOVF   FEF,W
3C00:  SUBLW  03
3C02:  BNC   3C0A
....................             flags = FIN; 
3C04:  MOVLW  01
3C06:  MOVWF  x13
....................          else 
3C08:  BRA    3C1A
....................             CloseSocket(ps); 
3C0A:  MOVFF  30E,353
3C0E:  MOVFF  30D,352
3C12:  MOVLB  0
3C14:  CALL   22EA
3C18:  MOVLB  3
....................          break; 
3C1A:  BRA    3C1E
3C1C:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
3C1E:  MOVF   x13,F
3C20:  BTFSC  FD8.2
3C22:  BRA    3D3A
....................       { 
....................          if(flags & ACK) 
3C24:  BTFSS  x13.4
3C26:  BRA    3C56
....................             seq = ps->SND_SEQ; 
3C28:  MOVLW  16
3C2A:  ADDWF  x0D,W
3C2C:  MOVWF  FE9
3C2E:  MOVLW  00
3C30:  ADDWFC x0E,W
3C32:  MOVWF  FEA
3C34:  MOVFF  FEF,00
3C38:  MOVFF  FEC,01
3C3C:  MOVFF  FEC,02
3C40:  MOVFF  FEC,03
3C44:  MOVFF  03,312
3C48:  MOVFF  02,311
3C4C:  MOVFF  01,310
3C50:  MOVFF  00,30F
....................          else 
3C54:  BRA    3C94
....................             seq = ps->SND_SEQ++; 
3C56:  MOVLW  16
3C58:  ADDWF  x0D,W
3C5A:  MOVWF  FE9
3C5C:  MOVLW  00
3C5E:  ADDWFC x0E,W
3C60:  MOVWF  FEA
3C62:  MOVF   FEE,F
3C64:  MOVF   FEE,F
3C66:  MOVF   FEE,F
3C68:  MOVFF  FED,03
3C6C:  MOVFF  FED,02
3C70:  MOVFF  FED,01
3C74:  MOVFF  FEF,00
3C78:  MOVLW  01
3C7A:  ADDWF  FEE,F
3C7C:  MOVLW  00
3C7E:  ADDWFC FEE,F
3C80:  ADDWFC FEE,F
3C82:  ADDWFC FED,F
3C84:  MOVFF  03,312
3C88:  MOVFF  02,311
3C8C:  MOVFF  01,310
3C90:  MOVFF  00,30F
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
3C94:  MOVLW  01
3C96:  ADDWF  x0D,W
3C98:  MOVWF  01
3C9A:  MOVLW  00
3C9C:  ADDWFC x0E,W
3C9E:  MOVWF  03
3CA0:  MOVFF  01,314
3CA4:  MOVWF  x15
3CA6:  MOVLW  0B
3CA8:  ADDWF  x0D,W
3CAA:  MOVWF  FE9
3CAC:  MOVLW  00
3CAE:  ADDWFC x0E,W
3CB0:  MOVWF  FEA
3CB2:  MOVFF  FEC,317
3CB6:  MOVF   FED,F
3CB8:  MOVFF  FEF,316
3CBC:  MOVLW  0D
3CBE:  ADDWF  x0D,W
3CC0:  MOVWF  FE9
3CC2:  MOVLW  00
3CC4:  ADDWFC x0E,W
3CC6:  MOVWF  FEA
3CC8:  MOVFF  FEC,319
3CCC:  MOVF   FED,F
3CCE:  MOVFF  FEF,318
3CD2:  MOVLW  1A
3CD4:  ADDWF  x0D,W
3CD6:  MOVWF  FE9
3CD8:  MOVLW  00
3CDA:  ADDWFC x0E,W
3CDC:  MOVWF  FEA
3CDE:  MOVFF  FEF,31A
3CE2:  MOVFF  FEC,31B
3CE6:  MOVFF  FEC,31C
3CEA:  MOVFF  FEC,31D
3CEE:  MOVFF  03,35A
3CF2:  MOVFF  01,359
3CF6:  MOVFF  317,35C
3CFA:  MOVFF  316,35B
3CFE:  MOVFF  319,35E
3D02:  MOVFF  318,35D
3D06:  MOVFF  312,362
3D0A:  MOVFF  311,361
3D0E:  MOVFF  310,360
3D12:  MOVFF  30F,35F
3D16:  MOVFF  31D,366
3D1A:  MOVFF  31C,365
3D1E:  MOVFF  31B,364
3D22:  MOVFF  31A,363
3D26:  MOVFF  313,367
3D2A:  MOVLW  FF
3D2C:  MOVWF  x68
3D2E:  CLRF   x6A
3D30:  CLRF   x69
3D32:  MOVLB  0
3D34:  CALL   2736
3D38:  MOVLB  3
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
3D3A:  INCF   x08,F
3D3C:  BRA    38B2
3D3E:  MOVLB  0
.................... } 
3D40:  GOTO   6AE2 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
3436:  MOVLW  06
3438:  MOVLB  3
343A:  ADDWF  x08,W
343C:  MOVWF  FE9
343E:  MOVLW  00
3440:  ADDWFC x09,W
3442:  MOVWF  FEA
3444:  MOVFF  FEF,00
3448:  MOVFF  FEC,01
344C:  MOVFF  FEC,02
3450:  MOVFF  FEC,03
3454:  MOVFF  03,325
3458:  MOVFF  02,324
345C:  MOVFF  01,323
3460:  MOVFF  00,322
....................    pseudoHeader.DestAddress        = *localIP; 
3464:  MOVFF  30A,FE9
3468:  MOVFF  30B,FEA
346C:  MOVFF  FEF,00
3470:  MOVFF  FEC,01
3474:  MOVFF  FEC,02
3478:  MOVFF  FEC,03
347C:  MOVFF  03,329
3480:  MOVFF  02,328
3484:  MOVFF  01,327
3488:  MOVFF  00,326
....................    pseudoHeader.Zero               = 0x0; 
348C:  CLRF   x2A
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
348E:  MOVLW  06
3490:  MOVWF  x2B
....................    pseudoHeader.TCPLength          = len; 
3492:  MOVFF  30D,32D
3496:  MOVFF  30C,32C
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
349A:  MOVFF  32D,3B1
349E:  MOVFF  32C,3B0
34A2:  MOVLB  0
34A4:  CALL   0F8E
34A8:  MOVFF  02,32D
34AC:  MOVFF  01,32C
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
34B0:  MOVLW  03
34B2:  MOVLB  3
34B4:  MOVWF  x35
34B6:  MOVLW  22
34B8:  MOVFF  335,394
34BC:  MOVWF  x93
34BE:  CLRF   x96
34C0:  MOVLW  0C
34C2:  MOVWF  x95
34C4:  MOVLB  0
34C6:  CALL   1C22
34CA:  MOVFF  01,32F
34CE:  MOVLB  3
34D0:  COMF   x2F,F
34D2:  MOVFF  02,330
34D6:  COMF   x30,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
34D8:  MOVFF  30D,392
34DC:  MOVFF  30C,391
34E0:  MOVLB  0
34E2:  CALL   1D38
34E6:  MOVFF  02,332
34EA:  MOVFF  01,331
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
34EE:  MOVLB  3
34F0:  MOVF   x32,W
34F2:  SUBWF  x2F,W
34F4:  BNZ   34FC
34F6:  MOVF   x31,W
34F8:  SUBWF  x30,W
34FA:  BZ    350A
....................    { 
....................       MACDiscardRx(); 
34FC:  MOVLB  0
34FE:  CALL   0EC2
....................       return TRUE; 
3502:  MOVLW  01
3504:  MOVWF  01
3506:  BRA    35DE
3508:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
350A:  CLRF   x36
350C:  CLRF   x35
350E:  MOVLB  0
3510:  CALL   1E90
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
3514:  MOVLW  03
3516:  MOVLB  3
3518:  MOVWF  x35
351A:  MOVLW  0E
351C:  MOVFF  335,3A0
3520:  MOVWF  x9F
3522:  CLRF   xA2
3524:  MOVLW  14
3526:  MOVWF  xA1
3528:  MOVLB  0
352A:  CALL   0F2E
....................    SwapTCPHeader(&TCPHeader); 
352E:  MOVLW  03
3530:  MOVLB  3
3532:  MOVWF  x92
3534:  MOVLW  0E
3536:  MOVWF  x91
3538:  MOVLB  0
353A:  CALL   1ECC
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
353E:  MOVLB  3
3540:  SWAPF  x1A,W
3542:  ANDLW  0F
3544:  MOVWF  00
3546:  RLCF   00,W
3548:  MOVWF  x34
354A:  RLCF   x34,F
354C:  MOVLW  FC
354E:  ANDWF  x34,F
3550:  MOVLW  14
3552:  SUBWF  x34,W
3554:  MOVWF  x33
....................    len = len - optionsSize - sizeof(TCPHeader); 
3556:  MOVF   x33,W
3558:  SUBWF  x0C,W
355A:  MOVWF  x34
355C:  MOVLW  00
355E:  SUBWFB x0D,W
3560:  MOVWF  x35
3562:  MOVLW  14
3564:  SUBWF  x34,W
3566:  MOVWF  x0C
3568:  MOVLW  00
356A:  SUBWFB x35,W
356C:  MOVWF  x0D
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
356E:  SWAPF  x1A,W
3570:  ANDLW  0F
3572:  MOVWF  00
3574:  RLCF   00,W
3576:  MOVWF  x34
3578:  RLCF   x34,F
357A:  MOVLW  FC
357C:  ANDWF  x34,F
357E:  CLRF   x36
3580:  MOVFF  334,335
3584:  MOVLB  0
3586:  CALL   1E90
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
358A:  MOVLW  03
358C:  MOVLB  3
358E:  MOVWF  x35
3590:  MOVLW  0E
3592:  MOVWF  x34
3594:  MOVFF  309,337
3598:  MOVFF  308,336
359C:  MOVLB  0
359E:  GOTO   20F2
35A2:  MOVFF  01,32E
....................    if(socket != INVALID_SOCKET) 
35A6:  MOVLB  3
35A8:  MOVF   x2E,W
35AA:  SUBLW  FE
35AC:  BZ    35D4
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
35AE:  MOVFF  32E,334
35B2:  MOVFF  309,336
35B6:  MOVFF  308,335
35BA:  MOVLW  03
35BC:  MOVWF  x38
35BE:  MOVLW  0E
35C0:  MOVWF  x37
35C2:  MOVFF  30D,33A
35C6:  MOVFF  30C,339
35CA:  MOVLB  0
35CC:  GOTO   2964
....................    } 
....................    else 
35D0:  BRA    35DA
35D2:  MOVLB  3
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
35D4:  MOVLB  0
35D6:  CALL   0EC2
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
35DA:  MOVLW  01
35DC:  MOVWF  01
.................... } 
35DE:  GOTO   6A1E (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
2736:  MOVLW  01
2738:  MOVLB  3
273A:  MOVWF  x91
273C:  MOVLB  0
273E:  RCALL  23EE
2740:  MOVF   01,F
2742:  BZ    2736
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
2744:  MOVLB  3
2746:  INCFSZ x68,W
2748:  BRA    275A
....................       buff = MACGetTxBuffer(TRUE); 
274A:  MOVLW  01
274C:  MOVWF  x91
274E:  MOVLB  0
2750:  CALL   1290
2754:  MOVFF  01,368
2758:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
275A:  INCFSZ x68,W
275C:  BRA    2760
....................       return; 
275E:  BRA    2960
....................  
....................    IPSetTxBuffer(buff, 0); 
2760:  MOVFF  368,3AA
2764:  CLRF   xAC
2766:  MOVLW  14
2768:  MOVWF  xAB
276A:  MOVLB  0
276C:  CALL   12BA
....................  
....................    header.SourcePort           = localPort; 
2770:  MOVFF  35C,36E
2774:  MOVFF  35B,36D
....................    header.DestPort             = remotePort; 
2778:  MOVFF  35E,370
277C:  MOVFF  35D,36F
....................    header.SeqNumber            = tseq; 
2780:  MOVFF  362,374
2784:  MOVFF  361,373
2788:  MOVFF  360,372
278C:  MOVFF  35F,371
....................    header.AckNumber            = tack; 
2790:  MOVFF  366,378
2794:  MOVFF  365,377
2798:  MOVFF  364,376
279C:  MOVFF  363,375
....................    header.Flags.bits.Reserved2 = 0; 
27A0:  MOVLW  3F
27A2:  MOVLB  3
27A4:  ANDWF  x7A,W
27A6:  MOVWF  x7A
....................    header.DataOffset.Reserved3 = 0; 
27A8:  MOVLW  F0
27AA:  ANDWF  x79,W
27AC:  MOVWF  x79
....................    header.Flags.b              = flags; 
27AE:  MOVFF  367,37A
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
27B2:  MOVLB  0
27B4:  BRA    2418
27B6:  MOVFF  02,37C
27BA:  MOVFF  01,37B
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
27BE:  MOVLB  3
27C0:  MOVF   x7C,F
27C2:  BNZ   27CA
27C4:  MOVF   x7B,W
27C6:  SUBLW  28
27C8:  BC    27D4
....................    { 
....................       header.Window -= 40; 
27CA:  MOVLW  28
27CC:  SUBWF  x7B,F
27CE:  MOVLW  00
27D0:  SUBWFB x7C,F
....................    } 
....................    else 
27D2:  BRA    27D8
....................       header.Window = 0; 
27D4:  CLRF   x7C
27D6:  CLRF   x7B
.................... #endif 
....................  
....................    header.Checksum             = 0; 
27D8:  CLRF   x7E
27DA:  CLRF   x7D
....................    header.UrgentPointer        = 0; 
27DC:  CLRF   x80
27DE:  CLRF   x7F
....................  
....................    SwapTCPHeader(&header); 
27E0:  MOVLW  03
27E2:  MOVWF  x92
27E4:  MOVLW  6D
27E6:  MOVWF  x91
27E8:  MOVLB  0
27EA:  CALL   1ECC
....................  
....................    len += sizeof(header); 
27EE:  MOVLW  14
27F0:  MOVLB  3
27F2:  ADDWF  x69,F
27F4:  MOVLW  00
27F6:  ADDWFC x6A,F
....................  
....................    if ( flags & SYN ) 
27F8:  BTFSS  x67.1
27FA:  BRA    281A
....................    { 
....................       len += sizeof(options); 
27FC:  MOVLW  04
27FE:  ADDWF  x69,F
2800:  MOVLW  00
2802:  ADDWFC x6A,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
2804:  MOVLW  02
2806:  MOVWF  x81
....................       options.Length = 0x04; 
2808:  MOVLW  04
280A:  MOVWF  x82
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
280C:  MOVWF  x83
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
280E:  CLRF   x84
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
2810:  MOVLW  0F
2812:  ANDWF  x79,W
2814:  IORLW  60
2816:  MOVWF  x79
....................    } 
....................    else 
2818:  BRA    2822
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
281A:  MOVLW  0F
281C:  ANDWF  x79,W
281E:  IORLW  50
2820:  MOVWF  x79
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
2822:  MOVFF  1B,388
2826:  MOVFF  1A,387
282A:  MOVFF  19,386
282E:  MOVFF  18,385
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
2832:  MOVLW  06
2834:  ADDWF  x59,W
2836:  MOVWF  FE9
2838:  MOVLW  00
283A:  ADDWFC x5A,W
283C:  MOVWF  FEA
283E:  MOVFF  FEF,00
2842:  MOVFF  FEC,01
2846:  MOVFF  FEC,02
284A:  MOVFF  FEC,03
284E:  MOVFF  03,38C
2852:  MOVFF  02,38B
2856:  MOVFF  01,38A
285A:  MOVFF  00,389
....................    pseudoHeader.Zero           = 0x0; 
285E:  CLRF   x8D
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
2860:  MOVLW  06
2862:  MOVWF  x8E
....................    pseudoHeader.TCPLength      = len; 
2864:  MOVFF  36A,390
2868:  MOVFF  369,38F
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
286C:  MOVFF  390,3B1
2870:  MOVFF  38F,3B0
2874:  MOVLB  0
2876:  CALL   0F8E
287A:  MOVFF  02,390
287E:  MOVFF  01,38F
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
2882:  MOVLW  03
2884:  MOVLB  3
2886:  MOVWF  x92
2888:  MOVLW  85
288A:  MOVFF  392,394
288E:  MOVWF  x93
2890:  CLRF   x96
2892:  MOVLW  0C
2894:  MOVWF  x95
2896:  MOVLB  0
2898:  CALL   1C22
289C:  MOVFF  01,37D
28A0:  MOVLB  3
28A2:  COMF   x7D,F
28A4:  MOVFF  02,37E
28A8:  COMF   x7E,F
....................    checkSum.Val = header.Checksum; 
28AA:  MOVFF  37E,36C
28AE:  MOVFF  37D,36B
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
28B2:  MOVFF  35A,392
28B6:  MOVFF  359,391
28BA:  MOVLW  06
28BC:  MOVWF  x93
28BE:  MOVFF  36A,395
28C2:  MOVFF  369,394
28C6:  MOVLB  0
28C8:  RCALL  260A
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
28CA:  MOVLW  03
28CC:  MOVLB  3
28CE:  MOVWF  x92
28D0:  MOVLW  6D
28D2:  MOVFF  392,3B6
28D6:  MOVWF  xB5
28D8:  CLRF   xB8
28DA:  MOVLW  14
28DC:  MOVWF  xB7
28DE:  MOVLB  0
28E0:  CALL   137E
....................  
....................    if ( flags & SYN ) 
28E4:  MOVLB  3
28E6:  BTFSS  x67.1
28E8:  BRA    2904
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
28EA:  MOVLW  03
28EC:  MOVWF  x92
28EE:  MOVLW  81
28F0:  MOVFF  392,3B6
28F4:  MOVWF  xB5
28F6:  CLRF   xB8
28F8:  MOVLW  04
28FA:  MOVWF  xB7
28FC:  MOVLB  0
28FE:  CALL   137E
2902:  MOVLB  3
....................  
....................    IPSetTxBuffer(buff, 0); 
2904:  MOVFF  368,3AA
2908:  CLRF   xAC
290A:  MOVLW  14
290C:  MOVWF  xAB
290E:  MOVLB  0
2910:  CALL   12BA
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
2914:  MOVFF  36A,392
2918:  MOVFF  369,391
291C:  CALL   1D38
2920:  MOVFF  02,36C
2924:  MOVFF  01,36B
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
2928:  MOVFF  368,3AA
292C:  MOVLB  3
292E:  CLRF   xAC
2930:  MOVLW  24
2932:  MOVWF  xAB
2934:  MOVLB  0
2936:  CALL   12BA
....................    MACPut(checkSum.v[1]); 
293A:  MOVFF  36C,3B4
293E:  CALL   1364
....................    MACPut(checkSum.v[0]); 
2942:  MOVFF  36B,3B4
2946:  CALL   1364
....................    MACSetTxBuffer(buff, 0); 
294A:  MOVFF  368,3AA
294E:  MOVLB  3
2950:  CLRF   xAC
2952:  CLRF   xAB
2954:  MOVLB  0
2956:  CALL   12BA
....................  
....................    MACFlush(); 
295A:  CALL   1496
295E:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
2960:  MOVLB  0
2962:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
20F2:  MOVLW  FE
20F4:  MOVLB  3
20F6:  MOVWF  x3B
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
20F8:  CLRF   x3A
20FA:  MOVF   x3A,W
20FC:  SUBLW  04
20FE:  BTFSS  FD8.0
2100:  BRA    21F6
....................    { 
....................       ps = &TCB[s]; 
2102:  MOVF   x3A,W
2104:  MULLW  24
2106:  MOVF   FF3,W
2108:  CLRF   03
210A:  ADDLW  5F
210C:  MOVWF  01
210E:  MOVLW  00
2110:  ADDWFC 03,F
2112:  MOVFF  01,338
2116:  MOVFF  03,339
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
211A:  MOVFF  338,FE9
211E:  MOVFF  339,FEA
2122:  MOVF   FEF,W
2124:  SUBLW  0A
2126:  BZ    21F2
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
2128:  MOVLW  0B
212A:  ADDWF  x38,W
212C:  MOVWF  FE9
212E:  MOVLW  00
2130:  ADDWFC x39,W
2132:  MOVWF  FEA
2134:  MOVFF  FEC,33D
2138:  MOVF   FED,F
213A:  MOVFF  FEF,33C
213E:  MOVLW  02
2140:  ADDWF  x34,W
2142:  MOVWF  FE9
2144:  MOVLW  00
2146:  ADDWFC x35,W
2148:  MOVWF  FEA
214A:  MOVFF  FEC,03
214E:  MOVF   FED,F
2150:  MOVF   FEF,W
2152:  SUBWF  x3C,W
2154:  BNZ   21F2
2156:  MOVF   03,W
2158:  SUBWF  x3D,W
215A:  BNZ   21F2
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
215C:  MOVFF  338,FE9
2160:  MOVFF  339,FEA
2164:  MOVF   FEF,F
2166:  BNZ   216C
....................                partialMatch = s; 
2168:  MOVFF  33A,33B
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
216C:  MOVLW  0D
216E:  ADDWF  x38,W
2170:  MOVWF  FE9
2172:  MOVLW  00
2174:  ADDWFC x39,W
2176:  MOVWF  FEA
2178:  MOVFF  FEC,33D
217C:  MOVF   FED,F
217E:  MOVFF  FEF,33C
2182:  MOVFF  334,FE9
2186:  MOVFF  335,FEA
218A:  MOVFF  FEC,03
218E:  MOVF   FED,F
2190:  MOVF   FEF,W
2192:  SUBWF  x3C,W
2194:  BNZ   21F2
2196:  MOVF   03,W
2198:  SUBWF  x3D,W
219A:  BNZ   21F2
219C:  MOVLW  07
219E:  ADDWF  x38,W
21A0:  MOVWF  FE9
21A2:  MOVLW  00
21A4:  ADDWFC x39,W
21A6:  MOVWF  FEA
21A8:  MOVFF  FEF,33C
21AC:  MOVFF  FEC,33D
21B0:  MOVFF  FEC,33E
21B4:  MOVFF  FEC,33F
21B8:  MOVLW  06
21BA:  ADDWF  x36,W
21BC:  MOVWF  FE9
21BE:  MOVLW  00
21C0:  ADDWFC x37,W
21C2:  MOVWF  FEA
21C4:  MOVFF  FEF,00
21C8:  MOVFF  FEC,01
21CC:  MOVFF  FEC,02
21D0:  MOVFF  FEC,03
21D4:  MOVF   00,W
21D6:  SUBWF  x3C,W
21D8:  BNZ   21F2
21DA:  MOVF   01,W
21DC:  SUBWF  x3D,W
21DE:  BNZ   21F2
21E0:  MOVF   02,W
21E2:  SUBWF  x3E,W
21E4:  BNZ   21F2
21E6:  MOVF   03,W
21E8:  SUBWF  x3F,W
21EA:  BNZ   21F2
....................             { 
....................                return s; 
21EC:  MOVFF  33A,01
21F0:  BRA    22CA
....................             } 
....................          } 
....................       } 
....................    } 
21F2:  INCF   x3A,F
21F4:  BRA    20FA
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
21F6:  MOVF   x3B,W
21F8:  SUBLW  FE
21FA:  BNZ   2202
....................       return INVALID_SOCKET; 
21FC:  MOVLW  FE
21FE:  MOVWF  01
2200:  BRA    22CA
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
2202:  MOVF   x3B,W
2204:  MULLW  24
2206:  MOVF   FF3,W
2208:  CLRF   03
220A:  ADDLW  5F
220C:  MOVWF  01
220E:  MOVLW  00
2210:  ADDWFC 03,F
2212:  MOVFF  01,338
2216:  MOVFF  03,339
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
221A:  MOVLW  01
221C:  ADDWF  x38,W
221E:  MOVWF  x3C
2220:  MOVLW  00
2222:  ADDWFC x39,W
2224:  MOVWF  x3D
2226:  MOVWF  FEA
2228:  MOVFF  33C,FE9
222C:  MOVFF  337,FE2
2230:  MOVFF  336,FE1
2234:  MOVLW  0A
2236:  MOVWF  01
2238:  MOVFF  FE6,FEE
223C:  DECFSZ 01,F
223E:  BRA    2238
....................    ps->remotePort          = h->SourcePort; 
2240:  MOVLW  0D
2242:  ADDWF  x38,W
2244:  MOVWF  01
2246:  MOVLW  00
2248:  ADDWFC x39,W
224A:  MOVFF  334,FE9
224E:  MOVFF  335,FEA
2252:  MOVFF  FEC,03
2256:  MOVF   FED,F
2258:  MOVFF  FEF,33E
225C:  MOVWF  FEA
225E:  MOVFF  01,FE9
2262:  MOVFF  03,FEC
2266:  MOVF   FED,F
2268:  MOVFF  33E,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
226C:  MOVLW  23
226E:  ADDWF  x38,W
2270:  MOVWF  FE9
2272:  MOVLW  00
2274:  ADDWFC x39,W
2276:  MOVWF  FEA
2278:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
227A:  MOVLW  0F
227C:  ADDWF  x38,W
227E:  MOVWF  FE9
2280:  MOVLW  00
2282:  ADDWFC x39,W
2284:  MOVWF  FEA
2286:  INCFSZ FEF,W
2288:  BRA    228C
228A:  BRA    22B8
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
228C:  MOVLW  0F
228E:  ADDWF  x38,W
2290:  MOVWF  FE9
2292:  MOVLW  00
2294:  ADDWFC x39,W
2296:  MOVWF  FEA
2298:  MOVFF  FEF,33C
229C:  MOVFF  33C,355
22A0:  MOVLB  0
22A2:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
22A6:  MOVLW  0F
22A8:  MOVLB  3
22AA:  ADDWF  x38,W
22AC:  MOVWF  FE9
22AE:  MOVLW  00
22B0:  ADDWFC x39,W
22B2:  MOVWF  FEA
22B4:  MOVLW  FF
22B6:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
22B8:  MOVLW  23
22BA:  ADDWF  x38,W
22BC:  MOVWF  FE9
22BE:  MOVLW  00
22C0:  ADDWFC x39,W
22C2:  MOVWF  FEA
22C4:  BSF    FEF.1
....................  
....................    return partialMatch; 
22C6:  MOVFF  33B,01
.................... } 
22CA:  MOVLB  0
22CC:  GOTO   35A2 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
1ECC:  MOVLB  3
1ECE:  MOVFF  391,01
1ED2:  MOVFF  392,03
1ED6:  MOVFF  391,393
1EDA:  MOVFF  392,394
1EDE:  MOVFF  391,FE9
1EE2:  MOVFF  392,FEA
1EE6:  MOVFF  FEC,396
1EEA:  MOVF   FED,F
1EEC:  MOVFF  FEF,395
1EF0:  MOVFF  396,3B1
1EF4:  MOVFF  395,3B0
1EF8:  MOVLB  0
1EFA:  CALL   0F8E
1EFE:  MOVFF  394,FEA
1F02:  MOVFF  393,FE9
1F06:  MOVFF  02,FEC
1F0A:  MOVF   FED,F
1F0C:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
1F10:  MOVLW  02
1F12:  MOVLB  3
1F14:  ADDWF  x91,W
1F16:  MOVWF  01
1F18:  MOVLW  00
1F1A:  ADDWFC x92,W
1F1C:  MOVWF  03
1F1E:  MOVFF  01,393
1F22:  MOVWF  x94
1F24:  MOVLW  02
1F26:  ADDWF  x91,W
1F28:  MOVWF  FE9
1F2A:  MOVLW  00
1F2C:  ADDWFC x92,W
1F2E:  MOVWF  FEA
1F30:  MOVFF  FEC,396
1F34:  MOVF   FED,F
1F36:  MOVFF  FEF,395
1F3A:  MOVFF  396,3B1
1F3E:  MOVFF  395,3B0
1F42:  MOVLB  0
1F44:  CALL   0F8E
1F48:  MOVFF  394,FEA
1F4C:  MOVFF  393,FE9
1F50:  MOVFF  02,FEC
1F54:  MOVF   FED,F
1F56:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
1F5A:  MOVLW  04
1F5C:  MOVLB  3
1F5E:  ADDWF  x91,W
1F60:  MOVWF  01
1F62:  MOVLW  00
1F64:  ADDWFC x92,W
1F66:  MOVWF  03
1F68:  MOVFF  01,393
1F6C:  MOVWF  x94
1F6E:  MOVLW  04
1F70:  ADDWF  x91,W
1F72:  MOVWF  FE9
1F74:  MOVLW  00
1F76:  ADDWFC x92,W
1F78:  MOVWF  FEA
1F7A:  MOVFF  FEF,395
1F7E:  MOVFF  FEC,396
1F82:  MOVFF  FEC,397
1F86:  MOVFF  FEC,398
1F8A:  MOVFF  398,39C
1F8E:  MOVFF  397,39B
1F92:  MOVFF  396,39A
1F96:  MOVFF  395,399
1F9A:  MOVLB  0
1F9C:  RCALL  1EAA
1F9E:  MOVFF  394,FEA
1FA2:  MOVFF  393,FE9
1FA6:  MOVFF  00,FEF
1FAA:  MOVFF  01,FEC
1FAE:  MOVFF  02,FEC
1FB2:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
1FB6:  MOVLW  08
1FB8:  MOVLB  3
1FBA:  ADDWF  x91,W
1FBC:  MOVWF  01
1FBE:  MOVLW  00
1FC0:  ADDWFC x92,W
1FC2:  MOVWF  03
1FC4:  MOVFF  01,393
1FC8:  MOVWF  x94
1FCA:  MOVLW  08
1FCC:  ADDWF  x91,W
1FCE:  MOVWF  FE9
1FD0:  MOVLW  00
1FD2:  ADDWFC x92,W
1FD4:  MOVWF  FEA
1FD6:  MOVFF  FEF,395
1FDA:  MOVFF  FEC,396
1FDE:  MOVFF  FEC,397
1FE2:  MOVFF  FEC,398
1FE6:  MOVFF  398,39C
1FEA:  MOVFF  397,39B
1FEE:  MOVFF  396,39A
1FF2:  MOVFF  395,399
1FF6:  MOVLB  0
1FF8:  RCALL  1EAA
1FFA:  MOVFF  394,FEA
1FFE:  MOVFF  393,FE9
2002:  MOVFF  00,FEF
2006:  MOVFF  01,FEC
200A:  MOVFF  02,FEC
200E:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
2012:  MOVLW  0E
2014:  MOVLB  3
2016:  ADDWF  x91,W
2018:  MOVWF  01
201A:  MOVLW  00
201C:  ADDWFC x92,W
201E:  MOVWF  03
2020:  MOVFF  01,393
2024:  MOVWF  x94
2026:  MOVLW  0E
2028:  ADDWF  x91,W
202A:  MOVWF  FE9
202C:  MOVLW  00
202E:  ADDWFC x92,W
2030:  MOVWF  FEA
2032:  MOVFF  FEC,396
2036:  MOVF   FED,F
2038:  MOVFF  FEF,395
203C:  MOVFF  396,3B1
2040:  MOVFF  395,3B0
2044:  MOVLB  0
2046:  CALL   0F8E
204A:  MOVFF  394,FEA
204E:  MOVFF  393,FE9
2052:  MOVFF  02,FEC
2056:  MOVF   FED,F
2058:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
205C:  MOVLW  10
205E:  MOVLB  3
2060:  ADDWF  x91,W
2062:  MOVWF  01
2064:  MOVLW  00
2066:  ADDWFC x92,W
2068:  MOVWF  03
206A:  MOVFF  01,393
206E:  MOVWF  x94
2070:  MOVLW  10
2072:  ADDWF  x91,W
2074:  MOVWF  FE9
2076:  MOVLW  00
2078:  ADDWFC x92,W
207A:  MOVWF  FEA
207C:  MOVFF  FEC,396
2080:  MOVF   FED,F
2082:  MOVFF  FEF,395
2086:  MOVFF  396,3B1
208A:  MOVFF  395,3B0
208E:  MOVLB  0
2090:  CALL   0F8E
2094:  MOVFF  394,FEA
2098:  MOVFF  393,FE9
209C:  MOVFF  02,FEC
20A0:  MOVF   FED,F
20A2:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
20A6:  MOVLW  12
20A8:  MOVLB  3
20AA:  ADDWF  x91,W
20AC:  MOVWF  01
20AE:  MOVLW  00
20B0:  ADDWFC x92,W
20B2:  MOVWF  03
20B4:  MOVFF  01,393
20B8:  MOVWF  x94
20BA:  MOVLW  12
20BC:  ADDWF  x91,W
20BE:  MOVWF  FE9
20C0:  MOVLW  00
20C2:  ADDWFC x92,W
20C4:  MOVWF  FEA
20C6:  MOVFF  FEC,396
20CA:  MOVF   FED,F
20CC:  MOVFF  FEF,395
20D0:  MOVFF  396,3B1
20D4:  MOVFF  395,3B0
20D8:  MOVLB  0
20DA:  CALL   0F8E
20DE:  MOVFF  394,FEA
20E2:  MOVFF  393,FE9
20E6:  MOVFF  02,FEC
20EA:  MOVF   FED,F
20EC:  MOVFF  01,FEF
.................... } 
20F0:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
22EA:  MOVLW  0F
22EC:  MOVLB  3
22EE:  ADDWF  x52,W
22F0:  MOVWF  FE9
22F2:  MOVLW  00
22F4:  ADDWFC x53,W
22F6:  MOVWF  FEA
22F8:  INCFSZ FEF,W
22FA:  BRA    22FE
22FC:  BRA    2338
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
22FE:  MOVLW  0F
2300:  ADDWF  x52,W
2302:  MOVWF  FE9
2304:  MOVLW  00
2306:  ADDWFC x53,W
2308:  MOVWF  FEA
230A:  MOVFF  FEF,354
230E:  MOVFF  354,355
2312:  MOVLB  0
2314:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
2318:  MOVLW  0F
231A:  MOVLB  3
231C:  ADDWF  x52,W
231E:  MOVWF  FE9
2320:  MOVLW  00
2322:  ADDWFC x53,W
2324:  MOVWF  FEA
2326:  MOVLW  FF
2328:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
232A:  MOVLW  23
232C:  ADDWF  x52,W
232E:  MOVWF  FE9
2330:  MOVLW  00
2332:  ADDWFC x53,W
2334:  MOVWF  FEA
2336:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
2338:  MOVLW  07
233A:  ADDWF  x52,W
233C:  MOVWF  FE9
233E:  MOVLW  00
2340:  ADDWFC x53,W
2342:  MOVWF  FEA
2344:  MOVF   FEE,F
2346:  MOVF   FEE,F
2348:  CLRF   FEC
234A:  MOVF   FED,F
234C:  CLRF   FEF
234E:  MOVF   FED,F
2350:  CLRF   FEF
2352:  MOVF   FED,F
2354:  CLRF   FEF
....................     ps->remotePort = 0x00; 
2356:  MOVLW  0D
2358:  ADDWF  x52,W
235A:  MOVWF  FE9
235C:  MOVLW  00
235E:  ADDWFC x53,W
2360:  MOVWF  FEA
2362:  CLRF   FEC
2364:  MOVF   FED,F
2366:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
2368:  MOVLW  23
236A:  ADDWF  x52,W
236C:  MOVWF  FE9
236E:  MOVLW  00
2370:  ADDWFC x53,W
2372:  MOVWF  FEA
2374:  BTFSS  FEF.3
2376:  BRA    2380
....................     { 
....................         MACDiscardRx(); 
2378:  MOVLB  0
237A:  CALL   0EC2
237E:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
2380:  MOVLW  23
2382:  ADDWF  x52,W
2384:  MOVWF  FE9
2386:  MOVLW  00
2388:  ADDWFC x53,W
238A:  MOVWF  FEA
238C:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
238E:  MOVLW  21
2390:  ADDWF  x52,W
2392:  MOVWF  FE9
2394:  MOVLW  00
2396:  ADDWFC x53,W
2398:  MOVWF  FEA
239A:  CLRF   FEC
239C:  MOVF   FED,F
239E:  MOVLW  1E
23A0:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
23A2:  MOVLW  23
23A4:  ADDWF  x52,W
23A6:  MOVWF  FE9
23A8:  MOVLW  00
23AA:  ADDWFC x53,W
23AC:  MOVWF  FEA
23AE:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
23B0:  MOVLW  23
23B2:  ADDWF  x52,W
23B4:  MOVWF  FE9
23B6:  MOVLW  00
23B8:  ADDWFC x53,W
23BA:  MOVWF  FEA
23BC:  BTFSS  FEF.0
23BE:  BRA    23CC
....................     { 
....................         ps->smState = TCP_LISTEN; 
23C0:  MOVFF  352,FE9
23C4:  MOVFF  353,FEA
23C8:  CLRF   FEF
....................     } 
....................     else 
23CA:  BRA    23D8
....................     { 
....................         ps->smState = TCP_CLOSED; 
23CC:  MOVFF  352,FE9
23D0:  MOVFF  353,FEA
23D4:  MOVLW  0A
23D6:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
23D8:  MOVLW  10
23DA:  ADDWF  x52,W
23DC:  MOVWF  FE9
23DE:  MOVLW  00
23E0:  ADDWFC x53,W
23E2:  MOVWF  FEA
23E4:  CLRF   FEC
23E6:  MOVF   FED,F
23E8:  CLRF   FEF
....................  
....................     return; 
.................... } 
23EA:  MOVLB  0
23EC:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
2964:  MOVLB  3
2966:  MOVF   x34,W
2968:  MULLW  24
296A:  MOVF   FF3,W
296C:  CLRF   03
296E:  ADDLW  5F
2970:  MOVWF  01
2972:  MOVLW  00
2974:  ADDWFC 03,F
2976:  MOVFF  01,34B
297A:  MOVFF  03,34C
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
297E:  CLRF   x4D
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
2980:  MOVLW  1E
2982:  ADDWF  x4B,W
2984:  MOVWF  FE9
2986:  MOVLW  00
2988:  ADDWFC x4C,W
298A:  MOVWF  FEA
298C:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
298E:  MOVLW  1F
2990:  ADDWF  x4B,W
2992:  MOVWF  01
2994:  MOVLW  00
2996:  ADDWFC x4C,W
2998:  MOVWF  03
299A:  MOVFF  01,352
299E:  MOVWF  x53
29A0:  MOVLB  0
29A2:  RCALL  22D0
29A4:  MOVFF  353,FEA
29A8:  MOVFF  352,FE9
29AC:  MOVFF  02,FEC
29B0:  MOVF   FED,F
29B2:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
29B6:  MOVLW  21
29B8:  MOVLB  3
29BA:  ADDWF  x4B,W
29BC:  MOVWF  FE9
29BE:  MOVLW  00
29C0:  ADDWFC x4C,W
29C2:  MOVWF  FEA
29C4:  CLRF   FEC
29C6:  MOVF   FED,F
29C8:  MOVLW  1E
29CA:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
29CC:  MOVLW  0D
29CE:  ADDWF  x37,W
29D0:  MOVWF  FE9
29D2:  MOVLW  00
29D4:  ADDWFC x38,W
29D6:  MOVWF  FEA
29D8:  BTFSS  FEF.2
29DA:  BRA    2A18
....................    { 
....................       MACDiscardRx(); 
29DC:  MOVLB  0
29DE:  CALL   0EC2
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
29E2:  MOVLB  3
29E4:  MOVFF  34B,01
29E8:  MOVFF  34C,03
29EC:  MOVFF  34B,352
29F0:  MOVFF  34C,353
29F4:  MOVLW  23
29F6:  ADDWF  x4B,W
29F8:  MOVWF  FE9
29FA:  MOVLW  00
29FC:  ADDWFC x4C,W
29FE:  MOVWF  FEA
2A00:  BTFSS  FEF.0
2A02:  BRA    2A08
2A04:  MOVLW  00
2A06:  BRA    2A0A
2A08:  MOVLW  01
2A0A:  MOVFF  353,FEA
2A0E:  MOVFF  352,FE9
2A12:  MOVWF  FEF
....................       return; 
2A14:  GOTO   3430
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
2A18:  MOVLW  16
2A1A:  ADDWF  x4B,W
2A1C:  MOVWF  FE9
2A1E:  MOVLW  00
2A20:  ADDWFC x4C,W
2A22:  MOVWF  FEA
2A24:  MOVFF  FEF,00
2A28:  MOVFF  FEC,01
2A2C:  MOVFF  FEC,02
2A30:  MOVFF  FEC,03
2A34:  MOVFF  03,342
2A38:  MOVFF  02,341
2A3C:  MOVFF  01,340
2A40:  MOVFF  00,33F
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
2A44:  MOVLW  0E
2A46:  ADDWF  x37,W
2A48:  MOVWF  FE9
2A4A:  MOVLW  00
2A4C:  ADDWFC x38,W
2A4E:  MOVWF  FEA
2A50:  MOVFF  FEC,03
2A54:  MOVF   FED,F
2A56:  MOVFF  FEF,352
2A5A:  MOVFF  03,353
2A5E:  CLRF   x54
2A60:  CLRF   x55
2A62:  MOVLW  08
2A64:  ADDWF  x37,W
2A66:  MOVWF  FE9
2A68:  MOVLW  00
2A6A:  ADDWFC x38,W
2A6C:  MOVWF  FEA
2A6E:  MOVFF  FEF,00
2A72:  MOVFF  FEC,01
2A76:  MOVFF  FEC,02
2A7A:  MOVFF  FEC,03
2A7E:  MOVF   00,W
2A80:  SUBWF  x3F,W
2A82:  MOVWF  00
2A84:  MOVF   01,W
2A86:  SUBWFB x40,W
2A88:  MOVWF  01
2A8A:  MOVF   02,W
2A8C:  SUBWFB x41,W
2A8E:  MOVWF  02
2A90:  MOVF   03,W
2A92:  SUBWFB x42,W
2A94:  MOVWF  03
2A96:  MOVF   00,W
2A98:  SUBWF  x52,F
2A9A:  MOVF   01,W
2A9C:  SUBWFB x53,F
2A9E:  MOVF   02,W
2AA0:  SUBWFB x54,F
2AA2:  MOVF   03,W
2AA4:  SUBWFB x55,F
2AA6:  MOVLW  10
2AA8:  ADDWF  x4B,W
2AAA:  MOVWF  FE9
2AAC:  MOVLW  00
2AAE:  ADDWFC x4C,W
2AB0:  MOVWF  FEA
2AB2:  MOVFF  FEC,03
2AB6:  MOVF   FED,F
2AB8:  MOVFF  FEF,00
2ABC:  MOVFF  03,01
2AC0:  CLRF   02
2AC2:  CLRF   03
2AC4:  MOVF   00,W
2AC6:  SUBWF  x52,W
2AC8:  MOVWF  x4E
2ACA:  MOVF   01,W
2ACC:  SUBWFB x53,W
2ACE:  MOVWF  x4F
2AD0:  MOVF   02,W
2AD2:  SUBWFB x54,W
2AD4:  MOVWF  x50
2AD6:  MOVF   03,W
2AD8:  SUBWFB x55,W
2ADA:  MOVWF  x51
....................    if(temp < 0) 
2ADC:  BTFSC  x51.7
2ADE:  BRA    2AE2
2AE0:  BRA    2AF6
....................    { 
....................       ps->RemoteWindow = 0; 
2AE2:  MOVLW  14
2AE4:  ADDWF  x4B,W
2AE6:  MOVWF  FE9
2AE8:  MOVLW  00
2AEA:  ADDWFC x4C,W
2AEC:  MOVWF  FEA
2AEE:  CLRF   FEC
2AF0:  MOVF   FED,F
2AF2:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
2AF4:  BRA    2B0A
....................    { 
....................       ps->RemoteWindow = ack; 
2AF6:  MOVLW  14
2AF8:  ADDWF  x4B,W
2AFA:  MOVWF  FE9
2AFC:  MOVLW  00
2AFE:  ADDWFC x4C,W
2B00:  MOVWF  FEA
2B02:  MOVFF  33B,FEF
2B06:  MOVFF  33C,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
2B0A:  MOVFF  34B,FE9
2B0E:  MOVFF  34C,FEA
2B12:  DECFSZ FEF,W
2B14:  BRA    2C92
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
2B16:  MOVLW  0D
2B18:  ADDWF  x37,W
2B1A:  MOVWF  FE9
2B1C:  MOVLW  00
2B1E:  ADDWFC x38,W
2B20:  MOVWF  FEA
2B22:  BTFSC  FEF.1
2B24:  BRA    2B4A
....................       { 
....................          MACDiscardRx(); 
2B26:  MOVLB  0
2B28:  CALL   0EC2
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
2B2C:  MOVLW  0D
2B2E:  MOVLB  3
2B30:  ADDWF  x37,W
2B32:  MOVWF  FE9
2B34:  MOVLW  00
2B36:  ADDWFC x38,W
2B38:  MOVWF  FEA
2B3A:  BTFSS  FEF.4
2B3C:  BRA    2B46
....................           { 
....................             flags = RST; 
2B3E:  MOVLW  04
2B40:  MOVWF  x4D
....................             goto SendTCPControlPacket; 
2B42:  GOTO   33B8
....................            } 
....................  
....................          return; 
2B46:  GOTO   3430
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2B4A:  MOVLW  1A
2B4C:  ADDWF  x4B,W
2B4E:  MOVWF  01
2B50:  MOVLW  00
2B52:  ADDWFC x4C,W
2B54:  MOVFF  01,352
2B58:  MOVWF  x53
2B5A:  MOVLW  04
2B5C:  ADDWF  x37,W
2B5E:  MOVWF  FE9
2B60:  MOVLW  00
2B62:  ADDWFC x38,W
2B64:  MOVWF  FEA
2B66:  MOVFF  FEF,354
2B6A:  MOVFF  FEC,355
2B6E:  MOVFF  FEC,356
2B72:  MOVFF  FEC,357
2B76:  MOVF   x39,W
2B78:  ADDWF  x54,F
2B7A:  MOVF   x3A,W
2B7C:  ADDWFC x55,F
2B7E:  MOVLW  00
2B80:  ADDWFC x56,F
2B82:  ADDWFC x57,F
2B84:  MOVLW  01
2B86:  ADDWF  x54,W
2B88:  MOVWF  00
2B8A:  MOVLW  00
2B8C:  ADDWFC x55,W
2B8E:  MOVWF  01
2B90:  MOVLW  00
2B92:  ADDWFC x56,W
2B94:  MOVWF  02
2B96:  MOVLW  00
2B98:  ADDWFC x57,W
2B9A:  MOVFF  353,FEA
2B9E:  MOVFF  352,FE9
2BA2:  MOVFF  00,FEF
2BA6:  MOVFF  01,FEC
2BAA:  MOVFF  02,FEC
2BAE:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
2BB0:  MOVLW  1A
2BB2:  ADDWF  x4B,W
2BB4:  MOVWF  FE9
2BB6:  MOVLW  00
2BB8:  ADDWFC x4C,W
2BBA:  MOVWF  FEA
2BBC:  MOVFF  FEF,00
2BC0:  MOVFF  FEC,01
2BC4:  MOVFF  FEC,02
2BC8:  MOVFF  FEC,03
2BCC:  MOVFF  03,33E
2BD0:  MOVFF  02,33D
2BD4:  MOVFF  01,33C
2BD8:  MOVFF  00,33B
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
2BDC:  MOVLW  0D
2BDE:  ADDWF  x37,W
2BE0:  MOVWF  FE9
2BE2:  MOVLW  00
2BE4:  ADDWFC x38,W
2BE6:  MOVWF  FEA
2BE8:  BTFSC  FEF.4
2BEA:  BRA    2C08
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
2BEC:  MOVFF  34B,FE9
2BF0:  MOVFF  34C,FEA
2BF4:  MOVLW  02
2BF6:  MOVWF  FEF
....................          MACDiscardRx(); 
2BF8:  MOVLB  0
2BFA:  CALL   0EC2
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
2BFE:  MOVLW  12
2C00:  MOVLB  3
2C02:  MOVWF  x4D
....................          goto SendTCPControlPacket; 
2C04:  GOTO   33B8
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
2C08:  MOVFF  34B,FE9
2C0C:  MOVFF  34C,FEA
2C10:  MOVLW  03
2C12:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
2C14:  MOVLW  10
2C16:  MOVWF  x4D
....................  
....................       ps->RemoteWindow = h->Window; 
2C18:  MOVLW  14
2C1A:  ADDWF  x4B,W
2C1C:  MOVWF  01
2C1E:  MOVLW  00
2C20:  ADDWFC x4C,W
2C22:  MOVWF  03
2C24:  MOVWF  x53
2C26:  MOVLW  0E
2C28:  ADDWF  x37,W
2C2A:  MOVWF  FE9
2C2C:  MOVLW  00
2C2E:  ADDWFC x38,W
2C30:  MOVWF  FEA
2C32:  MOVFF  FEC,03
2C36:  MOVF   FED,F
2C38:  MOVFF  FEF,354
2C3C:  MOVFF  353,FEA
2C40:  MOVFF  01,FE9
2C44:  MOVFF  03,FEC
2C48:  MOVF   FED,F
2C4A:  MOVFF  354,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
2C4E:  MOVF   x39,W
2C50:  IORWF  x3A,W
2C52:  BZ    2C88
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
2C54:  MOVLW  23
2C56:  ADDWF  x4B,W
2C58:  MOVWF  FE9
2C5A:  MOVLW  00
2C5C:  ADDWFC x4C,W
2C5E:  MOVWF  FEA
2C60:  BSF    FEF.3
....................          ps->RxCount             = len; 
2C62:  MOVLW  12
2C64:  ADDWF  x4B,W
2C66:  MOVWF  FE9
2C68:  MOVLW  00
2C6A:  ADDWFC x4C,W
2C6C:  MOVWF  FEA
2C6E:  MOVFF  33A,FEC
2C72:  MOVF   FED,F
2C74:  MOVFF  339,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
2C78:  MOVLW  23
2C7A:  ADDWF  x4B,W
2C7C:  MOVWF  FE9
2C7E:  MOVLW  00
2C80:  ADDWFC x4C,W
2C82:  MOVWF  FEA
2C84:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
2C86:  BRA    2C90
....................       { 
....................          MACDiscardRx(); 
2C88:  MOVLB  0
2C8A:  CALL   0EC2
2C8E:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
2C90:  BRA    33B8
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
2C92:  MOVFF  34B,FE9
2C96:  MOVFF  34C,FEA
2C9A:  MOVF   FEF,F
2C9C:  BTFSS  FD8.2
2C9E:  BRA    2E28
....................    { 
....................       MACDiscardRx(); 
2CA0:  MOVLB  0
2CA2:  CALL   0EC2
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
2CA6:  MOVLW  0D
2CA8:  MOVLB  3
2CAA:  ADDWF  x37,W
2CAC:  MOVWF  FE9
2CAE:  MOVLW  00
2CB0:  ADDWFC x38,W
2CB2:  MOVWF  FEA
2CB4:  BTFSC  FEF.1
2CB6:  BRA    2CBE
....................       { 
....................          flags = RST; 
2CB8:  MOVLW  04
2CBA:  MOVWF  x4D
....................          goto SendTCPControlPacket; 
2CBC:  BRA    33B8
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2CBE:  MOVLW  1A
2CC0:  ADDWF  x4B,W
2CC2:  MOVWF  01
2CC4:  MOVLW  00
2CC6:  ADDWFC x4C,W
2CC8:  MOVFF  01,352
2CCC:  MOVWF  x53
2CCE:  MOVLW  04
2CD0:  ADDWF  x37,W
2CD2:  MOVWF  FE9
2CD4:  MOVLW  00
2CD6:  ADDWFC x38,W
2CD8:  MOVWF  FEA
2CDA:  MOVFF  FEF,354
2CDE:  MOVFF  FEC,355
2CE2:  MOVFF  FEC,356
2CE6:  MOVFF  FEC,357
2CEA:  MOVF   x39,W
2CEC:  ADDWF  x54,F
2CEE:  MOVF   x3A,W
2CF0:  ADDWFC x55,F
2CF2:  MOVLW  00
2CF4:  ADDWFC x56,F
2CF6:  ADDWFC x57,F
2CF8:  MOVLW  01
2CFA:  ADDWF  x54,W
2CFC:  MOVWF  00
2CFE:  MOVLW  00
2D00:  ADDWFC x55,W
2D02:  MOVWF  01
2D04:  MOVLW  00
2D06:  ADDWFC x56,W
2D08:  MOVWF  02
2D0A:  MOVLW  00
2D0C:  ADDWFC x57,W
2D0E:  MOVFF  353,FEA
2D12:  MOVFF  352,FE9
2D16:  MOVFF  00,FEF
2D1A:  MOVFF  01,FEC
2D1E:  MOVFF  02,FEC
2D22:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
2D24:  MOVLW  14
2D26:  ADDWF  x4B,W
2D28:  MOVWF  01
2D2A:  MOVLW  00
2D2C:  ADDWFC x4C,W
2D2E:  MOVWF  03
2D30:  MOVWF  x53
2D32:  MOVLW  0E
2D34:  ADDWF  x37,W
2D36:  MOVWF  FE9
2D38:  MOVLW  00
2D3A:  ADDWFC x38,W
2D3C:  MOVWF  FEA
2D3E:  MOVFF  FEC,03
2D42:  MOVF   FED,F
2D44:  MOVFF  FEF,354
2D48:  MOVFF  353,FEA
2D4C:  MOVFF  01,FE9
2D50:  MOVFF  03,FEC
2D54:  MOVF   FED,F
2D56:  MOVFF  354,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
2D5A:  MOVLW  01
2D5C:  ADDWF  x4B,W
2D5E:  MOVWF  x52
2D60:  MOVLW  00
2D62:  ADDWFC x4C,W
2D64:  MOVWF  x53
2D66:  MOVWF  FEA
2D68:  MOVFF  352,FE9
2D6C:  MOVFF  336,FE2
2D70:  MOVFF  335,FE1
2D74:  MOVLW  0A
2D76:  MOVWF  01
2D78:  MOVFF  FE6,FEE
2D7C:  DECFSZ 01,F
2D7E:  BRA    2D78
....................       ps->remotePort = h->SourcePort; 
2D80:  MOVLW  0D
2D82:  ADDWF  x4B,W
2D84:  MOVWF  01
2D86:  MOVLW  00
2D88:  ADDWFC x4C,W
2D8A:  MOVFF  337,FE9
2D8E:  MOVFF  338,FEA
2D92:  MOVFF  FEC,03
2D96:  MOVF   FED,F
2D98:  MOVFF  FEF,354
2D9C:  MOVWF  FEA
2D9E:  MOVFF  01,FE9
2DA2:  MOVFF  03,FEC
2DA6:  MOVF   FED,F
2DA8:  MOVFF  354,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
2DAC:  MOVFF  34B,FE9
2DB0:  MOVFF  34C,FEA
2DB4:  MOVLW  02
2DB6:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
2DB8:  MOVLW  16
2DBA:  ADDWF  x4B,W
2DBC:  MOVWF  FE9
2DBE:  MOVLW  00
2DC0:  ADDWFC x4C,W
2DC2:  MOVWF  FEA
2DC4:  MOVF   FEE,F
2DC6:  MOVF   FEE,F
2DC8:  MOVF   FEE,F
2DCA:  MOVFF  FED,03
2DCE:  MOVFF  FED,02
2DD2:  MOVFF  FED,01
2DD6:  MOVFF  FEF,00
2DDA:  MOVLW  01
2DDC:  ADDWF  FEE,F
2DDE:  MOVLW  00
2DE0:  ADDWFC FEE,F
2DE2:  ADDWFC FEE,F
2DE4:  ADDWFC FED,F
2DE6:  MOVFF  03,342
2DEA:  MOVFF  02,341
2DEE:  MOVFF  01,340
2DF2:  MOVFF  00,33F
....................       ack =  ps->SND_ACK; 
2DF6:  MOVLW  1A
2DF8:  ADDWF  x4B,W
2DFA:  MOVWF  FE9
2DFC:  MOVLW  00
2DFE:  ADDWFC x4C,W
2E00:  MOVWF  FEA
2E02:  MOVFF  FEF,00
2E06:  MOVFF  FEC,01
2E0A:  MOVFF  FEC,02
2E0E:  MOVFF  FEC,03
2E12:  MOVFF  03,33E
2E16:  MOVFF  02,33D
2E1A:  MOVFF  01,33C
2E1E:  MOVFF  00,33B
....................       flags = SYN | ACK; 
2E22:  MOVLW  12
2E24:  MOVWF  x4D
....................       goto SendTCPControlPacket; 
2E26:  BRA    33B8
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
2E28:  MOVLW  1A
2E2A:  ADDWF  x4B,W
2E2C:  MOVWF  FE9
2E2E:  MOVLW  00
2E30:  ADDWFC x4C,W
2E32:  MOVWF  FEA
2E34:  MOVFF  FEF,00
2E38:  MOVFF  FEC,01
2E3C:  MOVFF  FEC,02
2E40:  MOVFF  FEC,03
2E44:  MOVFF  03,346
2E48:  MOVFF  02,345
2E4C:  MOVFF  01,344
2E50:  MOVFF  00,343
....................    prevSeq = ps->SND_SEQ; 
2E54:  MOVLW  16
2E56:  ADDWF  x4B,W
2E58:  MOVWF  FE9
2E5A:  MOVLW  00
2E5C:  ADDWFC x4C,W
2E5E:  MOVWF  FEA
2E60:  MOVFF  FEF,00
2E64:  MOVFF  FEC,01
2E68:  MOVFF  FEC,02
2E6C:  MOVFF  FEC,03
2E70:  MOVFF  03,34A
2E74:  MOVFF  02,349
2E78:  MOVFF  01,348
2E7C:  MOVFF  00,347
....................  
....................    ack = h->SeqNumber; 
2E80:  MOVLW  04
2E82:  ADDWF  x37,W
2E84:  MOVWF  FE9
2E86:  MOVLW  00
2E88:  ADDWFC x38,W
2E8A:  MOVWF  FEA
2E8C:  MOVFF  FEF,00
2E90:  MOVFF  FEC,01
2E94:  MOVFF  FEC,02
2E98:  MOVFF  FEC,03
2E9C:  MOVFF  03,33E
2EA0:  MOVFF  02,33D
2EA4:  MOVFF  01,33C
2EA8:  MOVFF  00,33B
....................    ack += (DWORD)len; 
2EAC:  CLRF   02
2EAE:  CLRF   03
2EB0:  MOVF   x39,W
2EB2:  ADDWF  x3B,F
2EB4:  MOVF   x3A,W
2EB6:  ADDWFC x3C,F
2EB8:  MOVF   02,W
2EBA:  ADDWFC x3D,F
2EBC:  MOVF   03,W
2EBE:  ADDWFC x3E,F
....................    seq = ps->SND_SEQ; 
2EC0:  MOVLW  16
2EC2:  ADDWF  x4B,W
2EC4:  MOVWF  FE9
2EC6:  MOVLW  00
2EC8:  ADDWFC x4C,W
2ECA:  MOVWF  FEA
2ECC:  MOVFF  FEF,00
2ED0:  MOVFF  FEC,01
2ED4:  MOVFF  FEC,02
2ED8:  MOVFF  FEC,03
2EDC:  MOVFF  03,342
2EE0:  MOVFF  02,341
2EE4:  MOVFF  01,340
2EE8:  MOVFF  00,33F
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
2EEC:  MOVLW  04
2EEE:  ADDWF  x37,W
2EF0:  MOVWF  FE9
2EF2:  MOVLW  00
2EF4:  ADDWFC x38,W
2EF6:  MOVWF  FEA
2EF8:  MOVFF  FEF,352
2EFC:  MOVFF  FEC,353
2F00:  MOVFF  FEC,354
2F04:  MOVFF  FEC,355
2F08:  MOVF   x43,W
2F0A:  SUBWF  x52,W
2F0C:  BTFSS  FD8.2
2F0E:  BRA    339C
2F10:  MOVF   x44,W
2F12:  SUBWF  x53,W
2F14:  BTFSS  FD8.2
2F16:  BRA    339C
2F18:  MOVF   x45,W
2F1A:  SUBWF  x54,W
2F1C:  BTFSS  FD8.2
2F1E:  BRA    339C
2F20:  MOVF   x46,W
2F22:  SUBWF  x55,W
2F24:  BTFSS  FD8.2
2F26:  BRA    339C
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
2F28:  MOVFF  34B,FE9
2F2C:  MOVFF  34C,FEA
2F30:  MOVF   FEF,W
2F32:  SUBLW  02
2F34:  BNZ   2FBC
....................          { 
....................             if(h->Flags.bits.flagACK) 
2F36:  MOVLW  0D
2F38:  ADDWF  x37,W
2F3A:  MOVWF  FE9
2F3C:  MOVLW  00
2F3E:  ADDWFC x38,W
2F40:  MOVWF  FEA
2F42:  BTFSS  FEF.4
2F44:  BRA    2FB2
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
2F46:  MOVLW  1A
2F48:  ADDWF  x4B,W
2F4A:  MOVWF  FE9
2F4C:  MOVLW  00
2F4E:  ADDWFC x4C,W
2F50:  MOVWF  FEA
2F52:  MOVFF  33B,FEF
2F56:  MOVFF  33C,FEC
2F5A:  MOVFF  33D,FEC
2F5E:  MOVFF  33E,FEC
....................                ps->smState = TCP_ESTABLISHED; 
2F62:  MOVFF  34B,FE9
2F66:  MOVFF  34C,FEA
2F6A:  MOVLW  03
2F6C:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
2F6E:  MOVF   x39,W
2F70:  IORWF  x3A,W
2F72:  BZ    2FA8
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
2F74:  MOVLW  23
2F76:  ADDWF  x4B,W
2F78:  MOVWF  FE9
2F7A:  MOVLW  00
2F7C:  ADDWFC x4C,W
2F7E:  MOVWF  FEA
2F80:  BSF    FEF.3
....................                   ps->RxCount             = len; 
2F82:  MOVLW  12
2F84:  ADDWF  x4B,W
2F86:  MOVWF  FE9
2F88:  MOVLW  00
2F8A:  ADDWFC x4C,W
2F8C:  MOVWF  FEA
2F8E:  MOVFF  33A,FEC
2F92:  MOVF   FED,F
2F94:  MOVFF  339,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
2F98:  MOVLW  23
2F9A:  ADDWF  x4B,W
2F9C:  MOVWF  FE9
2F9E:  MOVLW  00
2FA0:  ADDWFC x4C,W
2FA2:  MOVWF  FEA
2FA4:  BSF    FEF.2
....................                } 
....................                else 
2FA6:  BRA    2FB0
....................                   MACDiscardRx(); 
2FA8:  MOVLB  0
2FAA:  CALL   0EC2
2FAE:  MOVLB  3
....................             } 
....................             else   // No ACK to our SYN 
2FB0:  BRA    2FBA
....................             { 
....................                MACDiscardRx(); 
2FB2:  MOVLB  0
2FB4:  CALL   0EC2
2FB8:  MOVLB  3
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
2FBA:  BRA    339A
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
2FBC:  MOVLW  1A
2FBE:  ADDWF  x4B,W
2FC0:  MOVWF  FE9
2FC2:  MOVLW  00
2FC4:  ADDWFC x4C,W
2FC6:  MOVWF  FEA
2FC8:  MOVFF  33B,FEF
2FCC:  MOVFF  33C,FEC
2FD0:  MOVFF  33D,FEC
2FD4:  MOVFF  33E,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
2FD8:  MOVFF  34B,FE9
2FDC:  MOVFF  34C,FEA
2FE0:  MOVF   FEF,W
2FE2:  SUBLW  03
2FE4:  BTFSS  FD8.2
2FE6:  BRA    31AC
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
2FE8:  MOVLW  0D
2FEA:  ADDWF  x37,W
2FEC:  MOVWF  FE9
2FEE:  MOVLW  00
2FF0:  ADDWFC x38,W
2FF2:  MOVWF  FEA
2FF4:  BTFSS  FEF.4
2FF6:  BRA    3054
2FF8:  MOVLW  23
2FFA:  ADDWF  x4B,W
2FFC:  MOVWF  FE9
2FFE:  MOVLW  00
3000:  ADDWFC x4C,W
3002:  MOVWF  FEA
3004:  BTFSC  FEF.1
3006:  BRA    3054
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
3008:  MOVLW  0F
300A:  ADDWF  x4B,W
300C:  MOVWF  FE9
300E:  MOVLW  00
3010:  ADDWFC x4C,W
3012:  MOVWF  FEA
3014:  INCFSZ FEF,W
3016:  BRA    301A
3018:  BRA    3054
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
301A:  MOVLW  0F
301C:  ADDWF  x4B,W
301E:  MOVWF  FE9
3020:  MOVLW  00
3022:  ADDWFC x4C,W
3024:  MOVWF  FEA
3026:  MOVFF  FEF,352
302A:  MOVFF  352,355
302E:  MOVLB  0
3030:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
3034:  MOVLW  0F
3036:  MOVLB  3
3038:  ADDWF  x4B,W
303A:  MOVWF  FE9
303C:  MOVLW  00
303E:  ADDWFC x4C,W
3040:  MOVWF  FEA
3042:  MOVLW  FF
3044:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
3046:  MOVLW  23
3048:  ADDWF  x4B,W
304A:  MOVWF  FE9
304C:  MOVLW  00
304E:  ADDWFC x4C,W
3050:  MOVWF  FEA
3052:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
3054:  MOVLW  0D
3056:  ADDWF  x37,W
3058:  MOVWF  FE9
305A:  MOVLW  00
305C:  ADDWFC x38,W
305E:  MOVWF  FEA
3060:  BTFSS  FEF.0
3062:  BRA    3114
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
3064:  MOVLW  11
3066:  MOVWF  x4D
....................                   seq = ps->SND_SEQ++; 
3068:  MOVLW  16
306A:  ADDWF  x4B,W
306C:  MOVWF  FE9
306E:  MOVLW  00
3070:  ADDWFC x4C,W
3072:  MOVWF  FEA
3074:  MOVF   FEE,F
3076:  MOVF   FEE,F
3078:  MOVF   FEE,F
307A:  MOVFF  FED,03
307E:  MOVFF  FED,02
3082:  MOVFF  FED,01
3086:  MOVFF  FEF,00
308A:  MOVLW  01
308C:  ADDWF  FEE,F
308E:  MOVLW  00
3090:  ADDWFC FEE,F
3092:  ADDWFC FEE,F
3094:  ADDWFC FED,F
3096:  MOVFF  03,342
309A:  MOVFF  02,341
309E:  MOVFF  01,340
30A2:  MOVFF  00,33F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
30A6:  MOVLW  1A
30A8:  ADDWF  x4B,W
30AA:  MOVWF  FE9
30AC:  MOVLW  00
30AE:  ADDWFC x4C,W
30B0:  MOVWF  FEA
30B2:  MOVLW  01
30B4:  ADDWF  FEF,W
30B6:  MOVWF  00
30B8:  MOVLW  00
30BA:  ADDWFC FEC,W
30BC:  MOVWF  01
30BE:  MOVLW  00
30C0:  ADDWFC FEC,W
30C2:  MOVWF  02
30C4:  MOVLW  00
30C6:  ADDWFC FEC,W
30C8:  MOVF   FED,F
30CA:  MOVF   FED,F
30CC:  MOVF   FED,F
30CE:  MOVFF  00,FEF
30D2:  MOVFF  01,FEC
30D6:  MOVFF  02,FEC
30DA:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
30DC:  MOVLW  1A
30DE:  ADDWF  x4B,W
30E0:  MOVWF  FE9
30E2:  MOVLW  00
30E4:  ADDWFC x4C,W
30E6:  MOVWF  FEA
30E8:  MOVFF  FEF,00
30EC:  MOVFF  FEC,01
30F0:  MOVFF  FEC,02
30F4:  MOVFF  FEC,03
30F8:  MOVFF  03,33E
30FC:  MOVFF  02,33D
3100:  MOVFF  01,33C
3104:  MOVFF  00,33B
....................                   ps->smState = TCP_LAST_ACK; 
3108:  MOVFF  34B,FE9
310C:  MOVFF  34C,FEA
3110:  MOVLW  09
3112:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
3114:  MOVF   x39,W
3116:  IORWF  x3A,W
3118:  BZ    31A2
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
311A:  MOVLW  23
311C:  ADDWF  x4B,W
311E:  MOVWF  FE9
3120:  MOVLW  00
3122:  ADDWFC x4C,W
3124:  MOVWF  FEA
3126:  BTFSC  FEF.3
3128:  BRA    3160
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
312A:  MOVLW  23
312C:  ADDWF  x4B,W
312E:  MOVWF  FE9
3130:  MOVLW  00
3132:  ADDWFC x4C,W
3134:  MOVWF  FEA
3136:  BSF    FEF.3
....................                      ps->RxCount             = len; 
3138:  MOVLW  12
313A:  ADDWF  x4B,W
313C:  MOVWF  FE9
313E:  MOVLW  00
3140:  ADDWFC x4C,W
3142:  MOVWF  FEA
3144:  MOVFF  33A,FEC
3148:  MOVF   FED,F
314A:  MOVFF  339,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
314E:  MOVLW  23
3150:  ADDWF  x4B,W
3152:  MOVWF  FE9
3154:  MOVLW  00
3156:  ADDWFC x4C,W
3158:  MOVWF  FEA
315A:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
315C:  BSF    x4D.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
315E:  BRA    31A0
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
3160:  MOVLW  16
3162:  ADDWF  x4B,W
3164:  MOVWF  FE9
3166:  MOVLW  00
3168:  ADDWFC x4C,W
316A:  MOVWF  FEA
316C:  MOVFF  347,FEF
3170:  MOVFF  348,FEC
3174:  MOVFF  349,FEC
3178:  MOVFF  34A,FEC
....................                      ps->SND_ACK = prevAck; 
317C:  MOVLW  1A
317E:  ADDWF  x4B,W
3180:  MOVWF  FE9
3182:  MOVLW  00
3184:  ADDWFC x4C,W
3186:  MOVWF  FEA
3188:  MOVFF  343,FEF
318C:  MOVFF  344,FEC
3190:  MOVFF  345,FEC
3194:  MOVFF  346,FEC
....................  
....................                      MACDiscardRx(); 
3198:  MOVLB  0
319A:  CALL   0EC2
319E:  MOVLB  3
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
31A0:  BRA    31AA
....................                { 
....................                   MACDiscardRx(); 
31A2:  MOVLB  0
31A4:  CALL   0EC2
31A8:  MOVLB  3
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
31AA:  BRA    339A
31AC:  MOVFF  34B,FE9
31B0:  MOVFF  34C,FEA
31B4:  MOVF   FEF,W
31B6:  SUBLW  09
31B8:  BNZ   31E4
....................             { 
....................                MACDiscardRx(); 
31BA:  MOVLB  0
31BC:  CALL   0EC2
....................  
....................                if(h->Flags.bits.flagACK) 
31C0:  MOVLW  0D
31C2:  MOVLB  3
31C4:  ADDWF  x37,W
31C6:  MOVWF  FE9
31C8:  MOVLW  00
31CA:  ADDWFC x38,W
31CC:  MOVWF  FEA
31CE:  BTFSS  FEF.4
31D0:  BRA    31E2
....................                { 
....................                   CloseSocket(ps); 
31D2:  MOVFF  34C,353
31D6:  MOVFF  34B,352
31DA:  MOVLB  0
31DC:  CALL   22EA
31E0:  MOVLB  3
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
31E2:  BRA    339A
31E4:  MOVFF  34B,FE9
31E8:  MOVFF  34C,FEA
31EC:  MOVF   FEF,W
31EE:  SUBLW  04
31F0:  BNZ   32C6
....................             { 
....................                MACDiscardRx(); 
31F2:  MOVLB  0
31F4:  CALL   0EC2
....................  
....................                if(h->Flags.bits.flagFIN) 
31F8:  MOVLW  0D
31FA:  MOVLB  3
31FC:  ADDWF  x37,W
31FE:  MOVWF  FE9
3200:  MOVLW  00
3202:  ADDWFC x38,W
3204:  MOVWF  FEA
3206:  BTFSS  FEF.0
3208:  BRA    32A4
....................                { 
....................                   flags = ACK; 
320A:  MOVLW  10
320C:  MOVWF  x4D
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
320E:  MOVLW  1A
3210:  ADDWF  x4B,W
3212:  MOVWF  FE9
3214:  MOVLW  00
3216:  ADDWFC x4C,W
3218:  MOVWF  FEA
321A:  MOVLW  01
321C:  ADDWF  FEF,W
321E:  MOVWF  00
3220:  MOVLW  00
3222:  ADDWFC FEC,W
3224:  MOVWF  01
3226:  MOVLW  00
3228:  ADDWFC FEC,W
322A:  MOVWF  02
322C:  MOVLW  00
322E:  ADDWFC FEC,W
3230:  MOVF   FED,F
3232:  MOVF   FED,F
3234:  MOVF   FED,F
3236:  MOVFF  00,FEF
323A:  MOVFF  01,FEC
323E:  MOVFF  02,FEC
3242:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
3244:  MOVLW  1A
3246:  ADDWF  x4B,W
3248:  MOVWF  FE9
324A:  MOVLW  00
324C:  ADDWFC x4C,W
324E:  MOVWF  FEA
3250:  MOVFF  FEF,00
3254:  MOVFF  FEC,01
3258:  MOVFF  FEC,02
325C:  MOVFF  FEC,03
3260:  MOVFF  03,33E
3264:  MOVFF  02,33D
3268:  MOVFF  01,33C
326C:  MOVFF  00,33B
....................                   if(h->Flags.bits.flagACK) 
3270:  MOVLW  0D
3272:  ADDWF  x37,W
3274:  MOVWF  FE9
3276:  MOVLW  00
3278:  ADDWFC x38,W
327A:  MOVWF  FEA
327C:  BTFSS  FEF.4
327E:  BRA    3292
....................                   { 
....................                      CloseSocket(ps); 
3280:  MOVFF  34C,353
3284:  MOVFF  34B,352
3288:  MOVLB  0
328A:  CALL   22EA
....................                   } 
....................                   else 
328E:  BRA    32A0
3290:  MOVLB  3
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
3292:  MOVFF  34B,FE9
3296:  MOVFF  34C,FEA
329A:  MOVLW  06
329C:  MOVWF  FEF
329E:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
32A0:  BRA    32C2
32A2:  MOVLB  3
32A4:  MOVLW  0D
32A6:  ADDWF  x37,W
32A8:  MOVWF  FE9
32AA:  MOVLW  00
32AC:  ADDWFC x38,W
32AE:  MOVWF  FEA
32B0:  BTFSS  FEF.4
32B2:  BRA    32C0
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
32B4:  MOVFF  34B,FE9
32B8:  MOVFF  34C,FEA
32BC:  MOVLW  05
32BE:  MOVWF  FEF
32C0:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
32C2:  BRA    3398
32C4:  MOVLB  3
32C6:  MOVFF  34B,FE9
32CA:  MOVFF  34C,FEA
32CE:  MOVF   FEF,W
32D0:  SUBLW  05
32D2:  BNZ   3364
....................             { 
....................                MACDiscardRx(); 
32D4:  MOVLB  0
32D6:  CALL   0EC2
....................  
....................                if(h->Flags.bits.flagFIN) 
32DA:  MOVLW  0D
32DC:  MOVLB  3
32DE:  ADDWF  x37,W
32E0:  MOVWF  FE9
32E2:  MOVLW  00
32E4:  ADDWFC x38,W
32E6:  MOVWF  FEA
32E8:  BTFSS  FEF.0
32EA:  BRA    3362
....................                { 
....................                   flags = ACK; 
32EC:  MOVLW  10
32EE:  MOVWF  x4D
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
32F0:  MOVLW  1A
32F2:  ADDWF  x4B,W
32F4:  MOVWF  FE9
32F6:  MOVLW  00
32F8:  ADDWFC x4C,W
32FA:  MOVWF  FEA
32FC:  MOVLW  01
32FE:  ADDWF  FEF,W
3300:  MOVWF  00
3302:  MOVLW  00
3304:  ADDWFC FEC,W
3306:  MOVWF  01
3308:  MOVLW  00
330A:  ADDWFC FEC,W
330C:  MOVWF  02
330E:  MOVLW  00
3310:  ADDWFC FEC,W
3312:  MOVF   FED,F
3314:  MOVF   FED,F
3316:  MOVF   FED,F
3318:  MOVFF  00,FEF
331C:  MOVFF  01,FEC
3320:  MOVFF  02,FEC
3324:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
3326:  MOVLW  1A
3328:  ADDWF  x4B,W
332A:  MOVWF  FE9
332C:  MOVLW  00
332E:  ADDWFC x4C,W
3330:  MOVWF  FEA
3332:  MOVFF  FEF,00
3336:  MOVFF  FEC,01
333A:  MOVFF  FEC,02
333E:  MOVFF  FEC,03
3342:  MOVFF  03,33E
3346:  MOVFF  02,33D
334A:  MOVFF  01,33C
334E:  MOVFF  00,33B
....................                   CloseSocket(ps); 
3352:  MOVFF  34C,353
3356:  MOVFF  34B,352
335A:  MOVLB  0
335C:  CALL   22EA
3360:  MOVLB  3
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
3362:  BRA    339A
3364:  MOVFF  34B,FE9
3368:  MOVFF  34C,FEA
336C:  MOVF   FEF,W
336E:  SUBLW  06
3370:  BNZ   339A
....................             { 
....................                MACDiscardRx(); 
3372:  MOVLB  0
3374:  CALL   0EC2
....................  
....................                if ( h->Flags.bits.flagACK ) 
3378:  MOVLW  0D
337A:  MOVLB  3
337C:  ADDWF  x37,W
337E:  MOVWF  FE9
3380:  MOVLW  00
3382:  ADDWFC x38,W
3384:  MOVWF  FEA
3386:  BTFSS  FEF.4
3388:  BRA    339A
....................                { 
....................                   CloseSocket(ps); 
338A:  MOVFF  34C,353
338E:  MOVFF  34B,352
3392:  MOVLB  0
3394:  CALL   22EA
3398:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
339A:  BRA    33B8
....................       { 
....................          MACDiscardRx(); 
339C:  MOVLB  0
339E:  CALL   0EC2
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
33A2:  MOVLW  10
33A4:  MOVLB  3
33A6:  MOVWF  x4D
....................          ack = prevAck; 
33A8:  MOVFF  346,33E
33AC:  MOVFF  345,33D
33B0:  MOVFF  344,33C
33B4:  MOVFF  343,33B
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
33B8:  MOVF   x4D,F
33BA:  BZ    3430
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
33BC:  MOVLW  02
33BE:  ADDWF  x37,W
33C0:  MOVWF  FE9
33C2:  MOVLW  00
33C4:  ADDWFC x38,W
33C6:  MOVWF  FEA
33C8:  MOVFF  FEC,353
33CC:  MOVF   FED,F
33CE:  MOVFF  FEF,352
33D2:  MOVFF  337,FE9
33D6:  MOVFF  338,FEA
33DA:  MOVFF  FEC,355
33DE:  MOVF   FED,F
33E0:  MOVFF  FEF,354
33E4:  MOVFF  336,35A
33E8:  MOVFF  335,359
33EC:  MOVFF  353,35C
33F0:  MOVFF  352,35B
33F4:  MOVFF  355,35E
33F8:  MOVFF  354,35D
33FC:  MOVFF  342,362
3400:  MOVFF  341,361
3404:  MOVFF  340,360
3408:  MOVFF  33F,35F
340C:  MOVFF  33E,366
3410:  MOVFF  33D,365
3414:  MOVFF  33C,364
3418:  MOVFF  33B,363
341C:  MOVFF  34D,367
3420:  MOVLW  FF
3422:  MOVWF  x68
3424:  CLRF   x6A
3426:  CLRF   x69
3428:  MOVLB  0
342A:  CALL   2736
342E:  MOVLB  3
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
3430:  MOVLB  0
3432:  GOTO   35D0 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     //debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
36C2:  MOVLW  03
36C4:  MOVLB  3
36C6:  MOVWF  x61
36C8:  MOVLW  14
36CA:  MOVFF  361,3A0
36CE:  MOVWF  x9F
36D0:  CLRF   xA2
36D2:  MOVLW  08
36D4:  MOVWF  xA1
36D6:  MOVLB  0
36D8:  CALL   0F2E
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
36DC:  MOVLB  3
36DE:  CLRF   x5F
36E0:  CLRF   x5E
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
36E2:  MOVFF  30F,03
36E6:  MOVFF  30E,FE9
36EA:  MOVFF  30F,FEA
36EE:  MOVFF  FEF,360
36F2:  CLRF   x62
36F4:  MOVLW  14
36F6:  MOVWF  x61
36F8:  CLRF   x64
36FA:  MOVFF  360,363
36FE:  MOVLB  0
3700:  CALL   18DE
3704:  MOVFF  02,35D
3708:  MOVFF  01,35C
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
370C:  MOVLB  3
370E:  MOVFF  30E,FE9
3712:  MOVFF  30F,FEA
3716:  MOVLW  08
3718:  SUBWF  FEF,W
371A:  MOVWF  FEF
....................     MACGetArray(data, *len); 
371C:  MOVFF  30F,03
3720:  MOVFF  30E,FE9
3724:  MOVFF  30F,FEA
3728:  MOVFF  FEF,360
372C:  MOVFF  30D,3A0
3730:  MOVFF  30C,39F
3734:  CLRF   xA2
3736:  MOVFF  360,3A1
373A:  MOVLB  0
373C:  CALL   0F2E
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
3740:  MOVLW  03
3742:  MOVLB  3
3744:  MOVWF  x61
3746:  MOVLW  14
3748:  MOVWF  x60
374A:  MOVLB  0
374C:  RCALL  35E2
....................  
....................     *code = packet.Type; 
374E:  MOVLB  3
3750:  MOVFF  30A,FE9
3754:  MOVFF  30B,FEA
3758:  MOVFF  314,FEF
....................     *id = packet.Identifier; 
375C:  MOVFF  310,FE9
3760:  MOVFF  311,FEA
3764:  MOVFF  319,FEC
3768:  MOVF   FED,F
376A:  MOVFF  318,FEF
....................     *seq = packet.SequenceNumber; 
376E:  MOVFF  312,FE9
3772:  MOVFF  313,FEA
3776:  MOVFF  31B,FEC
377A:  MOVF   FED,F
377C:  MOVFF  31A,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
3780:  MOVF   x5E,W
3782:  SUBWF  x5C,W
3784:  BNZ   378C
3786:  MOVF   x5F,W
3788:  SUBWF  x5D,W
378A:  BZ    3790
378C:  MOVLW  00
378E:  BRA    3792
3790:  MOVLW  01
3792:  MOVWF  01
.................... } 
3794:  MOVLB  0
3796:  GOTO   6A70 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
379A:  MOVLW  01
379C:  MOVLB  3
379E:  MOVWF  x91
37A0:  MOVLB  0
37A2:  CALL   1290
37A6:  MOVFF  01,35C
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
37AA:  MOVLB  3
37AC:  INCFSZ x5C,W
37AE:  BRA    37B2
....................       return; 
37B0:  BRA    38A6
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
37B2:  MOVFF  35C,3AA
37B6:  CLRF   xAC
37B8:  MOVLW  14
37BA:  MOVWF  xAB
37BC:  MOVLB  0
37BE:  CALL   12BA
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
37C2:  CLRF   03
37C4:  MOVLB  3
37C6:  MOVF   x0D,W
37C8:  ADDLW  08
37CA:  MOVWF  x5A
37CC:  MOVLW  00
37CE:  ADDWFC 03,W
37D0:  MOVWF  x5B
....................  
....................     packet.Code             = 0; 
37D2:  CLRF   x13
....................     packet.Type             = code; 
37D4:  MOVFF  30A,312
....................     packet.Checksum         = 0; 
37D8:  CLRF   x15
37DA:  CLRF   x14
....................     packet.Identifier       = id; 
37DC:  MOVFF  30F,317
37E0:  MOVFF  30E,316
....................     packet.SequenceNumber   = seq; 
37E4:  MOVFF  311,319
37E8:  MOVFF  310,318
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
37EC:  MOVLW  03
37EE:  MOVWF  FEA
37F0:  MOVLW  1A
37F2:  MOVWF  FE9
37F4:  MOVFF  30C,FE2
37F8:  MOVFF  30B,FE1
37FC:  MOVF   x0D,W
37FE:  MOVWF  01
3800:  BZ    380A
3802:  MOVFF  FE6,FEE
3806:  DECFSZ 01,F
3808:  BRA    3802
....................  
....................     SwapICMPPacket(&packet); 
380A:  MOVLW  03
380C:  MOVWF  x61
380E:  MOVLW  12
3810:  MOVWF  x60
3812:  MOVLB  0
3814:  RCALL  35E2
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
3816:  MOVLW  08
3818:  MOVLB  3
381A:  ADDWF  x0D,W
381C:  CLRF   x5E
381E:  MOVWF  x5D
3820:  MOVFF  309,392
3824:  MOVFF  308,391
3828:  MOVLW  01
382A:  MOVWF  x93
382C:  MOVFF  35E,395
3830:  MOVFF  35D,394
3834:  MOVLB  0
3836:  CALL   260A
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
383A:  MOVLW  03
383C:  MOVLB  3
383E:  MOVWF  x5E
3840:  MOVLW  12
3842:  MOVFF  35E,3B6
3846:  MOVWF  xB5
3848:  MOVFF  35B,3B8
384C:  MOVFF  35A,3B7
3850:  MOVLB  0
3852:  CALL   137E
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
3856:  MOVLB  3
3858:  CLRF   xAB
385A:  MOVLW  14
385C:  MOVWF  xAA
385E:  MOVFF  35B,3AD
3862:  MOVFF  35A,3AC
3866:  MOVLB  0
3868:  CALL   2532
386C:  MOVFF  02,315
3870:  MOVFF  01,314
....................    IPSetTxBuffer(MyTxBuffer, 2); 
3874:  MOVFF  35C,3AA
3878:  MOVLB  3
387A:  CLRF   xAC
387C:  MOVLW  16
387E:  MOVWF  xAB
3880:  MOVLB  0
3882:  CALL   12BA
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
3886:  MOVLW  03
3888:  MOVLB  3
388A:  MOVWF  x5E
388C:  MOVLW  14
388E:  MOVFF  35E,3B6
3892:  MOVWF  xB5
3894:  CLRF   xB8
3896:  MOVLW  02
3898:  MOVWF  xB7
389A:  MOVLB  0
389C:  CALL   137E
.................... #endif 
....................  
....................  
....................     MACFlush(); 
38A0:  CALL   1496
38A4:  MOVLB  3
.................... } 
38A6:  MOVLB  0
38A8:  GOTO   6ACE (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
35E2:  MOVLW  04
35E4:  MOVLB  3
35E6:  ADDWF  x60,W
35E8:  MOVWF  01
35EA:  MOVLW  00
35EC:  ADDWFC x61,W
35EE:  MOVWF  03
35F0:  MOVFF  01,362
35F4:  MOVWF  x63
35F6:  MOVLW  04
35F8:  ADDWF  x60,W
35FA:  MOVWF  FE9
35FC:  MOVLW  00
35FE:  ADDWFC x61,W
3600:  MOVWF  FEA
3602:  MOVFF  FEC,365
3606:  MOVF   FED,F
3608:  MOVFF  FEF,364
360C:  MOVFF  365,3B1
3610:  MOVFF  364,3B0
3614:  MOVLB  0
3616:  CALL   0F8E
361A:  MOVFF  363,FEA
361E:  MOVFF  362,FE9
3622:  MOVFF  02,FEC
3626:  MOVF   FED,F
3628:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
362C:  MOVLW  06
362E:  MOVLB  3
3630:  ADDWF  x60,W
3632:  MOVWF  01
3634:  MOVLW  00
3636:  ADDWFC x61,W
3638:  MOVWF  03
363A:  MOVFF  01,362
363E:  MOVWF  x63
3640:  MOVLW  06
3642:  ADDWF  x60,W
3644:  MOVWF  FE9
3646:  MOVLW  00
3648:  ADDWFC x61,W
364A:  MOVWF  FEA
364C:  MOVFF  FEC,365
3650:  MOVF   FED,F
3652:  MOVFF  FEF,364
3656:  MOVFF  365,3B1
365A:  MOVFF  364,3B0
365E:  MOVLB  0
3660:  CALL   0F8E
3664:  MOVFF  363,FEA
3668:  MOVFF  362,FE9
366C:  MOVFF  02,FEC
3670:  MOVF   FED,F
3672:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
3676:  MOVLW  02
3678:  MOVLB  3
367A:  ADDWF  x60,W
367C:  MOVWF  01
367E:  MOVLW  00
3680:  ADDWFC x61,W
3682:  MOVWF  03
3684:  MOVFF  01,362
3688:  MOVWF  x63
368A:  MOVLW  02
368C:  ADDWF  x60,W
368E:  MOVWF  FE9
3690:  MOVLW  00
3692:  ADDWFC x61,W
3694:  MOVWF  FEA
3696:  MOVFF  FEC,365
369A:  MOVF   FED,F
369C:  MOVFF  FEF,364
36A0:  MOVFF  365,3B1
36A4:  MOVFF  364,3B0
36A8:  MOVLB  0
36AA:  CALL   0F8E
36AE:  MOVFF  363,FEA
36B2:  MOVFF  362,FE9
36B6:  MOVFF  02,FEC
36BA:  MOVF   FED,F
36BC:  MOVFF  01,FEF
.................... } 
36C0:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
0AB2:  BCF    58.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
0AB4:  MOVLW  FF
0AB6:  MOVLB  1
0AB8:  MOVWF  x15
....................     Cache.MACAddr.v[1] = 0xff; 
0ABA:  MOVWF  x16
....................     Cache.MACAddr.v[2] = 0xff; 
0ABC:  MOVWF  x17
....................     Cache.MACAddr.v[3] = 0xff; 
0ABE:  MOVWF  x18
....................     Cache.MACAddr.v[4] = 0xff; 
0AC0:  MOVWF  x19
....................     Cache.MACAddr.v[5] = 0xff; 
0AC2:  MOVWF  x1A
....................  
....................     Cache.IPAddr.Val = 0x0; 
0AC4:  CLRF   x1E
0AC6:  CLRF   x1D
0AC8:  CLRF   x1C
0ACA:  CLRF   x1B
.................... } 
0ACC:  MOVLB  0
0ACE:  GOTO   0EBA (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
184C:  MOVLW  00
184E:  BTFSC  58.1
1850:  MOVLW  01
1852:  XORLW  00
1854:  BZ    1858
1856:  BRA    18B6
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
1858:  MOVLW  03
185A:  MOVLB  3
185C:  MOVWF  x14
185E:  MOVLW  08
1860:  MOVWF  x13
1862:  MOVLW  03
1864:  MOVWF  x16
1866:  MOVLW  12
1868:  MOVWF  x15
186A:  MOVLB  0
186C:  BRA    11AE
186E:  MOVF   01,F
1870:  BNZ   1874
....................             break; 
1872:  BRA    18D6
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
1874:  CALL   0EC2
....................  
....................         if ( opCode == ARP_REPLY ) 
1878:  MOVLB  3
187A:  MOVF   x12,F
187C:  BNZ   18B2
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
187E:  MOVLW  01
1880:  MOVWF  FEA
1882:  MOVLW  15
1884:  MOVWF  FE9
1886:  MOVLW  03
1888:  MOVWF  FE2
188A:  MOVLW  08
188C:  MOVWF  FE1
188E:  MOVLW  06
1890:  MOVWF  01
1892:  MOVFF  FE6,FEE
1896:  DECFSZ 01,F
1898:  BRA    1892
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
189A:  MOVFF  311,11E
189E:  MOVFF  310,11D
18A2:  MOVFF  30F,11C
18A6:  MOVFF  30E,11B
....................             break; 
18AA:  MOVLB  0
18AC:  BRA    18D6
....................         } 
....................         else 
18AE:  BRA    18B6
18B0:  MOVLB  3
....................             smARP = SM_ARP_REPLY; 
18B2:  BSF    58.1
18B4:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
18B6:  MOVLW  03
18B8:  MOVLB  3
18BA:  MOVWF  x14
18BC:  MOVLW  08
18BE:  MOVWF  x13
18C0:  CLRF   x15
18C2:  MOVLB  0
18C4:  BRA    16BE
18C6:  MOVF   01,F
18C8:  BZ    18CE
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
18CA:  BCF    58.1
.................... 		} 
....................         else 
18CC:  BRA    18D4
....................             return FALSE; 
18CE:  MOVLW  00
18D0:  MOVWF  01
18D2:  BRA    18DA
....................         break; 
18D4:  BRA    18D6
....................  
....................     } 
....................     return TRUE; 
18D6:  MOVLW  01
18D8:  MOVWF  01
.................... } 
18DA:  GOTO   698C (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
11AE:  MOVLW  03
11B0:  MOVLB  3
11B2:  MOVWF  xA0
11B4:  MOVLW  17
11B6:  MOVWF  x9F
11B8:  CLRF   xA2
11BA:  MOVLW  1C
11BC:  MOVWF  xA1
11BE:  MOVLB  0
11C0:  RCALL  0F2E
....................  
....................     MACDiscardRx(); 
11C2:  RCALL  0EC2
....................  
....................     SwapARPPacket(&packet); 
11C4:  MOVLW  03
11C6:  MOVLB  3
11C8:  MOVWF  x34
11CA:  MOVLW  17
11CC:  MOVWF  x33
11CE:  MOVLB  0
11D0:  RCALL  10DA
....................  
.................... //   debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
.................... //      packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
.................... //      packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
.................... //      packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
.................... //      packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
11D2:  MOVLB  3
11D4:  DECFSZ x17,W
11D6:  BRA    11E8
11D8:  MOVF   x18,F
11DA:  BNZ   11E8
11DC:  MOVF   x1B,W
11DE:  SUBLW  06
11E0:  BNZ   11E8
11E2:  MOVF   x1C,W
11E4:  SUBLW  04
11E6:  BZ    11EE
....................          return FALSE; 
11E8:  MOVLW  00
11EA:  MOVWF  01
11EC:  BRA    128A
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
11EE:  MOVF   x1D,W
11F0:  SUBLW  02
11F2:  BNZ   1204
11F4:  MOVF   x1E,F
11F6:  BNZ   1204
....................         *opCode = ARP_REPLY; 
11F8:  MOVFF  315,FE9
11FC:  MOVFF  316,FEA
1200:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
1202:  BRA    122C
1204:  DECFSZ x1D,W
1206:  BRA    121A
1208:  MOVF   x1E,F
120A:  BNZ   121A
....................         *opCode = ARP_REQUEST; 
120C:  MOVFF  315,FE9
1210:  MOVFF  316,FEA
1214:  MOVLW  01
1216:  MOVWF  FEF
....................     else 
1218:  BRA    122C
....................     { 
....................         *opCode = ARP_UNKNOWN; 
121A:  MOVFF  315,FE9
121E:  MOVFF  316,FEA
1222:  MOVLW  02
1224:  MOVWF  FEF
....................         return FALSE; 
1226:  MOVLW  00
1228:  MOVWF  01
122A:  BRA    128A
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
122C:  MOVF   18,W
122E:  SUBWF  x2F,W
1230:  BNZ   1284
1232:  MOVF   19,W
1234:  SUBWF  x30,W
1236:  BNZ   1284
1238:  MOVF   1A,W
123A:  SUBWF  x31,W
123C:  BNZ   1284
123E:  MOVF   1B,W
1240:  SUBWF  x32,W
1242:  BNZ   1284
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
1244:  MOVFF  313,FE9
1248:  MOVFF  314,FEA
124C:  MOVLW  03
124E:  MOVWF  FE2
1250:  MOVLW  1F
1252:  MOVWF  FE1
1254:  MOVLW  06
1256:  MOVWF  01
1258:  MOVFF  FE6,FEE
125C:  DECFSZ 01,F
125E:  BRA    1258
....................         remote->IPAddr      = packet.SenderIPAddr; 
1260:  MOVLW  06
1262:  ADDWF  x13,W
1264:  MOVWF  FE9
1266:  MOVLW  00
1268:  ADDWFC x14,W
126A:  MOVWF  FEA
126C:  MOVFF  325,FEF
1270:  MOVFF  326,FEC
1274:  MOVFF  327,FEC
1278:  MOVFF  328,FEC
....................         return TRUE; 
127C:  MOVLW  01
127E:  MOVWF  01
1280:  BRA    128A
....................     } 
....................     else 
1282:  BRA    128A
....................         return FALSE; 
1284:  MOVLW  00
1286:  MOVWF  01
1288:  BRA    128A
.................... } 
128A:  MOVLB  0
128C:  GOTO   186E (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
16BE:  MOVLW  01
16C0:  MOVLB  3
16C2:  MOVWF  x91
16C4:  MOVLB  0
16C6:  RCALL  1290
16C8:  MOVFF  01,332
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
16CC:  MOVLB  3
16CE:  INCFSZ x32,W
16D0:  BRA    16D8
....................       return FALSE; 
16D2:  MOVLW  00
16D4:  MOVWF  01
16D6:  BRA    1846
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
16D8:  MOVFF  332,3AA
16DC:  CLRF   xAC
16DE:  CLRF   xAB
16E0:  MOVLB  0
16E2:  RCALL  12BA
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
16E4:  MOVLB  3
16E6:  CLRF   x17
16E8:  MOVLW  01
16EA:  MOVWF  x16
....................     packet.Protocol                 = ARP_IP; 
16EC:  MOVLW  08
16EE:  MOVWF  x19
16F0:  CLRF   x18
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
16F2:  MOVLW  06
16F4:  MOVWF  x1A
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
16F6:  MOVLW  04
16F8:  MOVWF  x1B
....................  
....................     if ( opCode == ARP_REQUEST ) 
16FA:  DECFSZ x15,W
16FC:  BRA    1714
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
16FE:  CLRF   x1D
1700:  MOVLW  01
1702:  MOVWF  x1C
....................         packet.TargetMACAddr.v[0]   = 0xff; 
1704:  MOVLW  FF
1706:  MOVWF  x28
....................         packet.TargetMACAddr.v[1]   = 0xff; 
1708:  MOVWF  x29
....................         packet.TargetMACAddr.v[2]   = 0xff; 
170A:  MOVWF  x2A
....................         packet.TargetMACAddr.v[3]   = 0xff; 
170C:  MOVWF  x2B
....................         packet.TargetMACAddr.v[4]   = 0xff; 
170E:  MOVWF  x2C
....................         packet.TargetMACAddr.v[5]   = 0xff; 
1710:  MOVWF  x2D
....................     } 
....................     else 
1712:  BRA    1742
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
1714:  CLRF   x1D
1716:  MOVLW  02
1718:  MOVWF  x1C
....................         packet.TargetMACAddr        = remote->MACAddr; 
171A:  MOVFF  314,03
171E:  MOVFF  313,333
1722:  MOVFF  314,334
1726:  MOVLW  03
1728:  MOVWF  FEA
172A:  MOVLW  28
172C:  MOVWF  FE9
172E:  MOVFF  314,FE2
1732:  MOVFF  313,FE1
1736:  MOVLW  06
1738:  MOVWF  01
173A:  MOVFF  FE6,FEE
173E:  DECFSZ 01,F
1740:  BRA    173A
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
1742:  MOVLW  03
1744:  MOVWF  FEA
1746:  MOVLW  1E
1748:  MOVWF  FE9
174A:  CLRF   FE2
174C:  MOVLW  1C
174E:  MOVWF  FE1
1750:  MOVLW  06
1752:  MOVWF  01
1754:  MOVFF  FE6,FEE
1758:  DECFSZ 01,F
175A:  BRA    1754
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
175C:  MOVFF  1B,327
1760:  MOVFF  1A,326
1764:  MOVFF  19,325
1768:  MOVFF  18,324
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
176C:  MOVLW  06
176E:  ADDWF  x13,W
1770:  MOVWF  FE9
1772:  MOVLW  00
1774:  ADDWFC x14,W
1776:  MOVWF  FEA
1778:  MOVFF  FEF,00
177C:  MOVFF  FEC,01
1780:  MOVFF  FEC,02
1784:  MOVFF  FEC,03
1788:  MOVF   00,W
178A:  XORWF  x24,W
178C:  MOVWF  x33
178E:  MOVF   01,W
1790:  XORWF  x25,W
1792:  MOVWF  x34
1794:  MOVF   02,W
1796:  XORWF  x26,W
1798:  MOVWF  x35
179A:  MOVF   03,W
179C:  XORWF  x27,W
179E:  MOVWF  x36
17A0:  MOVF   x33,W
17A2:  ANDWF  22,W
17A4:  MOVWF  00
17A6:  MOVF   x34,W
17A8:  ANDWF  23,W
17AA:  MOVWF  01
17AC:  MOVF   x35,W
17AE:  ANDWF  24,W
17B0:  MOVWF  02
17B2:  MOVF   x36,W
17B4:  ANDWF  25,W
17B6:  MOVWF  03
17B8:  MOVF   00,F
17BA:  BNZ   17C8
17BC:  MOVF   01,F
17BE:  BNZ   17C8
17C0:  MOVF   02,F
17C2:  BNZ   17C8
17C4:  MOVF   03,F
17C6:  BZ    17DA
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
17C8:  MOVFF  29,331
17CC:  MOVFF  28,330
17D0:  MOVFF  27,32F
17D4:  MOVFF  26,32E
....................     } 
....................     else 
17D8:  BRA    1806
....................         packet.TargetIPAddr             = remote->IPAddr; 
17DA:  MOVLW  06
17DC:  ADDWF  x13,W
17DE:  MOVWF  FE9
17E0:  MOVLW  00
17E2:  ADDWFC x14,W
17E4:  MOVWF  FEA
17E6:  MOVFF  FEF,00
17EA:  MOVFF  FEC,01
17EE:  MOVFF  FEC,02
17F2:  MOVFF  FEC,03
17F6:  MOVFF  03,331
17FA:  MOVFF  02,330
17FE:  MOVFF  01,32F
1802:  MOVFF  00,32E
....................  
....................     SwapARPPacket(&packet); 
1806:  MOVLW  03
1808:  MOVWF  x34
180A:  MOVLW  16
180C:  MOVWF  x33
180E:  MOVLB  0
1810:  RCALL  10DA
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
1812:  MOVLW  03
1814:  MOVLB  3
1816:  MOVWF  xAF
1818:  MOVLW  28
181A:  MOVWF  xAE
181C:  MOVLW  06
181E:  MOVWF  xB0
1820:  CLRF   xB2
1822:  MOVLW  1C
1824:  MOVWF  xB1
1826:  MOVLB  0
1828:  RCALL  13C8
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
182A:  MOVLW  03
182C:  MOVLB  3
182E:  MOVWF  xB6
1830:  MOVLW  16
1832:  MOVWF  xB5
1834:  CLRF   xB8
1836:  MOVLW  1C
1838:  MOVWF  xB7
183A:  MOVLB  0
183C:  RCALL  137E
....................  
....................     MACFlush(); 
183E:  RCALL  1496
....................     
....................    return TRUE; 
1840:  MOVLW  01
1842:  MOVWF  01
1844:  MOVLB  3
.................... } 
1846:  MOVLB  0
1848:  GOTO   18C6 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
10DA:  MOVLB  3
10DC:  MOVFF  333,01
10E0:  MOVFF  334,03
10E4:  MOVFF  333,335
10E8:  MOVFF  334,336
10EC:  MOVFF  333,FE9
10F0:  MOVFF  334,FEA
10F4:  MOVFF  FEC,338
10F8:  MOVF   FED,F
10FA:  MOVFF  FEF,337
10FE:  MOVFF  338,3B1
1102:  MOVFF  337,3B0
1106:  MOVLB  0
1108:  RCALL  0F8E
110A:  MOVFF  336,FEA
110E:  MOVFF  335,FE9
1112:  MOVFF  02,FEC
1116:  MOVF   FED,F
1118:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
111C:  MOVLW  02
111E:  MOVLB  3
1120:  ADDWF  x33,W
1122:  MOVWF  01
1124:  MOVLW  00
1126:  ADDWFC x34,W
1128:  MOVWF  03
112A:  MOVFF  01,335
112E:  MOVWF  x36
1130:  MOVLW  02
1132:  ADDWF  x33,W
1134:  MOVWF  FE9
1136:  MOVLW  00
1138:  ADDWFC x34,W
113A:  MOVWF  FEA
113C:  MOVFF  FEC,338
1140:  MOVF   FED,F
1142:  MOVFF  FEF,337
1146:  MOVFF  338,3B1
114A:  MOVFF  337,3B0
114E:  MOVLB  0
1150:  RCALL  0F8E
1152:  MOVFF  336,FEA
1156:  MOVFF  335,FE9
115A:  MOVFF  02,FEC
115E:  MOVF   FED,F
1160:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
1164:  MOVLW  06
1166:  MOVLB  3
1168:  ADDWF  x33,W
116A:  MOVWF  01
116C:  MOVLW  00
116E:  ADDWFC x34,W
1170:  MOVWF  03
1172:  MOVFF  01,335
1176:  MOVWF  x36
1178:  MOVLW  06
117A:  ADDWF  x33,W
117C:  MOVWF  FE9
117E:  MOVLW  00
1180:  ADDWFC x34,W
1182:  MOVWF  FEA
1184:  MOVFF  FEC,338
1188:  MOVF   FED,F
118A:  MOVFF  FEF,337
118E:  MOVFF  338,3B1
1192:  MOVFF  337,3B0
1196:  MOVLB  0
1198:  RCALL  0F8E
119A:  MOVFF  336,FEA
119E:  MOVFF  335,FE9
11A2:  MOVFF  02,FEC
11A6:  MOVF   FED,F
11A8:  MOVFF  01,FEF
.................... } 
11AC:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
45AC:  MOVLB  3
45AE:  CLRF   x27
....................  
....................    ostr = str; 
45B0:  MOVFF  322,324
45B4:  MOVFF  321,323
....................  
....................    while((c=*str) != 0) 
....................    { 
45B8:  MOVFF  322,03
45BC:  MOVFF  321,FE9
45C0:  MOVFF  322,FEA
45C4:  MOVFF  FEF,328
45C8:  MOVF   x28,F
45CA:  BZ    468C
....................       if (c=='+') 
45CC:  MOVF   x28,W
45CE:  SUBLW  2B
45D0:  BNZ   45EA
....................          *str++=' '; 
45D2:  MOVFF  322,03
45D6:  MOVF   x21,W
45D8:  INCF   x21,F
45DA:  BTFSC  FD8.2
45DC:  INCF   x22,F
45DE:  MOVWF  FE9
45E0:  MOVFF  03,FEA
45E4:  MOVLW  20
45E6:  MOVWF  FEF
....................       else if (c=='%') 
45E8:  BRA    4688
45EA:  MOVF   x28,W
45EC:  SUBLW  25
45EE:  BNZ   4682
....................       { 
....................          memcpy(new, str + 1, 2); 
45F0:  MOVLW  01
45F2:  ADDWF  x21,W
45F4:  MOVWF  x2A
45F6:  MOVLW  00
45F8:  ADDWFC x22,W
45FA:  MOVWF  x2B
45FC:  MOVLW  03
45FE:  MOVWF  FEA
4600:  MOVLW  25
4602:  MOVWF  FE9
4604:  MOVFF  32B,FE2
4608:  MOVFF  32A,FE1
460C:  MOVLW  02
460E:  MOVWF  01
4610:  MOVFF  FE6,FEE
4614:  DECFSZ 01,F
4616:  BRA    4610
....................          val = strtoul(new, 0, 16); 
4618:  MOVLW  03
461A:  MOVWF  x2B
461C:  MOVLW  25
461E:  MOVWF  x2A
4620:  CLRF   x2D
4622:  CLRF   x2C
4624:  MOVLW  10
4626:  MOVWF  x2E
4628:  MOVLB  0
462A:  BRA    413C
462C:  MOVFF  01,329
....................          *str++ = val; 
4630:  MOVLB  3
4632:  MOVFF  322,03
4636:  MOVF   x21,W
4638:  INCF   x21,F
463A:  BTFSC  FD8.2
463C:  INCF   x22,F
463E:  MOVWF  FE9
4640:  MOVFF  03,FEA
4644:  MOVFF  329,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
4648:  MOVLW  02
464A:  ADDWF  x21,W
464C:  MOVWF  x2A
464E:  MOVLW  00
4650:  ADDWFC x22,W
4652:  MOVWF  x2B
4654:  MOVFF  322,33F
4658:  MOVFF  321,33E
465C:  MOVLB  0
465E:  RCALL  44A8
4660:  MOVLW  01
4662:  SUBWF  01,W
4664:  MOVLB  3
4666:  MOVWF  x2C
4668:  MOVFF  322,32E
466C:  MOVFF  321,32D
4670:  MOVFF  32B,330
4674:  MOVFF  32A,32F
4678:  MOVWF  x31
467A:  MOVLB  0
467C:  BRA    44E2
....................       } 
....................       else 
467E:  BRA    4688
4680:  MOVLB  3
....................          str++; 
4682:  INCF   x21,F
4684:  BTFSC  FD8.2
4686:  INCF   x22,F
....................    } 
4688:  MOVLB  3
468A:  BRA    45B8
....................  
....................    return(ostr); 
468C:  MOVFF  323,01
4690:  MOVFF  324,02
.................... } 
4694:  MOVLB  0
4696:  RETLW  00
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
4A90:  MOVFF  31B,31D
4A94:  MOVFF  31A,31C
....................    pValue=0; 
4A98:  MOVLB  3
4A9A:  CLRF   x1F
4A9C:  CLRF   x1E
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
4A9E:  MOVFF  31A,FE9
4AA2:  MOVFF  31B,FEA
4AA6:  MOVFF  FEF,320
....................       if ((c=='&') || (c==0)) 
4AAA:  MOVF   x20,W
4AAC:  SUBLW  26
4AAE:  BZ    4AB4
4AB0:  MOVF   x20,F
4AB2:  BNZ   4B10
....................       { 
....................          *ptr=0; 
4AB4:  MOVFF  31A,FE9
4AB8:  MOVFF  31B,FEA
4ABC:  CLRF   FEF
....................          http_escape_chars(pKey); 
4ABE:  MOVFF  31D,322
4AC2:  MOVFF  31C,321
4AC6:  MOVLB  0
4AC8:  RCALL  45AC
....................          http_escape_chars(pValue); 
4ACA:  MOVFF  31F,322
4ACE:  MOVFF  31E,321
4AD2:  RCALL  45AC
....................          http_exec_cgi(file, pKey, pValue); 
4AD4:  MOVFF  319,324
4AD8:  MOVFF  318,323
4ADC:  MOVFF  317,322
4AE0:  MOVFF  316,321
4AE4:  MOVFF  31D,326
4AE8:  MOVFF  31C,325
4AEC:  MOVFF  31F,328
4AF0:  MOVFF  31E,327
4AF4:  BRA    4A0A
....................          pKey=ptr+1; 
4AF6:  MOVLW  01
4AF8:  MOVLB  3
4AFA:  ADDWF  x1A,W
4AFC:  MOVWF  x1C
4AFE:  MOVLW  00
4B00:  ADDWFC x1B,W
4B02:  MOVWF  x1D
....................          pValue=0; 
4B04:  CLRF   x1F
4B06:  CLRF   x1E
....................          if (c==0) 
4B08:  MOVF   x20,F
4B0A:  BNZ   4B0E
....................             break; 
4B0C:  BRA    4B34
....................       } 
....................       else if (c=='=') 
4B0E:  BRA    4B2C
4B10:  MOVF   x20,W
4B12:  SUBLW  3D
4B14:  BNZ   4B2C
....................       { 
....................          *ptr=0; 
4B16:  MOVFF  31A,FE9
4B1A:  MOVFF  31B,FEA
4B1E:  CLRF   FEF
....................          pValue=ptr+1; 
4B20:  MOVLW  01
4B22:  ADDWF  x1A,W
4B24:  MOVWF  x1E
4B26:  MOVLW  00
4B28:  ADDWFC x1B,W
4B2A:  MOVWF  x1F
....................       } 
....................       ptr++; 
4B2C:  INCF   x1A,F
4B2E:  BTFSC  FD8.2
4B30:  INCF   x1B,F
....................    } 
4B32:  BRA    4A9E
.................... } 
4B34:  MOVLB  0
4B36:  RETLW  00
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
4E18:  MOVFF  320,122
.................... } 
4E1C:  GOTO   57EE (RETURN)
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
5134:  MOVFF  122,33F
5138:  MOVFF  33E,340
513C:  BRA    4FEA
513E:  MOVF   01,W
.................... } 
5140:  RETLW  00
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
52FC:  MOVLB  3
52FE:  MOVFF  322,FE9
5302:  MOVFF  323,FEA
5306:  MOVFF  FEC,03
530A:  MOVF   FED,F
530C:  MOVFF  FEF,328
5310:  MOVFF  03,329
....................  
....................    n=strlen(ptr); 
5314:  MOVFF  329,33F
5318:  MOVFF  328,33E
531C:  MOVLB  0
531E:  CALL   44A8
5322:  MOVLB  3
5324:  CLRF   x27
5326:  MOVFF  01,326
....................  
....................    if (!n) 
532A:  MOVF   x26,W
532C:  IORWF  x27,W
532E:  BNZ   5336
....................       return(TCP_PUT_CONST_EC_FINISH); 
5330:  MOVLW  00
5332:  MOVWF  01
5334:  BRA    53BA
....................  
....................    txLeft = tcp_http_tx_left(); 
5336:  MOVFF  122,32E
533A:  MOVLB  0
533C:  RCALL  5200
533E:  MOVFF  02,325
5342:  MOVFF  01,324
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
5346:  MOVLB  3
5348:  MOVF   x24,W
534A:  IORWF  x25,W
534C:  BNZ   5354
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
534E:  MOVLW  01
5350:  MOVWF  01
5352:  BRA    53BA
....................   #endif 
....................  
....................    if (n > txLeft) 
5354:  MOVF   x25,W
5356:  SUBWF  x27,W
5358:  BNC   5368
535A:  BNZ   5362
535C:  MOVF   x26,W
535E:  SUBWF  x24,W
5360:  BC    5368
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
5362:  MOVLW  01
5364:  MOVWF  x2A
....................    } 
....................    else 
5366:  BRA    5372
....................    { 
....................       txLeft = n; 
5368:  MOVFF  327,325
536C:  MOVFF  326,324
....................       ec = TCP_PUT_CONST_EC_FINISH; 
5370:  CLRF   x2A
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
....................    { 
5372:  MOVFF  325,03
5376:  MOVF   x24,W
5378:  BTFSC  FD8.2
537A:  DECF   x25,F
537C:  DECF   x24,F
537E:  IORWF  03,W
5380:  BZ    53A4
....................       tcp_http_putc(*ptr++); 
5382:  MOVFF  329,03
5386:  MOVF   x28,W
5388:  INCF   x28,F
538A:  BTFSC  FD8.2
538C:  INCF   x29,F
538E:  MOVWF  FE9
5390:  MOVFF  03,FEA
5394:  MOVFF  FEF,32B
5398:  MOVFF  32B,33E
539C:  MOVLB  0
539E:  RCALL  5134
....................    } 
53A0:  MOVLB  3
53A2:  BRA    5372
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
53A4:  MOVFF  322,FE9
53A8:  MOVFF  323,FEA
53AC:  MOVFF  329,FEC
53B0:  MOVF   FED,F
53B2:  MOVFF  328,FEF
....................  
....................    return(ec); 
53B6:  MOVFF  32A,01
.................... } 
53BA:  MOVLB  0
53BC:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
.................... { 
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
*
53DC:  MOVLB  3
53DE:  CLRF   x35
53E0:  CLRF   x36
....................    int32 addy; 
....................    int1 premature = TRUE; 
53E2:  BSF    x3D.0
....................  
....................    max = *n; 
53E4:  MOVFF  330,FE9
53E8:  MOVFF  331,FEA
53EC:  MOVFF  FEC,03
53F0:  MOVF   FED,F
53F2:  MOVFF  FEF,337
53F6:  MOVFF  03,338
....................    addy = *retAddy; 
53FA:  MOVFF  32E,FE9
53FE:  MOVFF  32F,FEA
5402:  MOVFF  FEF,00
5406:  MOVFF  FEC,01
540A:  MOVFF  FEC,02
540E:  MOVFF  FEC,03
5412:  MOVFF  03,33C
5416:  MOVFF  02,33B
541A:  MOVFF  01,33A
541E:  MOVFF  00,339
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
5422:  MOVFF  33C,03
5426:  MOVFF  33B,02
542A:  MOVFF  33A,01
542E:  MOVFF  339,00
5432:  MOVLW  01
5434:  ADDWF  x39,F
5436:  BTFSC  FD8.0
5438:  INCF   x3A,F
543A:  BTFSC  FD8.2
543C:  INCF   x3B,F
543E:  BTFSC  FD8.2
5440:  INCF   x3C,F
5442:  MOVFF  03,341
5446:  MOVFF  02,340
544A:  MOVFF  01,33F
544E:  MOVFF  00,33E
5452:  MOVFF  02,FF8
5456:  MOVFF  01,FF7
545A:  MOVFF  00,FF6
545E:  MOVLW  03
5460:  MOVWF  FEA
5462:  MOVLW  33
5464:  MOVWF  FE9
5466:  CLRF   x43
5468:  MOVLW  01
546A:  MOVWF  x42
546C:  MOVLB  0
546E:  RCALL  53BE
....................       if (stopC == '%') 
5470:  MOVLB  3
5472:  MOVF   x33,W
5474:  SUBLW  25
5476:  BNZ   54FA
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
5478:  MOVFF  33C,03
547C:  MOVFF  33B,02
5480:  MOVFF  33A,01
5484:  MOVFF  339,00
5488:  MOVLW  01
548A:  ADDWF  x39,F
548C:  BTFSC  FD8.0
548E:  INCF   x3A,F
5490:  BTFSC  FD8.2
5492:  INCF   x3B,F
5494:  BTFSC  FD8.2
5496:  INCF   x3C,F
5498:  MOVFF  03,341
549C:  MOVFF  02,340
54A0:  MOVFF  01,33F
54A4:  MOVFF  00,33E
54A8:  MOVFF  02,FF8
54AC:  MOVFF  01,FF7
54B0:  MOVFF  00,FF6
54B4:  MOVLW  03
54B6:  MOVWF  FEA
54B8:  MOVLW  34
54BA:  MOVWF  FE9
54BC:  CLRF   x43
54BE:  MOVLW  01
54C0:  MOVWF  x42
54C2:  MOVLB  0
54C4:  RCALL  53BE
....................          if (checkC == '%') 
54C6:  MOVLB  3
54C8:  MOVF   x34,W
54CA:  SUBLW  25
54CC:  BNZ   54F6
....................          { 
....................             if (fileSize < max) 
54CE:  MOVF   x36,W
54D0:  SUBWF  x38,W
54D2:  BNC   54F2
54D4:  BNZ   54DC
54D6:  MOVF   x37,W
54D8:  SUBWF  x35,W
54DA:  BC    54F2
....................             { 
....................                if (doSend) 
54DC:  MOVF   x32,F
54DE:  BZ    54EA
....................                   tcp_http_putc('%'); 
54E0:  MOVLW  25
54E2:  MOVWF  x3E
54E4:  MOVLB  0
54E6:  RCALL  5134
54E8:  MOVLB  3
....................                fileSize++; 
54EA:  INCF   x35,F
54EC:  BTFSC  FD8.2
54EE:  INCF   x36,F
....................             } 
....................             else 
54F0:  BRA    54F4
....................                break; 
54F2:  BRA    552C
....................          } 
....................          else 
54F4:  BRA    54F8
....................             break;   //ESCAPE 
54F6:  BRA    552C
....................       } 
....................       else if (stopC) 
54F8:  BRA    552A
54FA:  MOVF   x33,F
54FC:  BZ    5526
....................       { 
....................          if (fileSize < max) 
54FE:  MOVF   x36,W
5500:  SUBWF  x38,W
5502:  BNC   5522
5504:  BNZ   550C
5506:  MOVF   x37,W
5508:  SUBWF  x35,W
550A:  BC    5522
....................          { 
....................             if (doSend) 
550C:  MOVF   x32,F
550E:  BZ    551A
....................                tcp_http_putc(stopC); 
5510:  MOVFF  333,33E
5514:  MOVLB  0
5516:  RCALL  5134
5518:  MOVLB  3
....................             fileSize++; 
551A:  INCF   x35,F
551C:  BTFSC  FD8.2
551E:  INCF   x36,F
....................          } 
....................          else 
5520:  BRA    5524
....................             break; 
5522:  BRA    552C
....................       } 
....................       else 
5524:  BRA    552A
....................       { 
....................          premature = FALSE; 
5526:  BCF    x3D.0
....................          break;   //EOF (stopC == 0) 
5528:  BRA    552C
....................       } 
....................    } 
552A:  BRA    5422
....................  
....................    if (premature) 
552C:  BTFSS  x3D.0
552E:  BRA    5540
....................       addy--; 
5530:  MOVLW  FF
5532:  ADDWF  x39,F
5534:  BTFSS  FD8.0
5536:  ADDWF  x3A,F
5538:  BTFSS  FD8.0
553A:  ADDWF  x3B,F
553C:  BTFSS  FD8.0
553E:  ADDWF  x3C,F
....................  
....................    *n = fileSize; 
5540:  MOVFF  330,FE9
5544:  MOVFF  331,FEA
5548:  MOVFF  336,FEC
554C:  MOVF   FED,F
554E:  MOVFF  335,FEF
....................    *retAddy = addy; 
5552:  MOVFF  32E,FE9
5556:  MOVFF  32F,FEA
555A:  MOVFF  339,FEF
555E:  MOVFF  33A,FEC
5562:  MOVFF  33B,FEC
5566:  MOVFF  33C,FEC
....................  
....................    return(stopC); 
556A:  MOVFF  333,01
.................... } 
556E:  MOVLB  0
5570:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
.................... { 
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
5572:  MOVLB  3
5574:  CLRF   x29
5576:  CLRF   x2A
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
5578:  MOVFF  122,32E
557C:  MOVLB  0
557E:  RCALL  5200
5580:  MOVFF  02,32C
5584:  MOVFF  01,32B
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
5588:  MOVLB  3
558A:  MOVF   x2B,W
558C:  IORWF  x2C,W
558E:  BNZ   5596
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
5590:  MOVLW  01
5592:  MOVWF  01
5594:  BRA    5644
....................  #endif 
....................  
....................    addy = *retAddy; 
5596:  MOVFF  322,FE9
559A:  MOVFF  323,FEA
559E:  MOVFF  FEF,00
55A2:  MOVFF  FEC,01
55A6:  MOVFF  FEC,02
55AA:  MOVFF  FEC,03
55AE:  MOVFF  03,328
55B2:  MOVFF  02,327
55B6:  MOVFF  01,326
55BA:  MOVFF  00,325
....................  
....................    fileSize = 0xFFFF; 
55BE:  MOVLW  FF
55C0:  MOVWF  x2A
55C2:  MOVWF  x29
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
55C4:  MOVLW  03
55C6:  MOVWF  x2F
55C8:  MOVLW  25
55CA:  MOVWF  x2E
55CC:  MOVLW  03
55CE:  MOVWF  x31
55D0:  MOVLW  29
55D2:  MOVWF  x30
55D4:  CLRF   x32
55D6:  MOVLB  0
55D8:  RCALL  53DC
55DA:  MOVFF  01,324
....................  
....................    if (!fileSize && (stopC!='%')) 
55DE:  MOVLB  3
55E0:  MOVF   x29,W
55E2:  IORWF  x2A,W
55E4:  BNZ   55F2
55E6:  MOVF   x24,W
55E8:  SUBLW  25
55EA:  BZ    55F2
....................       return(TCP_PUT_CONST_EC_FINISH); 
55EC:  MOVLW  00
55EE:  MOVWF  01
55F0:  BRA    5644
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
55F2:  MOVF   x2C,W
55F4:  SUBWF  x2A,W
55F6:  BNC   560E
55F8:  BNZ   5600
55FA:  MOVF   x29,W
55FC:  SUBWF  x2B,W
55FE:  BC    560E
....................    { 
....................       fileSize = txLeft; 
5600:  MOVFF  32C,32A
5604:  MOVFF  32B,329
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
5608:  MOVLW  01
560A:  MOVWF  x2D
....................    } 
....................    else 
560C:  BRA    5626
....................    { 
....................       if (stopC == '%') 
560E:  MOVF   x24,W
5610:  SUBLW  25
5612:  BNZ   561A
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
5614:  MOVLW  02
5616:  MOVWF  x2D
....................       else if (stopC) 
5618:  BRA    5626
561A:  MOVF   x24,F
561C:  BZ    5624
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
561E:  MOVLW  01
5620:  MOVWF  x2D
....................       else 
5622:  BRA    5626
....................          ec = TCP_PUT_CONST_EC_FINISH; 
5624:  CLRF   x2D
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
5626:  MOVFF  323,32F
562A:  MOVFF  322,32E
562E:  MOVLW  03
5630:  MOVWF  x31
5632:  MOVLW  29
5634:  MOVWF  x30
5636:  MOVLW  01
5638:  MOVWF  x32
563A:  MOVLB  0
563C:  RCALL  53DC
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
563E:  MOVLB  3
5640:  MOVFF  32D,01
.................... } 
5644:  MOVLB  0
5646:  GOTO   5A4A (RETURN)
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
564A:  MOVFF  326,FF8
564E:  MOVFF  325,FF7
5652:  MOVFF  324,FF6
5656:  MOVLW  03
5658:  MOVWF  FEA
565A:  MOVLW  28
565C:  MOVWF  FE9
565E:  MOVLB  3
5660:  CLRF   x43
5662:  MOVLW  01
5664:  MOVWF  x42
5666:  MOVLB  0
5668:  RCALL  53BE
.................... #endif 
....................  
....................    return(ret); 
566A:  MOVLB  3
566C:  MOVFF  328,01
.................... } 
5670:  MOVLB  0
5672:  GOTO   5A8E (RETURN)
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
57D0:  CLRF   03
57D2:  MOVLB  3
57D4:  MOVF   x14,W
57D6:  ADDLW  1F
57D8:  MOVWF  FE9
57DA:  MOVLW  01
57DC:  ADDWFC 03,W
57DE:  MOVWF  FEA
57E0:  MOVFF  FEF,31D
....................  
....................    set_tcp_http_putc(socket); 
57E4:  MOVFF  31D,320
57E8:  MOVLB  0
57EA:  GOTO   4E18
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
57EE:  MOVLB  3
57F0:  MOVF   x14,W
57F2:  MULLW  04
57F4:  MOVF   FF3,W
57F6:  CLRF   03
57F8:  ADDLW  23
57FA:  MOVWF  FE9
57FC:  MOVLW  01
57FE:  ADDWFC 03,W
5800:  MOVWF  FEA
5802:  MOVFF  FEF,320
5806:  MOVFF  FEC,321
580A:  MOVFF  FEC,322
580E:  MOVFF  FEC,323
5812:  MOVF   x20,F
5814:  BTFSS  FD8.2
5816:  BRA    59D8
5818:  MOVF   x21,F
581A:  BTFSS  FD8.2
581C:  BRA    59D8
581E:  MOVF   x22,F
5820:  BTFSS  FD8.2
5822:  BRA    59D8
5824:  MOVF   x23,F
5826:  BTFSS  FD8.2
5828:  BRA    59D8
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
582A:  BCF    FD8.0
582C:  RLCF   x14,W
582E:  CLRF   03
5830:  ADDLW  27
5832:  MOVWF  FE9
5834:  MOVLW  01
5836:  ADDWFC 03,W
5838:  MOVWF  FEA
583A:  CLRF   FEC
583C:  MOVF   FED,F
583E:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
5840:  MOVF   x14,W
5842:  MULLW  04
5844:  MOVF   FF3,W
5846:  CLRF   03
5848:  ADDLW  23
584A:  MOVWF  FE9
584C:  MOVLW  01
584E:  ADDWFC 03,W
5850:  MOVWF  FEA
5852:  MOVFF  317,FEF
5856:  MOVFF  318,FEC
585A:  MOVFF  319,FEC
585E:  MOVFF  31A,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
5862:  MOVLW  01
5864:  MOVLB  1
5866:  MOVWF  x51
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
5868:  MOVLB  3
586A:  CLRF   x20
586C:  MOVF   x20,W
586E:  MOVLB  0
5870:  CALL   009E
5874:  MOVLB  3
5876:  INCF   x20,F
5878:  MOVWF  00
587A:  MOVWF  x3E
587C:  MOVLB  0
587E:  RCALL  5134
5880:  MOVLW  09
5882:  MOVLB  3
5884:  SUBWF  x20,W
5886:  BNZ   586C
5888:  MOVLW  10
588A:  MOVWF  FE9
588C:  MOVFF  316,321
5890:  MOVFF  315,320
5894:  MOVLB  0
5896:  BRA    5142
5898:  MOVLW  20
589A:  MOVLB  3
589C:  MOVWF  x3E
589E:  MOVLB  0
58A0:  RCALL  5134
....................     #endif 
....................  
....................       switch(errorCode) 
....................       { 
58A2:  MOVLB  3
58A4:  MOVFF  315,00
58A8:  MOVF   x16,W
58AA:  MOVWF  03
58AC:  BNZ   58B8
58AE:  MOVLW  C8
58B0:  SUBWF  00,W
58B2:  MOVLB  0
58B4:  BZ    58DA
58B6:  MOVLB  3
58B8:  MOVLW  01
58BA:  SUBWF  03,W
58BC:  BNZ   58C8
58BE:  MOVLW  94
58C0:  SUBWF  00,W
58C2:  MOVLB  0
58C4:  BZ    58F0
58C6:  MOVLB  3
58C8:  MOVLW  01
58CA:  SUBWF  03,W
58CC:  BNZ   58D8
58CE:  MOVLW  F4
58D0:  SUBWF  00,W
58D2:  MOVLB  0
58D4:  BZ    5914
58D6:  MOVLB  3
58D8:  BRA    5938
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
58DA:  MOVLW  4F
58DC:  MOVLB  3
58DE:  MOVWF  x3E
58E0:  MOVLB  0
58E2:  RCALL  5134
58E4:  MOVLW  4B
58E6:  MOVLB  3
58E8:  MOVWF  x3E
58EA:  MOVLB  0
58EC:  RCALL  5134
....................             break; 
58EE:  BRA    593C
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
58F0:  MOVLB  3
58F2:  CLRF   x20
58F4:  MOVF   x20,W
58F6:  MOVLB  0
58F8:  CALL   00C6
58FC:  MOVLB  3
58FE:  INCF   x20,F
5900:  MOVWF  00
5902:  MOVWF  x3E
5904:  MOVLB  0
5906:  RCALL  5134
5908:  MOVLW  09
590A:  MOVLB  3
590C:  SUBWF  x20,W
590E:  BNZ   58F4
....................             break; 
5910:  MOVLB  0
5912:  BRA    593C
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
5914:  MOVLB  3
5916:  CLRF   x20
5918:  MOVF   x20,W
591A:  MOVLB  0
591C:  CALL   00EA
5920:  MOVLB  3
5922:  INCF   x20,F
5924:  MOVWF  00
5926:  MOVWF  x3E
5928:  MOVLB  0
592A:  RCALL  5134
592C:  MOVLW  0C
592E:  MOVLB  3
5930:  SUBWF  x20,W
5932:  BNZ   5918
....................             break; 
5934:  MOVLB  0
5936:  BRA    593C
....................          default: 
....................             break; 
5938:  MOVLB  0
593A:  BRA    593C
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
593C:  MOVLB  3
593E:  CLRF   x20
5940:  MOVF   x20,W
5942:  MOVLB  0
5944:  CALL   0112
5948:  MOVLB  3
594A:  INCF   x20,F
594C:  MOVWF  00
594E:  MOVWF  x3E
5950:  MOVLB  0
5952:  CALL   5134
5956:  MOVLW  10
5958:  MOVLB  3
595A:  SUBWF  x20,W
595C:  BNZ   5940
....................       if (contentType) 
595E:  MOVF   x1B,W
5960:  IORWF  x1C,W
5962:  BZ    5998
....................          printf(tcp_http_putc, "%s", contentType); 
5964:  MOVFF  31C,FEA
5968:  MOVFF  31B,FE9
596C:  MOVLW  00
596E:  IORWF  FEF,W
5970:  BZ    5996
5972:  MOVFF  FEA,321
5976:  MOVFF  FE9,320
597A:  MOVFF  FEF,33E
597E:  MOVLB  0
5980:  CALL   5134
5984:  MOVFF  321,FEA
5988:  MOVFF  320,FE9
598C:  INCF   FE9,F
598E:  BTFSC  FD8.2
5990:  INCF   FEA,F
5992:  MOVLB  3
5994:  BRA    596C
....................       else 
5996:  BRA    59B8
....................          printf(tcp_http_putc,"text/html"); 
5998:  CLRF   x20
599A:  MOVF   x20,W
599C:  MOVLB  0
599E:  CALL   013E
59A2:  MOVLB  3
59A4:  INCF   x20,F
59A6:  MOVWF  00
59A8:  MOVWF  x3E
59AA:  MOVLB  0
59AC:  CALL   5134
59B0:  MOVLW  09
59B2:  MOVLB  3
59B4:  SUBWF  x20,W
59B6:  BNZ   599A
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
59B8:  CLRF   x20
59BA:  MOVF   x20,W
59BC:  MOVLB  0
59BE:  CALL   0162
59C2:  MOVLB  3
59C4:  INCF   x20,F
59C6:  MOVWF  00
59C8:  MOVWF  x3E
59CA:  MOVLB  0
59CC:  CALL   5134
59D0:  MOVLW  04
59D2:  MOVLB  3
59D4:  SUBWF  x20,W
59D6:  BNZ   59BA
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
59D8:  BCF    FD8.0
59DA:  RLCF   x14,W
59DC:  CLRF   03
59DE:  ADDLW  27
59E0:  MOVWF  FE9
59E2:  MOVLW  01
59E4:  ADDWFC 03,W
59E6:  MOVWF  FEA
59E8:  MOVF   FEF,F
59EA:  BZ    5A1E
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
59EC:  BCF    FD8.0
59EE:  RLCF   x14,W
59F0:  CLRF   03
59F2:  ADDLW  27
59F4:  MOVWF  x20
59F6:  MOVLW  01
59F8:  ADDWFC 03,W
59FA:  MOVWF  x21
59FC:  MOVWF  x23
59FE:  MOVFF  320,322
5A02:  MOVLB  0
5A04:  RCALL  52FC
....................       lastHTTPPutVarPos[which] = 0; 
5A06:  BCF    FD8.0
5A08:  MOVLB  3
5A0A:  RLCF   x14,W
5A0C:  CLRF   03
5A0E:  ADDLW  27
5A10:  MOVWF  FE9
5A12:  MOVLW  01
5A14:  ADDWFC 03,W
5A16:  MOVWF  FEA
5A18:  CLRF   FEC
5A1A:  MOVF   FED,F
5A1C:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
5A1E:  MOVLB  1
5A20:  DECFSZ x51,W
5A22:  BRA    5B64
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
5A24:  MOVLB  3
5A26:  MOVF   x14,W
5A28:  MULLW  04
5A2A:  MOVF   FF3,W
5A2C:  CLRF   03
5A2E:  ADDLW  23
5A30:  MOVWF  01
5A32:  MOVLW  01
5A34:  ADDWFC 03,F
5A36:  MOVFF  01,320
5A3A:  MOVFF  03,321
5A3E:  MOVFF  03,323
5A42:  MOVFF  01,322
5A46:  MOVLB  0
5A48:  BRA    5572
5A4A:  MOVFF  01,31E
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
5A4E:  MOVLB  3
5A50:  MOVF   x1E,W
5A52:  SUBLW  02
5A54:  BTFSS  FD8.2
5A56:  BRA    5B52
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
5A58:  MOVF   x14,W
5A5A:  MULLW  04
5A5C:  MOVF   FF3,W
5A5E:  CLRF   03
5A60:  ADDLW  23
5A62:  MOVWF  FE9
5A64:  MOVLW  01
5A66:  ADDWFC 03,W
5A68:  MOVWF  FEA
5A6A:  MOVFF  FEF,320
5A6E:  MOVFF  FEC,321
5A72:  MOVFF  FEC,322
5A76:  MOVFF  FEC,323
5A7A:  MOVFF  323,327
5A7E:  MOVFF  322,326
5A82:  MOVFF  321,325
5A86:  MOVFF  320,324
5A8A:  MOVLB  0
5A8C:  BRA    564A
5A8E:  MOVFF  01,31F
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
5A92:  MOVLB  3
5A94:  MOVF   x14,W
5A96:  MULLW  04
5A98:  MOVF   FF3,W
5A9A:  CLRF   03
5A9C:  ADDLW  23
5A9E:  MOVWF  FE9
5AA0:  MOVLW  01
5AA2:  ADDWFC 03,W
5AA4:  MOVWF  FEA
5AA6:  MOVLW  01
5AA8:  ADDWF  FEF,W
5AAA:  MOVWF  00
5AAC:  MOVLW  00
5AAE:  ADDWFC FEC,W
5AB0:  MOVWF  01
5AB2:  MOVLW  00
5AB4:  ADDWFC FEC,W
5AB6:  MOVWF  02
5AB8:  MOVLW  00
5ABA:  ADDWFC FEC,W
5ABC:  MOVF   FED,F
5ABE:  MOVF   FED,F
5AC0:  MOVF   FED,F
5AC2:  MOVFF  00,FEF
5AC6:  MOVFF  01,FEC
5ACA:  MOVFF  02,FEC
5ACE:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
5AD0:  MOVFF  31A,323
5AD4:  MOVFF  319,322
5AD8:  MOVFF  318,321
5ADC:  MOVFF  317,320
5AE0:  MOVFF  31F,324
5AE4:  MOVLW  01
5AE6:  MOVWF  x26
5AE8:  MOVLW  29
5AEA:  MOVWF  x25
5AEC:  MOVLW  27
5AEE:  MOVWF  x27
5AF0:  MOVLB  0
5AF2:  BRA    5706
....................             lastHTTPPutVarPos[which] = &str[0]; 
5AF4:  BCF    FD8.0
5AF6:  MOVLB  3
5AF8:  RLCF   x14,W
5AFA:  CLRF   03
5AFC:  ADDLW  27
5AFE:  MOVWF  FE9
5B00:  MOVLW  01
5B02:  ADDWFC 03,W
5B04:  MOVWF  FEA
5B06:  MOVLW  01
5B08:  MOVWF  FEC
5B0A:  MOVF   FED,F
5B0C:  MOVLW  29
5B0E:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
5B10:  BCF    FD8.0
5B12:  RLCF   x14,W
5B14:  CLRF   03
5B16:  ADDLW  27
5B18:  MOVWF  x20
5B1A:  MOVLW  01
5B1C:  ADDWFC 03,W
5B1E:  MOVWF  x21
5B20:  MOVWF  x23
5B22:  MOVFF  320,322
5B26:  MOVLB  0
5B28:  CALL   52FC
5B2C:  MOVFF  01,31E
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
5B30:  MOVLB  3
5B32:  MOVF   x1E,F
5B34:  BNZ   5B4E
....................                lastHTTPPutVarPos[which] = 0; 
5B36:  BCF    FD8.0
5B38:  RLCF   x14,W
5B3A:  CLRF   03
5B3C:  ADDLW  27
5B3E:  MOVWF  FE9
5B40:  MOVLW  01
5B42:  ADDWFC 03,W
5B44:  MOVWF  FEA
5B46:  CLRF   FEC
5B48:  MOVF   FED,F
5B4A:  CLRF   FEF
....................             else 
5B4C:  BRA    5B50
....................                break; 
5B4E:  BRA    5B62
....................          } 
....................          else 
5B50:  BRA    5B60
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
5B52:  MOVF   x1E,F
5B54:  BNZ   5B5E
....................                status = HTTP_PUT_FILE_CHUNK_END; 
5B56:  MOVLW  02
5B58:  MOVLB  1
5B5A:  MOVWF  x51
5B5C:  MOVLB  3
....................             break; 
5B5E:  BRA    5B62
....................          } 
....................       } while (TRUE); 
....................    } 
5B60:  BRA    5A26
5B62:  MOVLB  1
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
5B64:  MOVF   x51,W
5B66:  SUBLW  02
5B68:  BNZ   5B6E
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
5B6A:  MOVLW  03
5B6C:  MOVWF  x51
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
5B6E:  MOVFF  31D,345
5B72:  MOVLB  0
5B74:  CALL   4E20
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
5B78:  MOVLB  1
5B7A:  MOVF   x51,W
5B7C:  SUBLW  03
5B7E:  BZ    5B84
5B80:  MOVLW  00
5B82:  BRA    5B86
5B84:  MOVLW  01
5B86:  MOVWF  01
.................... } 
5B88:  MOVLB  0
5B8A:  RETLW  00
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
0E42:  MOVLB  3
0E44:  CLRF   x02
0E46:  MOVF   x02,F
0E48:  BNZ   0EA6
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
0E4A:  CLRF   03
0E4C:  MOVF   x02,W
0E4E:  ADDLW  1F
0E50:  MOVWF  01
0E52:  MOVLW  01
0E54:  ADDWFC 03,F
0E56:  MOVFF  01,303
0E5A:  MOVFF  03,304
0E5E:  CLRF   x06
0E60:  MOVLW  50
0E62:  MOVWF  x05
0E64:  MOVLB  0
0E66:  BRA    0D46
0E68:  MOVFF  304,FEA
0E6C:  MOVFF  303,FE9
0E70:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
0E74:  CLRF   03
0E76:  MOVLB  3
0E78:  MOVF   x02,W
0E7A:  ADDLW  1F
0E7C:  MOVWF  FE9
0E7E:  MOVLW  01
0E80:  ADDWFC 03,W
0E82:  MOVWF  FEA
0E84:  MOVF   FEF,W
0E86:  SUBLW  FE
0E88:  BZ    0EA2
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
0E8A:  BCF    FD8.0
0E8C:  RLCF   x02,W
0E8E:  CLRF   03
0E90:  ADDLW  20
0E92:  MOVWF  FE9
0E94:  MOVLW  01
0E96:  ADDWFC 03,W
0E98:  MOVWF  FEA
0E9A:  MOVLW  01
0E9C:  MOVWF  FEC
0E9E:  MOVF   FED,F
0EA0:  MOVWF  FEF
....................          } 
....................       } 
0EA2:  INCF   x02,F
0EA4:  BRA    0E46
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
.................... } 
0EA6:  MOVLB  0
0EA8:  GOTO   0EBE (RETURN)
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
5CCA:  MOVLB  3
5CCC:  CLRF   x0E
5CCE:  MOVF   x0E,F
5CD0:  BTFSS  FD8.2
5CD2:  GOTO   691E
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
5CD6:  BCF    FD8.0
5CD8:  RLCF   x0E,W
5CDA:  CLRF   03
5CDC:  ADDLW  20
5CDE:  MOVWF  FE9
5CE0:  MOVLW  01
5CE2:  ADDWFC 03,W
5CE4:  MOVWF  FEA
5CE6:  MOVFF  FEC,311
5CEA:  MOVF   FED,F
5CEC:  MOVFF  FEF,310
5CF0:  INCFSZ x10,W
5CF2:  BRA    5CFC
5CF4:  MOVF   x11,F
5CF6:  BNZ   5CFC
....................          return; 
5CF8:  GOTO   691E
....................  
....................       currSocket=http_socket[hs]; 
5CFC:  CLRF   03
5CFE:  MOVF   x0E,W
5D00:  ADDLW  1F
5D02:  MOVWF  FE9
5D04:  MOVLW  01
5D06:  ADDWFC 03,W
5D08:  MOVWF  FEA
5D0A:  MOVFF  FEF,30F
....................  
....................       if (!TCPIsConnected(currSocket)) 
5D0E:  MOVFF  30F,310
5D12:  MOVLB  0
5D14:  CALL   3D7A
5D18:  MOVF   01,F
5D1A:  BNZ   5D38
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
5D1C:  BCF    FD8.0
5D1E:  MOVLB  3
5D20:  RLCF   x0E,W
5D22:  CLRF   03
5D24:  ADDLW  20
5D26:  MOVWF  FE9
5D28:  MOVLW  01
5D2A:  ADDWFC 03,W
5D2C:  MOVWF  FEA
5D2E:  MOVLW  01
5D30:  MOVWF  FEC
5D32:  MOVF   FED,F
5D34:  MOVWF  FEF
5D36:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
....................       { 
5D38:  BCF    FD8.0
5D3A:  MOVLB  3
5D3C:  RLCF   x0E,W
5D3E:  CLRF   03
5D40:  ADDLW  20
5D42:  MOVWF  FE9
5D44:  MOVLW  01
5D46:  ADDWFC 03,W
5D48:  MOVWF  FEA
5D4A:  MOVFF  FEF,00
5D4E:  INCF   FE9,F
5D50:  MOVF   FEF,W
5D52:  DECF   FE9,F
5D54:  MOVWF  03
5D56:  MOVLW  01
5D58:  SUBWF  03,W
5D5A:  BNZ   5D66
5D5C:  MOVLW  01
5D5E:  SUBWF  00,W
5D60:  MOVLB  0
5D62:  BZ    5E14
5D64:  MOVLB  3
5D66:  MOVLW  01
5D68:  SUBWF  03,W
5D6A:  BNZ   5D76
5D6C:  MOVLW  02
5D6E:  SUBWF  00,W
5D70:  MOVLB  0
5D72:  BZ    5E24
5D74:  MOVLB  3
5D76:  MOVLW  01
5D78:  SUBWF  03,W
5D7A:  BNZ   5D88
5D7C:  MOVLW  03
5D7E:  SUBWF  00,W
5D80:  MOVLB  0
5D82:  BTFSC  FD8.2
5D84:  BRA    5ED4
5D86:  MOVLB  3
5D88:  MOVLW  01
5D8A:  SUBWF  03,W
5D8C:  BNZ   5D9A
5D8E:  MOVLW  04
5D90:  SUBWF  00,W
5D92:  MOVLB  0
5D94:  BTFSC  FD8.2
5D96:  BRA    632A
5D98:  MOVLB  3
5D9A:  MOVLW  01
5D9C:  SUBWF  03,W
5D9E:  BNZ   5DAC
5DA0:  MOVLW  05
5DA2:  SUBWF  00,W
5DA4:  MOVLB  0
5DA6:  BTFSC  FD8.2
5DA8:  BRA    6388
5DAA:  MOVLB  3
5DAC:  MOVLW  01
5DAE:  SUBWF  03,W
5DB0:  BNZ   5DC0
5DB2:  MOVLW  06
5DB4:  SUBWF  00,W
5DB6:  MOVLB  0
5DB8:  BTFSC  FD8.2
5DBA:  GOTO   6640
5DBE:  MOVLB  3
5DC0:  MOVLW  01
5DC2:  SUBWF  03,W
5DC4:  BNZ   5DD4
5DC6:  MOVLW  07
5DC8:  SUBWF  00,W
5DCA:  MOVLB  0
5DCC:  BTFSC  FD8.2
5DCE:  GOTO   6682
5DD2:  MOVLB  3
5DD4:  MOVLW  01
5DD6:  SUBWF  03,W
5DD8:  BNZ   5DE8
5DDA:  MOVLW  08
5DDC:  SUBWF  00,W
5DDE:  MOVLB  0
5DE0:  BTFSC  FD8.2
5DE2:  GOTO   67CE
5DE6:  MOVLB  3
5DE8:  MOVLW  01
5DEA:  SUBWF  03,W
5DEC:  BNZ   5DFC
5DEE:  MOVLW  09
5DF0:  SUBWF  00,W
5DF2:  MOVLB  0
5DF4:  BTFSC  FD8.2
5DF6:  GOTO   6818
5DFA:  MOVLB  3
5DFC:  MOVLW  01
5DFE:  SUBWF  03,W
5E00:  BNZ   5E10
5E02:  MOVLW  0A
5E04:  SUBWF  00,W
5E06:  MOVLB  0
5E08:  BTFSC  FD8.2
5E0A:  GOTO   6912
5E0E:  MOVLB  3
5E10:  GOTO   6912
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
5E14:  MOVFF  30F,310
5E18:  CALL   3D7A
5E1C:  MOVF   01,F
5E1E:  BNZ   5E24
....................                break; 
5E20:  GOTO   6916
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
5E24:  MOVLB  3
5E26:  MOVF   x0E,W
5E28:  MULLW  FE
5E2A:  MOVF   FF3,W
5E2C:  CLRF   x11
5E2E:  MOVWF  x10
5E30:  MOVLW  6F
5E32:  ADDWF  x10,W
5E34:  MOVWF  FE9
5E36:  MOVLW  01
5E38:  ADDWFC x11,W
5E3A:  MOVWF  FEA
5E3C:  CLRF   FEF
....................             i[hs]=0; 
5E3E:  CLRF   03
5E40:  MOVF   x0E,W
5E42:  ADDLW  6D
5E44:  MOVWF  FE9
5E46:  MOVLW  02
5E48:  ADDWFC 03,W
5E4A:  MOVWF  FEA
5E4C:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
5E4E:  BCF    FD8.0
5E50:  RLCF   x0E,W
5E52:  CLRF   03
5E54:  ADDLW  20
5E56:  MOVWF  FE9
5E58:  MOVLW  01
5E5A:  ADDWFC 03,W
5E5C:  MOVWF  FEA
5E5E:  MOVLW  01
5E60:  MOVWF  FEC
5E62:  MOVF   FED,F
5E64:  MOVLW  03
5E66:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
5E68:  BCF    FD8.0
5E6A:  RLCF   x0E,W
5E6C:  CLRF   03
5E6E:  ADDLW  75
5E70:  MOVWF  01
5E72:  MOVLW  02
5E74:  ADDWFC 03,F
5E76:  MOVFF  01,310
5E7A:  MOVFF  03,311
5E7E:  MOVLB  0
5E80:  CALL   22D0
5E84:  MOVFF  311,FEA
5E88:  MOVFF  310,FE9
5E8C:  MOVFF  02,FEC
5E90:  MOVF   FED,F
5E92:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
5E96:  MOVLB  3
5E98:  MOVF   x0E,W
5E9A:  MULLW  04
5E9C:  MOVF   FF3,W
5E9E:  CLRF   03
5EA0:  ADDLW  6F
5EA2:  MOVWF  FE9
5EA4:  MOVLW  02
5EA6:  ADDWFC 03,W
5EA8:  MOVWF  FEA
5EAA:  MOVF   FEE,F
5EAC:  MOVF   FEE,F
5EAE:  CLRF   FEC
5EB0:  MOVF   FED,F
5EB2:  CLRF   FEF
5EB4:  MOVF   FED,F
5EB6:  CLRF   FEF
5EB8:  MOVF   FED,F
5EBA:  CLRF   FEF
....................             http_post_len[hs]=0; 
5EBC:  BCF    FD8.0
5EBE:  RLCF   x0E,W
5EC0:  CLRF   03
5EC2:  ADDLW  73
5EC4:  MOVWF  FE9
5EC6:  MOVLW  02
5EC8:  ADDWFC 03,W
5ECA:  MOVWF  FEA
5ECC:  CLRF   FEC
5ECE:  MOVF   FED,F
5ED0:  CLRF   FEF
5ED2:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
5ED4:  MOVLB  3
5ED6:  BCF    x08.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
....................             { 
5ED8:  MOVFF  30F,310
5EDC:  MOVLB  0
5EDE:  CALL   3DA4
5EE2:  MOVF   01,F
5EE4:  BTFSC  FD8.2
5EE6:  BRA    622E
5EE8:  MOVFF  30F,310
5EEC:  MOVLW  03
5EEE:  MOVLB  3
5EF0:  MOVWF  x12
5EF2:  MOVLW  09
5EF4:  MOVWF  x11
5EF6:  MOVLB  0
5EF8:  CALL   3DD0
5EFC:  MOVF   01,F
5EFE:  BTFSC  FD8.2
5F00:  BRA    622E
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
5F02:  MOVLB  3
5F04:  MOVF   x09,W
5F06:  SUBLW  1F
5F08:  BC    5F54
5F0A:  CLRF   03
5F0C:  MOVF   x0E,W
5F0E:  ADDLW  6D
5F10:  MOVWF  FE9
5F12:  MOVLW  02
5F14:  ADDWFC 03,W
5F16:  MOVWF  FEA
5F18:  MOVF   FEF,W
5F1A:  SUBLW  FB
5F1C:  BNC   5F54
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
5F1E:  MOVF   x0E,W
5F20:  MULLW  FE
5F22:  MOVF   FF3,W
5F24:  CLRF   x11
5F26:  MOVWF  x10
5F28:  CLRF   03
5F2A:  MOVF   x0E,W
5F2C:  ADDLW  6D
5F2E:  MOVWF  FE9
5F30:  MOVLW  02
5F32:  ADDWFC 03,W
5F34:  MOVWF  FEA
5F36:  MOVF   FEF,W
5F38:  INCF   FEF,F
5F3A:  CLRF   03
5F3C:  ADDWF  x10,W
5F3E:  MOVWF  01
5F40:  MOVF   x11,W
5F42:  ADDWFC 03,F
5F44:  MOVF   01,W
5F46:  ADDLW  6F
5F48:  MOVWF  FE9
5F4A:  MOVLW  01
5F4C:  ADDWFC 03,W
5F4E:  MOVWF  FEA
5F50:  MOVFF  309,FEF
....................                } 
....................                if (c=='\n') 
5F54:  MOVF   x09,W
5F56:  SUBLW  0A
5F58:  BTFSS  FD8.2
5F5A:  BRA    622A
....................                { 
....................                   buffer[hs][i[hs]]=0; 
5F5C:  MOVF   x0E,W
5F5E:  MULLW  FE
5F60:  MOVF   FF3,W
5F62:  CLRF   x11
5F64:  MOVWF  x10
5F66:  CLRF   03
5F68:  MOVF   x0E,W
5F6A:  ADDLW  6D
5F6C:  MOVWF  FE9
5F6E:  MOVLW  02
5F70:  ADDWFC 03,W
5F72:  MOVWF  FEA
5F74:  CLRF   03
5F76:  MOVF   FEF,W
5F78:  ADDWF  x10,W
5F7A:  MOVWF  01
5F7C:  MOVF   x11,W
5F7E:  ADDWFC 03,F
5F80:  MOVF   01,W
5F82:  ADDLW  6F
5F84:  MOVWF  FE9
5F86:  MOVLW  01
5F88:  ADDWFC 03,W
5F8A:  MOVWF  FEA
5F8C:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
....................                      ) 
5F8E:  MOVF   x0E,W
5F90:  MULLW  FE
5F92:  MOVF   FF3,W
5F94:  CLRF   x11
5F96:  MOVWF  x10
5F98:  MOVLW  6F
5F9A:  ADDWF  x10,F
5F9C:  MOVLW  01
5F9E:  ADDWFC x11,F
5FA0:  MOVFF  311,313
5FA4:  MOVFF  310,312
5FA8:  MOVWF  x15
5FAA:  MOVLW  52
5FAC:  MOVWF  x14
5FAE:  MOVLB  0
5FB0:  CALL   3FAE
5FB4:  MOVFF  02,30B
5FB8:  MOVFF  01,30A
5FBC:  MOVLB  3
5FBE:  MOVF   x0A,F
5FC0:  BNZ   5FC8
5FC2:  MOVF   x0B,F
5FC4:  BTFSC  FD8.2
5FC6:  BRA    61AC
5FC8:  CLRF   x13
5FCA:  CLRF   x12
5FCC:  MOVLW  01
5FCE:  MOVWF  x15
5FD0:  MOVLW  52
5FD2:  MOVWF  x14
5FD4:  MOVLB  0
5FD6:  CALL   3FAE
5FDA:  MOVFF  02,30D
5FDE:  MOVFF  01,30C
5FE2:  MOVLB  3
5FE4:  MOVF   x0C,F
5FE6:  BNZ   5FEE
5FE8:  MOVF   x0D,F
5FEA:  BTFSC  FD8.2
5FEC:  BRA    61AC
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
5FEE:  MOVFF  30B,311
5FF2:  MOVFF  30A,310
5FF6:  MOVLW  01
5FF8:  MOVWF  x13
5FFA:  MOVLW  56
5FFC:  MOVWF  x12
5FFE:  MOVLB  0
6000:  CALL   405E
6004:  MOVF   01,F
6006:  BZ    6026
6008:  MOVFF  30B,311
600C:  MOVFF  30A,310
6010:  MOVLW  01
6012:  MOVLB  3
6014:  MOVWF  x13
6016:  MOVLW  5A
6018:  MOVWF  x12
601A:  MOVLB  0
601C:  CALL   405E
6020:  MOVF   01,F
6022:  BTFSS  FD8.2
6024:  BRA    6142
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
6026:  MOVFF  30D,313
602A:  MOVFF  30C,312
602E:  MOVLW  01
6030:  MOVLB  3
6032:  MOVWF  x15
6034:  MOVLW  54
6036:  MOVWF  x14
6038:  MOVLB  0
603A:  CALL   3FAE
603E:  MOVFF  02,30D
6042:  MOVFF  01,30C
....................                         http_escape_chars(pValue); 
6046:  MOVFF  30D,322
604A:  MOVFF  30C,321
604E:  CALL   45AC
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
6052:  MOVLB  3
6054:  MOVF   x0E,W
6056:  MULLW  04
6058:  MOVF   FF3,W
605A:  CLRF   03
605C:  ADDLW  6F
605E:  MOVWF  01
6060:  MOVLW  02
6062:  ADDWFC 03,F
6064:  MOVFF  01,310
6068:  MOVFF  03,311
606C:  MOVFF  30D,313
6070:  MOVFF  30C,312
6074:  MOVLB  0
6076:  GOTO   47A0
607A:  MOVFF  311,FEA
607E:  MOVFF  310,FE9
6082:  MOVFF  00,FEF
6086:  MOVFF  01,FEC
608A:  MOVFF  02,FEC
608E:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
6092:  MOVLB  3
6094:  CLRF   x13
6096:  CLRF   x12
6098:  MOVLW  01
609A:  MOVWF  x15
609C:  MOVLW  54
609E:  MOVWF  x14
60A0:  MOVLB  0
60A2:  CALL   3FAE
60A6:  MOVFF  02,30D
60AA:  MOVFF  01,30C
....................                         if (pValue) 
60AE:  MOVLB  3
60B0:  MOVF   x0C,W
60B2:  IORWF  x0D,W
60B4:  BZ    60F8
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
60B6:  MOVF   x0E,W
60B8:  MULLW  04
60BA:  MOVF   FF3,W
60BC:  CLRF   03
60BE:  ADDLW  6F
60C0:  MOVWF  FE9
60C2:  MOVLW  02
60C4:  ADDWFC 03,W
60C6:  MOVWF  FEA
60C8:  MOVFF  FEF,310
60CC:  MOVFF  FEC,311
60D0:  MOVFF  FEC,312
60D4:  MOVFF  FEC,313
60D8:  MOVFF  313,319
60DC:  MOVFF  312,318
60E0:  MOVFF  311,317
60E4:  MOVFF  310,316
60E8:  MOVFF  30D,31B
60EC:  MOVFF  30C,31A
60F0:  MOVLB  0
60F2:  CALL   4A90
60F6:  MOVLB  3
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
60F8:  MOVFF  30B,311
60FC:  MOVFF  30A,310
6100:  MOVLW  01
6102:  MOVWF  x13
6104:  MOVLW  56
6106:  MOVWF  x12
6108:  MOVLB  0
610A:  CALL   405E
610E:  MOVF   01,F
6110:  BNZ   612A
....................                            http_cmd[hs]=HTTP_REQ_GET; 
6112:  CLRF   03
6114:  MOVLB  3
6116:  MOVF   x0E,W
6118:  ADDLW  6E
611A:  MOVWF  FE9
611C:  MOVLW  02
611E:  ADDWFC 03,W
6120:  MOVWF  FEA
6122:  MOVLW  01
6124:  MOVWF  FEF
....................                         else 
6126:  BRA    613E
6128:  MOVLB  0
....................                            http_cmd[hs]=HTTP_REQ_POST; 
612A:  CLRF   03
612C:  MOVLB  3
612E:  MOVF   x0E,W
6130:  ADDLW  6E
6132:  MOVWF  FE9
6134:  MOVLW  02
6136:  ADDWFC 03,W
6138:  MOVWF  FEA
613A:  MOVLW  02
613C:  MOVWF  FEF
....................                      } 
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
613E:  BRA    61AA
6140:  MOVLB  0
6142:  CLRF   03
6144:  MOVLB  3
6146:  MOVF   x0E,W
6148:  ADDLW  6E
614A:  MOVWF  FE9
614C:  MOVLW  02
614E:  ADDWFC 03,W
6150:  MOVWF  FEA
6152:  MOVF   FEF,F
6154:  BZ    61AA
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
6156:  MOVFF  30B,311
615A:  MOVFF  30A,310
615E:  MOVLW  01
6160:  MOVWF  x13
6162:  MOVLW  5F
6164:  MOVWF  x12
6166:  MOVLB  0
6168:  CALL   405E
616C:  MOVF   01,F
616E:  BNZ   61A8
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
6170:  BCF    FD8.0
6172:  MOVLB  3
6174:  RLCF   x0E,W
6176:  CLRF   03
6178:  ADDLW  73
617A:  MOVWF  01
617C:  MOVLW  02
617E:  ADDWFC 03,F
6180:  MOVFF  01,310
6184:  MOVFF  03,311
6188:  MOVFF  30D,313
618C:  MOVFF  30C,312
6190:  MOVLB  0
6192:  GOTO   4B38
6196:  MOVFF  311,FEA
619A:  MOVFF  310,FE9
619E:  MOVFF  02,FEC
61A2:  MOVF   FED,F
61A4:  MOVFF  01,FEF
61A8:  MOVLB  3
....................                         } 
....................                      } 
....................                   } 
....................                   else if (i[hs] == 0) 
61AA:  BRA    621A
61AC:  CLRF   03
61AE:  MOVF   x0E,W
61B0:  ADDLW  6D
61B2:  MOVWF  FE9
61B4:  MOVLW  02
61B6:  ADDWFC 03,W
61B8:  MOVWF  FEA
61BA:  MOVF   FEF,F
61BC:  BNZ   621A
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
61BE:  CLRF   03
61C0:  MOVF   x0E,W
61C2:  ADDLW  6E
61C4:  MOVWF  FE9
61C6:  MOVLW  02
61C8:  ADDWFC 03,W
61CA:  MOVWF  FEA
61CC:  MOVF   FEF,W
61CE:  SUBLW  02
61D0:  BNZ   61F0
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
61D2:  BCF    FD8.0
61D4:  RLCF   x0E,W
61D6:  CLRF   03
61D8:  ADDLW  20
61DA:  MOVWF  FE9
61DC:  MOVLW  01
61DE:  ADDWFC 03,W
61E0:  MOVWF  FEA
61E2:  MOVLW  01
61E4:  MOVWF  FEC
61E6:  MOVF   FED,F
61E8:  MOVLW  04
61EA:  MOVWF  FEF
....................                         postContinue=TRUE; 
61EC:  BSF    x08.1
....................                      } 
....................                      else 
61EE:  BRA    6214
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
61F0:  BCF    FD8.0
61F2:  RLCF   x0E,W
61F4:  CLRF   03
61F6:  ADDLW  20
61F8:  MOVWF  FE9
61FA:  MOVLW  01
61FC:  ADDWFC 03,W
61FE:  MOVWF  FEA
6200:  MOVLW  01
6202:  MOVWF  FEC
6204:  MOVF   FED,F
6206:  MOVLW  06
6208:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
620A:  MOVFF  30F,313
620E:  MOVLB  0
6210:  CALL   4D2C
....................                      } 
....................                      break;   //break out of read from ethernet loop 
6214:  MOVLB  0
6216:  BRA    622E
6218:  MOVLB  3
....................                   } 
....................                   i[hs]=0; 
621A:  CLRF   03
621C:  MOVF   x0E,W
621E:  ADDLW  6D
6220:  MOVWF  FE9
6222:  MOVLW  02
6224:  ADDWFC 03,W
6226:  MOVWF  FEA
6228:  CLRF   FEF
....................                } 
....................             } 
622A:  BRA    5ED8
622C:  MOVLB  0
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
622E:  CALL   22D0
6232:  MOVFF  02,311
6236:  MOVFF  01,310
623A:  BCF    FD8.0
623C:  MOVLB  3
623E:  RLCF   x0E,W
6240:  CLRF   03
6242:  ADDLW  75
6244:  MOVWF  FE9
6246:  MOVLW  02
6248:  ADDWFC 03,W
624A:  MOVWF  FEA
624C:  MOVFF  FEC,03
6250:  MOVF   FED,F
6252:  MOVFF  FEF,01
6256:  MOVF   02,W
6258:  SUBWF  03,W
625A:  BNC   6264
625C:  BNZ   6268
625E:  MOVF   01,W
6260:  SUBWF  x10,W
6262:  BNC   6268
6264:  MOVLW  00
6266:  BRA    626A
6268:  MOVLW  01
626A:  CLRF   03
626C:  IORWF  03,W
626E:  BZ    62B2
6270:  BCF    FD8.0
6272:  RLCF   x0E,W
6274:  CLRF   03
6276:  ADDLW  75
6278:  MOVWF  FE9
627A:  MOVLW  02
627C:  ADDWFC 03,W
627E:  MOVWF  FEA
6280:  MOVFF  FEC,03
6284:  MOVF   FED,F
6286:  MOVF   FEF,W
6288:  SUBLW  FF
628A:  MOVWF  x10
628C:  MOVLW  FF
628E:  SUBFWB 03,W
6290:  MOVWF  x11
6292:  MOVLB  0
6294:  CALL   22D0
6298:  MOVF   01,W
629A:  MOVLB  3
629C:  ADDWF  x10,F
629E:  MOVF   02,W
62A0:  ADDWFC x11,F
62A2:  MOVLW  01
62A4:  ADDWF  x10,W
62A6:  MOVWF  01
62A8:  MOVLW  00
62AA:  ADDWFC x11,W
62AC:  MOVWF  03
62AE:  MOVF   01,W
62B0:  BRA    62E6
62B2:  MOVLB  0
62B4:  CALL   22D0
62B8:  MOVFF  02,311
62BC:  MOVFF  01,310
62C0:  BCF    FD8.0
62C2:  MOVLB  3
62C4:  RLCF   x0E,W
62C6:  CLRF   03
62C8:  ADDLW  75
62CA:  MOVWF  FE9
62CC:  MOVLW  02
62CE:  ADDWFC 03,W
62D0:  MOVWF  FEA
62D2:  MOVFF  FEC,03
62D6:  MOVF   FED,F
62D8:  MOVF   FEF,W
62DA:  SUBWF  01,W
62DC:  MOVWF  00
62DE:  MOVF   03,W
62E0:  SUBWFB 02,W
62E2:  MOVWF  03
62E4:  MOVF   00,W
62E6:  SUBLW  C8
62E8:  BC    6320
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
62EA:  MOVF   x0E,W
62EC:  MULLW  04
62EE:  MOVF   FF3,W
62F0:  CLRF   03
62F2:  ADDLW  6F
62F4:  MOVWF  FE9
62F6:  MOVLW  02
62F8:  ADDWFC 03,W
62FA:  MOVWF  FEA
62FC:  MOVLW  FF
62FE:  MOVWF  FEF
6300:  MOVWF  FEC
6302:  MOVWF  FEC
6304:  MOVWF  FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
6306:  BCF    FD8.0
6308:  RLCF   x0E,W
630A:  CLRF   03
630C:  ADDLW  20
630E:  MOVWF  FE9
6310:  MOVLW  01
6312:  ADDWFC 03,W
6314:  MOVWF  FEA
6316:  MOVLW  01
6318:  MOVWF  FEC
631A:  MOVF   FED,F
631C:  MOVLW  06
631E:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
6320:  BTFSC  x08.1
6322:  BRA    6328
....................                break; 
6324:  MOVLB  0
6326:  BRA    6916
6328:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
632A:  BCF    FD8.0
632C:  MOVLB  3
632E:  RLCF   x0E,W
6330:  CLRF   03
6332:  ADDLW  20
6334:  MOVWF  FE9
6336:  MOVLW  01
6338:  ADDWFC 03,W
633A:  MOVWF  FEA
633C:  MOVLW  01
633E:  MOVWF  FEC
6340:  MOVF   FED,F
6342:  MOVLW  05
6344:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
6346:  BCF    FD8.0
6348:  RLCF   x0E,W
634A:  CLRF   03
634C:  ADDLW  75
634E:  MOVWF  01
6350:  MOVLW  02
6352:  ADDWFC 03,F
6354:  MOVFF  01,310
6358:  MOVFF  03,311
635C:  MOVLB  0
635E:  CALL   22D0
6362:  MOVFF  311,FEA
6366:  MOVFF  310,FE9
636A:  MOVFF  02,FEC
636E:  MOVF   FED,F
6370:  MOVFF  01,FEF
....................             i[hs]=0; 
6374:  CLRF   03
6376:  MOVLB  3
6378:  MOVF   x0E,W
637A:  ADDLW  6D
637C:  MOVWF  FE9
637E:  MOVLW  02
6380:  ADDWFC 03,W
6382:  MOVWF  FEA
6384:  CLRF   FEF
6386:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
....................             { 
6388:  MOVFF  30F,310
638C:  CALL   3DA4
6390:  MOVF   01,F
6392:  BTFSC  FD8.2
6394:  BRA    654A
6396:  MOVFF  30F,310
639A:  MOVLW  03
639C:  MOVLB  3
639E:  MOVWF  x12
63A0:  MOVLW  09
63A2:  MOVWF  x11
63A4:  MOVLB  0
63A6:  CALL   3DD0
63AA:  MOVF   01,F
63AC:  BTFSC  FD8.2
63AE:  BRA    654A
63B0:  BCF    FD8.0
63B2:  MOVLB  3
63B4:  RLCF   x0E,W
63B6:  CLRF   03
63B8:  ADDLW  73
63BA:  MOVWF  FE9
63BC:  MOVLW  02
63BE:  ADDWFC 03,W
63C0:  MOVWF  FEA
63C2:  MOVFF  FEC,311
63C6:  MOVF   FED,F
63C8:  MOVFF  FEF,310
63CC:  MOVF   x10,F
63CE:  BNZ   63DA
63D0:  MOVF   x11,F
63D2:  BTFSS  FD8.2
63D4:  BRA    63DA
63D6:  MOVLB  0
63D8:  BRA    654A
....................                http_post_len[hs] -= 1; 
63DA:  BCF    FD8.0
63DC:  RLCF   x0E,W
63DE:  CLRF   03
63E0:  ADDLW  73
63E2:  MOVWF  FE9
63E4:  MOVLW  02
63E6:  ADDWFC 03,W
63E8:  MOVWF  FEA
63EA:  MOVLW  01
63EC:  SUBWF  FEF,W
63EE:  MOVWF  00
63F0:  MOVLW  00
63F2:  SUBWFB FEC,W
63F4:  MOVWF  03
63F6:  MOVF   00,W
63F8:  MOVF   FED,F
63FA:  MOVWF  FEF
63FC:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
6400:  MOVF   x09,W
6402:  SUBLW  26
6404:  BZ    643C
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
6406:  MOVF   x0E,W
6408:  MULLW  FE
640A:  MOVF   FF3,W
640C:  CLRF   x11
640E:  MOVWF  x10
6410:  CLRF   03
6412:  MOVF   x0E,W
6414:  ADDLW  6D
6416:  MOVWF  FE9
6418:  MOVLW  02
641A:  ADDWFC 03,W
641C:  MOVWF  FEA
641E:  MOVF   FEF,W
6420:  INCF   FEF,F
6422:  CLRF   03
6424:  ADDWF  x10,W
6426:  MOVWF  01
6428:  MOVF   x11,W
642A:  ADDWFC 03,F
642C:  MOVF   01,W
642E:  ADDLW  6F
6430:  MOVWF  FE9
6432:  MOVLW  01
6434:  ADDWFC 03,W
6436:  MOVWF  FEA
6438:  MOVFF  309,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
643C:  MOVF   x09,W
643E:  SUBLW  26
6440:  BZ    6464
6442:  BCF    FD8.0
6444:  RLCF   x0E,W
6446:  CLRF   03
6448:  ADDLW  73
644A:  MOVWF  FE9
644C:  MOVLW  02
644E:  ADDWFC 03,W
6450:  MOVWF  FEA
6452:  MOVFF  FEC,311
6456:  MOVF   FED,F
6458:  MOVFF  FEF,310
645C:  MOVF   x10,F
645E:  BNZ   6546
6460:  MOVF   x11,F
6462:  BNZ   6546
....................                { 
....................                   buffer[hs][i[hs]]=0; 
6464:  MOVF   x0E,W
6466:  MULLW  FE
6468:  MOVF   FF3,W
646A:  CLRF   x11
646C:  MOVWF  x10
646E:  CLRF   03
6470:  MOVF   x0E,W
6472:  ADDLW  6D
6474:  MOVWF  FE9
6476:  MOVLW  02
6478:  ADDWFC 03,W
647A:  MOVWF  FEA
647C:  CLRF   03
647E:  MOVF   FEF,W
6480:  ADDWF  x10,W
6482:  MOVWF  01
6484:  MOVF   x11,W
6486:  ADDWFC 03,F
6488:  MOVF   01,W
648A:  ADDLW  6F
648C:  MOVWF  FE9
648E:  MOVLW  01
6490:  ADDWFC 03,W
6492:  MOVWF  FEA
6494:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
6496:  MOVF   x0E,W
6498:  MULLW  04
649A:  MOVF   FF3,W
649C:  CLRF   03
649E:  ADDLW  6F
64A0:  MOVWF  FE9
64A2:  MOVLW  02
64A4:  ADDWFC 03,W
64A6:  MOVWF  FEA
64A8:  MOVFF  FEF,310
64AC:  MOVFF  FEC,311
64B0:  MOVFF  FEC,312
64B4:  MOVFF  FEC,313
64B8:  MOVF   x0E,W
64BA:  MULLW  FE
64BC:  MOVF   FF3,W
64BE:  CLRF   x15
64C0:  MOVWF  x14
64C2:  MOVLW  6F
64C4:  ADDWF  x14,F
64C6:  MOVLW  01
64C8:  ADDWFC x15,F
64CA:  MOVFF  313,319
64CE:  MOVFF  312,318
64D2:  MOVFF  311,317
64D6:  MOVFF  310,316
64DA:  MOVFF  315,31B
64DE:  MOVFF  314,31A
64E2:  MOVLB  0
64E4:  CALL   4A90
....................                   if (http_post_len[hs] == 0) 
64E8:  BCF    FD8.0
64EA:  MOVLB  3
64EC:  RLCF   x0E,W
64EE:  CLRF   03
64F0:  ADDLW  73
64F2:  MOVWF  FE9
64F4:  MOVLW  02
64F6:  ADDWFC 03,W
64F8:  MOVWF  FEA
64FA:  MOVFF  FEC,311
64FE:  MOVF   FED,F
6500:  MOVFF  FEF,310
6504:  MOVF   x10,F
6506:  BNZ   6536
6508:  MOVF   x11,F
650A:  BNZ   6536
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
650C:  BCF    FD8.0
650E:  RLCF   x0E,W
6510:  CLRF   03
6512:  ADDLW  20
6514:  MOVWF  FE9
6516:  MOVLW  01
6518:  ADDWFC 03,W
651A:  MOVWF  FEA
651C:  MOVLW  01
651E:  MOVWF  FEC
6520:  MOVF   FED,F
6522:  MOVLW  06
6524:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
6526:  MOVFF  30F,313
652A:  MOVLB  0
652C:  CALL   4D2C
....................                      break; 
6530:  BRA    654A
....................                   } 
....................                   else 
6532:  BRA    6548
6534:  MOVLB  3
....................                      i[hs]=0; 
6536:  CLRF   03
6538:  MOVF   x0E,W
653A:  ADDLW  6D
653C:  MOVWF  FE9
653E:  MOVLW  02
6540:  ADDWFC 03,W
6542:  MOVWF  FEA
6544:  CLRF   FEF
6546:  MOVLB  0
....................                } 
....................             } 
6548:  BRA    6388
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
654A:  CALL   22D0
654E:  MOVFF  02,311
6552:  MOVFF  01,310
6556:  BCF    FD8.0
6558:  MOVLB  3
655A:  RLCF   x0E,W
655C:  CLRF   03
655E:  ADDLW  75
6560:  MOVWF  FE9
6562:  MOVLW  02
6564:  ADDWFC 03,W
6566:  MOVWF  FEA
6568:  MOVFF  FEC,03
656C:  MOVF   FED,F
656E:  MOVFF  FEF,01
6572:  MOVF   02,W
6574:  SUBWF  03,W
6576:  BNC   6580
6578:  BNZ   6584
657A:  MOVF   01,W
657C:  SUBWF  x10,W
657E:  BNC   6584
6580:  MOVLW  00
6582:  BRA    6586
6584:  MOVLW  01
6586:  CLRF   03
6588:  IORWF  03,W
658A:  BZ    65CE
658C:  BCF    FD8.0
658E:  RLCF   x0E,W
6590:  CLRF   03
6592:  ADDLW  75
6594:  MOVWF  FE9
6596:  MOVLW  02
6598:  ADDWFC 03,W
659A:  MOVWF  FEA
659C:  MOVFF  FEC,03
65A0:  MOVF   FED,F
65A2:  MOVF   FEF,W
65A4:  SUBLW  FF
65A6:  MOVWF  x10
65A8:  MOVLW  FF
65AA:  SUBFWB 03,W
65AC:  MOVWF  x11
65AE:  MOVLB  0
65B0:  CALL   22D0
65B4:  MOVF   01,W
65B6:  MOVLB  3
65B8:  ADDWF  x10,F
65BA:  MOVF   02,W
65BC:  ADDWFC x11,F
65BE:  MOVLW  01
65C0:  ADDWF  x10,W
65C2:  MOVWF  01
65C4:  MOVLW  00
65C6:  ADDWFC x11,W
65C8:  MOVWF  03
65CA:  MOVF   01,W
65CC:  BRA    6602
65CE:  MOVLB  0
65D0:  CALL   22D0
65D4:  MOVFF  02,311
65D8:  MOVFF  01,310
65DC:  BCF    FD8.0
65DE:  MOVLB  3
65E0:  RLCF   x0E,W
65E2:  CLRF   03
65E4:  ADDLW  75
65E6:  MOVWF  FE9
65E8:  MOVLW  02
65EA:  ADDWFC 03,W
65EC:  MOVWF  FEA
65EE:  MOVFF  FEC,03
65F2:  MOVF   FED,F
65F4:  MOVF   FEF,W
65F6:  SUBWF  01,W
65F8:  MOVWF  00
65FA:  MOVF   03,W
65FC:  SUBWFB 02,W
65FE:  MOVWF  03
6600:  MOVF   00,W
6602:  SUBLW  C8
6604:  BC    663C
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
6606:  MOVF   x0E,W
6608:  MULLW  04
660A:  MOVF   FF3,W
660C:  CLRF   03
660E:  ADDLW  6F
6610:  MOVWF  FE9
6612:  MOVLW  02
6614:  ADDWFC 03,W
6616:  MOVWF  FEA
6618:  MOVLW  FF
661A:  MOVWF  FEF
661C:  MOVWF  FEC
661E:  MOVWF  FEC
6620:  MOVWF  FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
6622:  BCF    FD8.0
6624:  RLCF   x0E,W
6626:  CLRF   03
6628:  ADDLW  20
662A:  MOVWF  FE9
662C:  MOVLW  01
662E:  ADDWFC 03,W
6630:  MOVWF  FEA
6632:  MOVLW  01
6634:  MOVWF  FEC
6636:  MOVF   FED,F
6638:  MOVLW  06
663A:  MOVWF  FEF
....................             } 
....................             break; 
663C:  MOVLB  0
663E:  BRA    6916
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
6640:  MOVLB  3
6642:  MOVF   x0E,W
6644:  MULLW  04
6646:  MOVF   FF3,W
6648:  CLRF   03
664A:  ADDLW  23
664C:  MOVWF  FE9
664E:  MOVLW  01
6650:  ADDWFC 03,W
6652:  MOVWF  FEA
6654:  MOVF   FEE,F
6656:  MOVF   FEE,F
6658:  CLRF   FEC
665A:  MOVF   FED,F
665C:  CLRF   FEF
665E:  MOVF   FED,F
6660:  CLRF   FEF
6662:  MOVF   FED,F
6664:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
6666:  BCF    FD8.0
6668:  RLCF   x0E,W
666A:  CLRF   03
666C:  ADDLW  20
666E:  MOVWF  FE9
6670:  MOVLW  01
6672:  ADDWFC 03,W
6674:  MOVWF  FEA
6676:  MOVLW  01
6678:  MOVWF  FEC
667A:  MOVF   FED,F
667C:  MOVLW  07
667E:  MOVWF  FEF
6680:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
6682:  MOVFF  30F,313
6686:  CALL   4D2C
....................             if (TCPIsPutReady(currSocket)) 
668A:  MOVFF  30F,333
668E:  CALL   4D7A
6692:  MOVF   01,F
6694:  BTFSC  FD8.2
6696:  BRA    67CC
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
6698:  MOVLB  3
669A:  MOVF   x0E,W
669C:  MULLW  04
669E:  MOVF   FF3,W
66A0:  CLRF   03
66A2:  ADDLW  6F
66A4:  MOVWF  FE9
66A6:  MOVLW  02
66A8:  ADDWFC 03,W
66AA:  MOVWF  FEA
66AC:  MOVFF  FEF,310
66B0:  MOVFF  FEC,311
66B4:  MOVFF  FEC,312
66B8:  MOVFF  FEC,313
66BC:  INCFSZ x10,W
66BE:  BRA    6704
66C0:  INCFSZ x11,W
66C2:  BRA    6704
66C4:  INCFSZ x12,W
66C6:  BRA    6704
66C8:  INCFSZ x13,W
66CA:  BRA    6704
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
66CC:  MOVLW  02
66CE:  MOVWF  03
66D0:  MOVLW  12
66D2:  MOVWF  x10
66D4:  MOVFF  03,311
66D8:  MOVFF  30E,314
66DC:  MOVLW  01
66DE:  MOVWF  x16
66E0:  MOVLW  F4
66E2:  MOVWF  x15
66E4:  CLRF   x1A
66E6:  CLRF   x19
66E8:  MOVFF  03,318
66EC:  MOVFF  310,317
66F0:  CLRF   x1C
66F2:  CLRF   x1B
66F4:  MOVLB  0
66F6:  CALL   57D0
66FA:  MOVLB  3
66FC:  BCF    x08.0
66FE:  BTFSC  01.0
6700:  BSF    x08.0
....................                else if (http_page_req[hs]) 
6702:  BRA    67AC
....................                 #if HTTP_USE_CONTENT_TYPE 
6704:  MOVF   x0E,W
6706:  MULLW  04
6708:  MOVF   FF3,W
670A:  CLRF   03
670C:  ADDLW  6F
670E:  MOVWF  FE9
6710:  MOVLW  02
6712:  ADDWFC 03,W
6714:  MOVWF  FEA
6716:  MOVF   FEF,F
6718:  BNZ   6726
671A:  MOVF   FEC,F
671C:  BNZ   6726
671E:  MOVF   FEC,F
6720:  BNZ   6726
6722:  MOVF   FEC,F
6724:  BZ    6776
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
6726:  MOVF   x0E,W
6728:  MULLW  04
672A:  MOVF   FF3,W
672C:  CLRF   03
672E:  ADDLW  6F
6730:  MOVWF  FE9
6732:  MOVLW  02
6734:  ADDWFC 03,W
6736:  MOVWF  FEA
6738:  MOVFF  FEF,310
673C:  MOVFF  FEC,311
6740:  MOVFF  FEC,312
6744:  MOVFF  FEC,313
6748:  MOVFF  30E,314
674C:  CLRF   x16
674E:  MOVLW  C8
6750:  MOVWF  x15
6752:  MOVFF  313,31A
6756:  MOVFF  312,319
675A:  MOVFF  311,318
675E:  MOVFF  310,317
6762:  CLRF   x1C
6764:  CLRF   x1B
6766:  MOVLB  0
6768:  CALL   57D0
676C:  MOVLB  3
676E:  BCF    x08.0
6770:  BTFSC  01.0
6772:  BSF    x08.0
....................                 #endif 
....................                else 
6774:  BRA    67AC
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
6776:  MOVLW  01
6778:  MOVWF  03
677A:  MOVLW  CE
677C:  MOVWF  x10
677E:  MOVFF  03,311
6782:  MOVFF  30E,314
6786:  MOVLW  01
6788:  MOVWF  x16
678A:  MOVLW  94
678C:  MOVWF  x15
678E:  CLRF   x1A
6790:  CLRF   x19
6792:  MOVFF  03,318
6796:  MOVFF  310,317
679A:  CLRF   x1C
679C:  CLRF   x1B
679E:  MOVLB  0
67A0:  CALL   57D0
67A4:  MOVLB  3
67A6:  BCF    x08.0
67A8:  BTFSC  01.0
67AA:  BSF    x08.0
....................  
....................                if (doneSend) 
67AC:  BTFSS  x08.0
67AE:  BRA    67CA
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
67B0:  BCF    FD8.0
67B2:  RLCF   x0E,W
67B4:  CLRF   03
67B6:  ADDLW  20
67B8:  MOVWF  FE9
67BA:  MOVLW  01
67BC:  ADDWFC 03,W
67BE:  MOVWF  FEA
67C0:  MOVLW  01
67C2:  MOVWF  FEC
67C4:  MOVF   FED,F
67C6:  MOVLW  08
67C8:  MOVWF  FEF
67CA:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
67CC:  BRA    6916
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
67CE:  BCF    FD8.0
67D0:  MOVLB  3
67D2:  RLCF   x0E,W
67D4:  CLRF   03
67D6:  ADDLW  20
67D8:  MOVWF  FE9
67DA:  MOVLW  01
67DC:  ADDWFC 03,W
67DE:  MOVWF  FEA
67E0:  MOVLW  01
67E2:  MOVWF  FEC
67E4:  MOVF   FED,F
67E6:  MOVLW  09
67E8:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
67EA:  BCF    FD8.0
67EC:  RLCF   x0E,W
67EE:  CLRF   03
67F0:  ADDLW  75
67F2:  MOVWF  01
67F4:  MOVLW  02
67F6:  ADDWFC 03,F
67F8:  MOVFF  01,310
67FC:  MOVFF  03,311
6800:  MOVLB  0
6802:  CALL   22D0
6806:  MOVFF  311,FEA
680A:  MOVFF  310,FE9
680E:  MOVFF  02,FEC
6812:  MOVF   FED,F
6814:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
6818:  MOVFF  30F,313
681C:  CALL   4D2C
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
....................                ) 
6820:  MOVFF  30F,333
6824:  CALL   4D7A
6828:  MOVF   01,F
682A:  BNZ   68EA
682C:  CALL   22D0
6830:  MOVFF  02,311
6834:  MOVFF  01,310
6838:  BCF    FD8.0
683A:  MOVLB  3
683C:  RLCF   x0E,W
683E:  CLRF   03
6840:  ADDLW  75
6842:  MOVWF  FE9
6844:  MOVLW  02
6846:  ADDWFC 03,W
6848:  MOVWF  FEA
684A:  MOVFF  FEC,03
684E:  MOVF   FED,F
6850:  MOVFF  FEF,01
6854:  MOVF   02,W
6856:  SUBWF  03,W
6858:  BNC   6862
685A:  BNZ   6866
685C:  MOVF   01,W
685E:  SUBWF  x10,W
6860:  BNC   6866
6862:  MOVLW  00
6864:  BRA    6868
6866:  MOVLW  01
6868:  CLRF   03
686A:  IORWF  03,W
686C:  BZ    68B0
686E:  BCF    FD8.0
6870:  RLCF   x0E,W
6872:  CLRF   03
6874:  ADDLW  75
6876:  MOVWF  FE9
6878:  MOVLW  02
687A:  ADDWFC 03,W
687C:  MOVWF  FEA
687E:  MOVFF  FEC,03
6882:  MOVF   FED,F
6884:  MOVF   FEF,W
6886:  SUBLW  FF
6888:  MOVWF  x10
688A:  MOVLW  FF
688C:  SUBFWB 03,W
688E:  MOVWF  x11
6890:  MOVLB  0
6892:  CALL   22D0
6896:  MOVF   01,W
6898:  MOVLB  3
689A:  ADDWF  x10,F
689C:  MOVF   02,W
689E:  ADDWFC x11,F
68A0:  MOVLW  01
68A2:  ADDWF  x10,W
68A4:  MOVWF  01
68A6:  MOVLW  00
68A8:  ADDWFC x11,W
68AA:  MOVWF  03
68AC:  MOVF   01,W
68AE:  BRA    68E4
68B0:  MOVLB  0
68B2:  CALL   22D0
68B6:  MOVFF  02,311
68BA:  MOVFF  01,310
68BE:  BCF    FD8.0
68C0:  MOVLB  3
68C2:  RLCF   x0E,W
68C4:  CLRF   03
68C6:  ADDLW  75
68C8:  MOVWF  FE9
68CA:  MOVLW  02
68CC:  ADDWFC 03,W
68CE:  MOVWF  FEA
68D0:  MOVFF  FEC,03
68D4:  MOVF   FED,F
68D6:  MOVF   FEF,W
68D8:  SUBWF  01,W
68DA:  MOVWF  00
68DC:  MOVF   03,W
68DE:  SUBWFB 02,W
68E0:  MOVWF  03
68E2:  MOVF   00,W
68E4:  SUBLW  32
68E6:  BC    690E
68E8:  MOVLB  0
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
68EA:  MOVFF  30F,310
68EE:  GOTO   5B8C
....................                http_state[hs]=HTTP_CLOSED; 
68F2:  BCF    FD8.0
68F4:  MOVLB  3
68F6:  RLCF   x0E,W
68F8:  CLRF   03
68FA:  ADDLW  20
68FC:  MOVWF  FE9
68FE:  MOVLW  01
6900:  ADDWFC 03,W
6902:  MOVWF  FEA
6904:  MOVLW  01
6906:  MOVWF  FEC
6908:  MOVF   FED,F
690A:  MOVLW  0A
690C:  MOVWF  FEF
....................             } 
....................             break; 
690E:  MOVLB  0
6910:  BRA    6916
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
6912:  MOVLB  0
6914:  BRA    6916
....................       } 
....................    } 
6916:  MOVLB  3
6918:  INCF   x0E,F
691A:  GOTO   5CCE
.................... } 
691E:  MOVLB  0
6920:  GOTO   6AE6 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
0EAC:  MOVLB  2
0EAE:  CLRF   x77
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
0EB0:  MOVLB  0
0EB2:  GOTO   05C4
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
0EB6:  BRA    08E4
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
0EB8:  BRA    0AB2
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
0EBA:  BRA    0C00
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
0EBC:  BRA    0E42
.................... #endif 
.................... } 
0EBE:  GOTO   6FB0 (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
6924:  MOVLB  3
6926:  BCF    x07.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
6928:  BCF    x07.0
....................         switch(smStack) 
....................         { 
692A:  MOVLB  2
692C:  MOVF   x77,W
692E:  ADDLW  F9
6930:  BTFSC  FD8.0
6932:  BRA    6AD6
6934:  ADDLW  07
6936:  MOVLB  0
6938:  GOTO   6AEA
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
693C:  MOVLW  02
693E:  MOVLB  3
6940:  MOVWF  x09
6942:  MOVLW  78
6944:  MOVWF  x08
6946:  MOVLW  03
6948:  MOVWF  x0B
694A:  MOVLW  06
694C:  MOVWF  x0A
694E:  MOVLB  0
6950:  GOTO   0FA4
6954:  MOVF   01,F
6956:  BNZ   695C
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
6958:  MOVLB  2
695A:  BRA    6AD6
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET ");      //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................  
....................             lbContinue = TRUE; 
695C:  MOVLB  3
695E:  BSF    x07.0
....................             if ( type.MACFrameType == MAC_IP ) { 
6960:  MOVF   x06,F
6962:  BNZ   696E
....................                 smStack = SM_STACK_IP; 
6964:  MOVLW  02
6966:  MOVLB  2
6968:  MOVWF  x77
.................... //                debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
696A:  BRA    6986
696C:  MOVLB  3
696E:  MOVF   x06,W
6970:  SUBLW  06
6972:  BNZ   697E
....................                 smStack = SM_STACK_ARP; 
6974:  MOVLW  05
6976:  MOVLB  2
6978:  MOVWF  x77
.................... //                debug_stack("ARP ");          //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             else { 
697A:  BRA    6986
697C:  MOVLB  3
....................                 MACDiscardRx(); 
697E:  MOVLB  0
6980:  CALL   0EC2
6984:  MOVLB  2
.................... //                debug_stack("DISCARD");       //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             break; 
6986:  BRA    6AD6
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
6988:  GOTO   184C
698C:  MOVF   01,F
698E:  BZ    6994
....................                 smStack = SM_STACK_IDLE; 
6990:  MOVLB  2
6992:  CLRF   x77
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
6994:  MOVLB  2
6996:  BRA    6AD6
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
6998:  MOVLW  03
699A:  MOVLB  3
699C:  MOVWF  x09
699E:  MOVLW  02
69A0:  MOVWF  x08
69A2:  MOVWF  x0B
69A4:  MOVLW  78
69A6:  MOVWF  x0A
69A8:  MOVLW  03
69AA:  MOVWF  x0D
69AC:  MOVLW  06
69AE:  MOVWF  x0C
69B0:  MOVLW  02
69B2:  MOVWF  x0F
69B4:  MOVLW  82
69B6:  MOVWF  x0E
69B8:  MOVLB  0
69BA:  GOTO   1B42
69BE:  MOVF   01,F
69C0:  BZ    69F4
....................             { 
....................                 lbContinue = TRUE; 
69C2:  MOVLB  3
69C4:  BSF    x07.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
69C6:  DECFSZ x06,W
69C8:  BRA    69D4
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
69CA:  MOVLW  03
69CC:  MOVLB  2
69CE:  MOVWF  x77
.................... //                    debug_stack("ICMP ");        //SE COMENTA PARA TRABAJO CON ALUX 1.1 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
69D0:  BRA    69F0
69D2:  MOVLB  3
69D4:  MOVF   x06,W
69D6:  SUBLW  06
69D8:  BNZ   69E4
....................                     smStack = SM_STACK_TCP; 
69DA:  MOVLW  06
69DC:  MOVLB  2
69DE:  MOVWF  x77
.................... //                    debug_stack("TCP ");            //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
.................... //                    debug_stack("UDP ");            //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
.................... #endif 
....................  
....................                 else 
69E0:  BRA    69F0
69E2:  MOVLB  3
....................                 { 
....................                     lbContinue = FALSE; 
69E4:  BCF    x07.0
....................                     MACDiscardRx(); 
69E6:  MOVLB  0
69E8:  CALL   0EC2
....................  
....................                     smStack = SM_STACK_IDLE; 
69EC:  MOVLB  2
69EE:  CLRF   x77
.................... //                    debug_stack("UNKOWN-IP1 ");     //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
....................             } 
....................             else 
69F0:  BRA    69FC
69F2:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
69F4:  CALL   0EC2
....................                 smStack = SM_STACK_IDLE; 
69F8:  MOVLB  2
69FA:  CLRF   x77
.................... //                debug_stack("UNKOWN-IP2 ");         //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             break; 
69FC:  BRA    6AD6
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 //debug_stack("\r\nUDP PROCESSED");   //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
69FE:  MOVLW  02
6A00:  MOVLB  3
6A02:  MOVWF  x09
6A04:  MOVLW  78
6A06:  MOVWF  x08
6A08:  MOVLW  03
6A0A:  MOVWF  x0B
6A0C:  MOVLW  02
6A0E:  MOVWF  x0A
6A10:  MOVFF  283,30D
6A14:  MOVFF  282,30C
6A18:  MOVLB  0
6A1A:  GOTO   3436
6A1E:  MOVF   01,F
6A20:  BZ    6A26
....................             { 
.................... //                debug_stack("\r\nTCP PROCESSED");   //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
6A22:  MOVLB  2
6A24:  CLRF   x77
....................             } 
....................             break; 
6A26:  MOVLB  2
6A28:  BRA    6AD6
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
6A2A:  MOVLB  2
6A2C:  CLRF   x77
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
6A2E:  MOVF   x83,F
6A30:  BNZ   6A84
6A32:  MOVF   x82,W
6A34:  SUBLW  48
6A36:  BNC   6A84
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
6A38:  MOVLW  02
6A3A:  MOVLB  3
6A3C:  MOVWF  x09
6A3E:  MOVLW  82
6A40:  MOVWF  x08
6A42:  MOVLW  03
6A44:  MOVWF  x0B
6A46:  MOVLW  06
6A48:  MOVWF  x0A
6A4A:  MOVLW  02
6A4C:  MOVWF  x0D
6A4E:  MOVLW  84
6A50:  MOVWF  x0C
6A52:  MOVFF  309,30F
6A56:  MOVFF  308,30E
6A5A:  MOVLW  02
6A5C:  MOVWF  x11
6A5E:  MOVLW  C4
6A60:  MOVWF  x10
6A62:  MOVLW  02
6A64:  MOVWF  x13
6A66:  MOVLW  C6
6A68:  MOVWF  x12
6A6A:  MOVLB  0
6A6C:  GOTO   36C2
6A70:  MOVF   01,F
6A72:  BZ    6A88
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
6A74:  MOVLB  3
6A76:  MOVF   x06,W
6A78:  SUBLW  08
6A7A:  BNZ   6A86
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED");      //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                         lbContinue = TRUE; 
6A7C:  BSF    x07.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
6A7E:  MOVLW  04
6A80:  MOVLB  2
6A82:  MOVWF  x77
6A84:  MOVLB  3
6A86:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
6A88:  CALL   0EC2
....................             break; 
6A8C:  MOVLB  2
6A8E:  BRA    6AD6
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
6A90:  MOVLW  01
6A92:  MOVLB  3
6A94:  MOVWF  x91
6A96:  MOVLB  0
6A98:  CALL   23EE
6A9C:  MOVF   01,F
6A9E:  BZ    6AD2
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
6AA0:  MOVLW  02
6AA2:  MOVLB  3
6AA4:  MOVWF  x09
6AA6:  MOVLW  78
6AA8:  MOVWF  x08
6AAA:  CLRF   x0A
6AAC:  MOVLW  02
6AAE:  MOVWF  x0C
6AB0:  MOVLW  84
6AB2:  MOVWF  x0B
6AB4:  MOVFF  282,30D
6AB8:  MOVFF  2C5,30F
6ABC:  MOVFF  2C4,30E
6AC0:  MOVFF  2C7,311
6AC4:  MOVFF  2C6,310
6AC8:  MOVLB  0
6ACA:  GOTO   379A
....................  
.................... //                debug_stack("\r\nICMP REPLIED");    //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
6ACE:  MOVLB  2
6AD0:  CLRF   x77
....................             } 
....................             break; 
6AD2:  MOVLB  2
6AD4:  BRA    6AD6
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
6AD6:  MOVLB  3
6AD8:  BTFSC  x07.0
6ADA:  BRA    6928
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
6ADC:  MOVLB  0
6ADE:  GOTO   38AC
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
6AE2:  GOTO   5CCA
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
6AE6:  GOTO   6FB2 (RETURN)
....................  
....................  
.................... #if STACK_USE_CCS_PICENS 
....................  #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................                                      
....................                                     //SE MODIFICARON LOS PINES PARA TRABAJO CON ALUX 1.1 
....................  #define USER_LED1    PIN_B5        //ANTES PIN_A5 
....................  #define USER_LED2    PIN_B6        //ANTES PIN_B4 
....................  #define USER_LED3    PIN_B7        //ANTES PIN_B5 
....................  #define LED_OFF      output_low    //ANTES OUTPUT_HIGH 
....................  #define LED_ON       output_high   //ANTES OUTPUT_LOW 
....................   
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
*
0596:  BSF    FC0.0
0598:  BSF    FC0.1
059A:  BSF    FC0.2
059C:  BCF    FC0.7
059E:  BSF    FC2.0
....................    setup_adc_ports(AN0); 
05A0:  MOVF   FC1,W
05A2:  ANDLW  C0
05A4:  IORLW  0E
05A6:  MOVWF  FC1
....................     
....................    ////ALUX: ANTES 
....................    //*0xF92=(*0xF92 & 0xDF) | 0x11;   //a5 output, a4 and a0 input 
....................    //*0xF93=*0xF93 & 0xCF;            //b4 and b5 output 
....................     
....................    ////ALUX: PARA EL ALUX 1.1  TRIS A:0xF92, TRISB:0xF93, TRISC:0XF94 
....................       *0xF92 = (*0xF92 & 0xFF) | 0x11;   //a4 y a0 entradas. 
05A8:  MOVF   F92,W
05AA:  IORLW  11
05AC:  MOVWF  F92
....................       *0xF93 = (*0xF93 & 0x1D) | 0x05;   //b7, b5 y b1 salidas, b2 y b0 entradas. 
05AE:  MOVF   F93,W
05B0:  ANDLW  1D
05B2:  IORLW  05
05B4:  MOVWF  F93
....................       *0xF94 = (*0xF94 & 0x7C);          //c1 y c0 salidas. 
05B6:  MOVLW  7C
05B8:  ANDWF  F94,F
....................     
....................    LED_ON(USER_LED1); 
05BA:  BSF    F8A.5
....................    LED_ON(USER_LED2); 
05BC:  BSF    F8A.6
....................    LED_ON(USER_LED3); 
05BE:  BSF    F8A.7
....................     
....................  } 
05C0:  GOTO   6FA0 (RETURN)
....................  
.................... ////ALUX: 
.................... /*#elif STACK_USE_CCS_PICEEC 
....................  #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................  
....................  #define USER_LED1    PIN_A5 
....................  #define USER_LED2    PIN_B4 
....................  #define USER_LED3    PIN_B5 
....................  #define LED_ON       output_low 
....................  #define LED_OFF      output_high 
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................    setup_adc_ports(AN0_TO_AN2); 
....................    set_adc_channel(2); 
....................    *0xF92=*0xF92 & 0xFC;   //a0 and a1 output 
....................    *0xF93=*0xF93 & 0xCF;   //b4 and b5 output 
....................    LED_OFF(USER_LED1); 
....................    LED_OFF(USER_LED2); 
....................    LED_OFF(USER_LED3); 
....................  } 
.................... #else 
....................  #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................  #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................  
....................  #define USER_LED1    PIN_B2 
....................  #define USER_LED2    PIN_B4 
....................  #define LED_ON       output_low 
....................  #define LED_OFF      output_high 
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL ); 
....................    setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................    *0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................    *0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................    LED_OFF(USER_LED1); 
....................    LED_OFF(USER_LED2); 
....................  }*/ 
.................... #endif  
....................  
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
0552:  CLRF   1C
....................    MY_MAC_BYTE2=2; 
0554:  MOVLW  02
0556:  MOVWF  1D
....................    MY_MAC_BYTE3=3; 
0558:  MOVLW  03
055A:  MOVWF  1E
....................    MY_MAC_BYTE4=4; 
055C:  MOVLW  04
055E:  MOVWF  1F
....................    MY_MAC_BYTE5=5; 
0560:  MOVLW  05
0562:  MOVWF  20
....................    MY_MAC_BYTE6=6; 
0564:  MOVLW  06
0566:  MOVWF  21
.................... } 
0568:  GOTO   6F98 (RETURN)
....................  
.................... void IPAddrInit(void) { 
....................    //IP address of this unit       //SE MODIFICO LA IP DEL PIC A 192.168.0.110 
....................    MY_IP_BYTE1=192; 
056C:  MOVLW  C0
056E:  MOVWF  18
....................    MY_IP_BYTE2=168; 
0570:  MOVLW  A8
0572:  MOVWF  19
....................    MY_IP_BYTE3=0; 
0574:  CLRF   1A
....................    MY_IP_BYTE4=110; 
0576:  MOVLW  6E
0578:  MOVWF  1B
....................  
....................    //network gateway               //SE MODIFICO LA IP DEL PIC A 192.168.0.1 
....................    MY_GATE_BYTE1=192; 
057A:  MOVLW  C0
057C:  MOVWF  26
....................    MY_GATE_BYTE2=168; 
057E:  MOVLW  A8
0580:  MOVWF  27
....................    MY_GATE_BYTE3=0; 
0582:  CLRF   28
....................    MY_GATE_BYTE4=1; 
0584:  MOVLW  01
0586:  MOVWF  29
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
0588:  MOVLW  FF
058A:  MOVWF  22
....................    MY_MASK_BYTE2=255; 
058C:  MOVWF  23
....................    MY_MASK_BYTE3=255; 
058E:  MOVWF  24
....................    MY_MASK_BYTE4=0; 
0590:  CLRF   25
.................... } 
0592:  GOTO   6F9C (RETURN)
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x08, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
....................  
.................... /*#if STACK_USE_CCS_PICENS 
....................  #include "tcpip/mlcd.c" 
.................... #else 
....................  #include "tcpip/dlcd.c" 
.................... #endif*/ 
....................  
.................... //here is this examples / page 
.................... const char  HTML_INDEX_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"C:\\PIC Ethernet WebServer\\cicy.gif\"><P>    
.................... <H1>CICY HTTP/CGI EXAMPLE</H1> 
.................... <FORM METHOD=GET> 
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16> 
.................... <BR>LED1:<INPUT type=\"radio\" name=\"led1\" value=1>ON &nbsp; &nbsp; &nbsp; 
.................... <INPUT type=\"radio\" name=\"led1\" value=0 checked>OFF 
.................... <BR>LED2:<INPUT type=\"radio\" name=\"led2\" value=1>ON &nbsp; &nbsp; &nbsp; 
.................... <INPUT type=\"radio\" name=\"led2\" value=0 checked>OFF 
.................... <BR><INPUT TYPE=\"submit\"></FORM> 
.................... <P><A HREF=\"/analog\">Analog Readings</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... const char  HTML_ANALOG_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"http://www.ccsinfo.com/pix/CCSlogotiny.gif\"> 
.................... <H1>PICNET ADC READINGS</H1> 
.................... <P>%0 
.................... <BR>%1 
.................... <P><A HREF=\"/\">Change LCD/LEDs</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... //this is a callback function to the HTTP stack.  see http.c 
.................... //this demo provides to web "pages", an index (/) and an about page (/about) 
.................... int32 http_get_page(char *file_str) { 
....................    int32 file_loc=0; 
*
47A0:  MOVLB  3
47A2:  CLRF   x14
47A4:  CLRF   x15
47A6:  CLRF   x16
47A8:  CLRF   x17
....................    static char index[]="/"; 
....................    static char about[]="/analog"; 
....................  
....................    //printf("\r\nRequest %s ",file_str); 
....................  
....................    if (stricmp(file_str,index)==0) 
47AA:  MOVFF  313,32B
47AE:  MOVFF  312,32A
47B2:  MOVLW  02
47B4:  MOVWF  x2D
47B6:  MOVLW  E8
47B8:  MOVWF  x2C
47BA:  MOVLB  0
47BC:  RCALL  4698
47BE:  MOVF   01,F
47C0:  BNZ   47D6
....................       file_loc=label_address(HTML_INDEX_PAGE); 
47C2:  MOVLW  02
47C4:  MOVWF  03
47C6:  MOVLW  5C
47C8:  MOVLB  3
47CA:  MOVWF  x14
47CC:  MOVFF  03,315
47D0:  CLRF   x16
47D2:  CLRF   x17
....................  
....................    else if (stricmp(file_str,about)==0) 
47D4:  BRA    4802
47D6:  MOVFF  313,32B
47DA:  MOVFF  312,32A
47DE:  MOVLW  02
47E0:  MOVLB  3
47E2:  MOVWF  x2D
47E4:  MOVLW  EA
47E6:  MOVWF  x2C
47E8:  MOVLB  0
47EA:  RCALL  4698
47EC:  MOVF   01,F
47EE:  BNZ   4804
....................       file_loc=label_address(HTML_ANALOG_PAGE); 
47F0:  MOVLW  04
47F2:  MOVWF  03
47F4:  MOVLW  8A
47F6:  MOVLB  3
47F8:  MOVWF  x14
47FA:  MOVFF  03,315
47FE:  CLRF   x16
4800:  CLRF   x17
4802:  MOVLB  0
....................  
....................    /*if (file_loc) 
....................       //printf("(FILE=%LU)",file_loc); 
....................    else 
....................       //printf("(File Not Found)");*/ 
....................  
....................    return(file_loc); 
4804:  MOVFF  314,00
4808:  MOVFF  315,01
480C:  MOVFF  316,02
4810:  MOVFF  317,03
.................... } 
4814:  GOTO   607A (RETURN)
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... // this demo provides handling for two formatting chars, %0 and %1. 
.................... //  %0 is ADC for channel 0, %1 is ADC for channel 1. 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) { 
....................    char new_str[20]; 
....................    int8 len=0; 
*
5706:  MOVLB  3
5708:  CLRF   x3C
....................    int8 i; 
....................  
....................    *str=0; 
570A:  MOVFF  325,FE9
570E:  MOVFF  326,FEA
5712:  CLRF   FEF
....................  
....................    switch(id) { 
5714:  MOVF   x24,W
5716:  XORLW  30
5718:  MOVLB  0
571A:  BZ    5722
571C:  XORLW  01
571E:  BZ    5790
5720:  BRA    5798
....................       case '0': 
....................          set_adc_channel(0); 
5722:  MOVLW  00
5724:  MOVWF  01
5726:  MOVF   FC2,W
5728:  ANDLW  C3
572A:  IORWF  01,W
572C:  MOVWF  FC2
....................          delay_us(100); 
572E:  MOVLW  64
5730:  MOVLB  3
5732:  MOVWF  x3E
5734:  MOVLB  0
5736:  BRA    5676
....................          i=read_adc(); 
5738:  BSF    FC2.1
573A:  BTFSC  FC2.1
573C:  BRA    573A
573E:  MOVFF  FC4,33D
5742:  MOVLB  3
....................          sprintf(new_str,"<B>AN0 = </B>0x%X",i); 
5744:  MOVLW  03
5746:  MOVLB  2
5748:  MOVWF  xF3
574A:  MOVLW  28
574C:  MOVWF  xF2
574E:  MOVLB  3
5750:  CLRF   x3E
5752:  MOVF   x3E,W
5754:  MOVLB  0
5756:  CALL   0182
575A:  MOVLB  3
575C:  INCF   x3E,F
575E:  MOVWF  00
5760:  MOVWF  x40
5762:  MOVLB  0
5764:  RCALL  569C
5766:  MOVLW  0F
5768:  MOVLB  3
576A:  SUBWF  x3E,W
576C:  BNZ   5752
576E:  MOVFF  33D,33E
5772:  MOVLW  37
5774:  MOVWF  x3F
5776:  MOVLB  0
5778:  BRA    56BE
....................          len=strlen(new_str); 
577A:  MOVLW  03
577C:  MOVLB  3
577E:  MOVWF  x3F
5780:  MOVLW  28
5782:  MOVWF  x3E
5784:  MOVLB  0
5786:  CALL   44A8
578A:  MOVFF  01,33C
....................          break; 
578E:  BRA    5798
....................  
....................       case '1': 
....................         #if STACK_USE_CCS_PICNET 
....................          set_adc_channel(1); 
....................          delay_us(100); 
....................          i=read_adc(); 
....................          sprintf(new_str,"<B>AN1 = </B>0x%X",i); 
....................          len=strlen(new_str); 
....................         #else 
....................          len=0; 
5790:  MOVLB  3
5792:  CLRF   x3C
....................         #endif 
....................          break; 
5794:  MOVLB  0
5796:  BRA    5798
....................  
....................    } 
....................  
....................    if (len) { 
5798:  MOVLB  3
579A:  MOVF   x3C,F
579C:  BZ    57C6
....................       if (len>max_ret) {len=max_ret;} 
579E:  MOVF   x3C,W
57A0:  SUBWF  x27,W
57A2:  BC    57A8
57A4:  MOVFF  327,33C
....................       memcpy(str,new_str,len); 
57A8:  MOVFF  326,FEA
57AC:  MOVFF  325,FE9
57B0:  MOVLW  03
57B2:  MOVWF  FE2
57B4:  MOVLW  28
57B6:  MOVWF  FE1
57B8:  MOVF   x3C,W
57BA:  MOVWF  01
57BC:  BZ    57C6
57BE:  MOVFF  FE6,FEE
57C2:  DECFSZ 01,F
57C4:  BRA    57BE
....................    } 
....................  
....................    return(len); 
57C6:  MOVFF  33C,01
.................... } 
57CA:  MOVLB  0
57CC:  GOTO   5AF4 (RETURN)
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... //in this example it verifies that "pwd" is "master", if it is 
.................... //then it sets led1 and led2 ("led1" and "led2") based on their value 
.................... //and changes the lcd screen ("lcd"). 
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
....................    static char led1_key[]="led1"; 
....................    static char led2_key[]="led2"; 
....................    static char lcd_key[]="lcd"; 
....................    int8 v; 
....................  
....................    //printf("\r\nCGI FILE=%LD KEY=%S VAL=%S", file, key, val); 
....................  
....................    if (stricmp(key,led1_key)==0) { 
*
4A0A:  MOVFF  326,32B
4A0E:  MOVFF  325,32A
4A12:  MOVLW  02
4A14:  MOVLB  3
4A16:  MOVWF  x2D
4A18:  MOVLW  F4
4A1A:  MOVWF  x2C
4A1C:  MOVLB  0
4A1E:  RCALL  4698
4A20:  MOVF   01,F
4A22:  BNZ   4A3E
....................       v=atoi(val); 
4A24:  MOVFF  328,32B
4A28:  MOVFF  327,32A
4A2C:  RCALL  4868
4A2E:  MOVFF  01,329
....................       if (!v) {output_low(USER_LED1);} 
4A32:  MOVLB  3
4A34:  MOVF   x29,F
4A36:  BNZ   4A3C
4A38:  BCF    F8A.5
....................       else {output_high(USER_LED1);} 
4A3A:  BRA    4A3E
4A3C:  BSF    F8A.5
....................    } 
....................  
....................    if (stricmp(key,led2_key)==0) { 
4A3E:  MOVFF  326,32B
4A42:  MOVFF  325,32A
4A46:  MOVLW  02
4A48:  MOVLB  3
4A4A:  MOVWF  x2D
4A4C:  MOVLW  F9
4A4E:  MOVWF  x2C
4A50:  MOVLB  0
4A52:  RCALL  4698
4A54:  MOVF   01,F
4A56:  BNZ   4A72
....................       v=atoi(val); 
4A58:  MOVFF  328,32B
4A5C:  MOVFF  327,32A
4A60:  RCALL  4868
4A62:  MOVFF  01,329
....................       if (!v) {output_low(USER_LED2);} 
4A66:  MOVLB  3
4A68:  MOVF   x29,F
4A6A:  BNZ   4A70
4A6C:  BCF    F8A.6
....................       else {output_high(USER_LED2);} 
4A6E:  BRA    4A72
4A70:  BSF    F8A.6
....................    } 
....................  
....................    if (stricmp(key,lcd_key)==0) { 
4A72:  MOVFF  326,32B
4A76:  MOVFF  325,32A
4A7A:  MOVLW  02
4A7C:  MOVLB  3
4A7E:  MOVWF  x2D
4A80:  MOVLW  FE
4A82:  MOVWF  x2C
4A84:  MOVLB  0
4A86:  RCALL  4698
4A88:  MOVF   01,F
4A8A:  BNZ   4A8C
....................       //printf(lcd_putc,"\f%s",val); 
....................    } 
.................... } 
4A8C:  GOTO   4AF6 (RETURN)
....................  
.................... void main(void) { 
*
6B1C:  CLRF   FF8
6B1E:  BCF    FD0.7
6B20:  BSF    08.7
6B22:  CLRF   FEA
6B24:  CLRF   FE9
6B26:  MOVF   FC1,W
6B28:  ANDLW  C0
6B2A:  IORLW  0F
6B2C:  MOVWF  FC1
6B2E:  MOVLW  07
6B30:  MOVWF  FB4
6B32:  CLRF   49
6B34:  CLRF   4A
6B36:  CLRF   50
6B38:  CLRF   51
6B3A:  CLRF   52
6B3C:  CLRF   53
6B3E:  CLRF   5A
6B40:  CLRF   5B
6B42:  CLRF   5C
6B44:  CLRF   5D
6B46:  MOVLW  04
6B48:  MOVWF  5E
6B4A:  BCF    58.1
6B4C:  MOVLB  1
6B4E:  CLRF   x15
6B50:  CLRF   x16
6B52:  CLRF   x17
6B54:  CLRF   x18
6B56:  CLRF   x19
6B58:  CLRF   x1A
6B5A:  CLRF   x1B
6B5C:  CLRF   x1C
6B5E:  CLRF   x1D
6B60:  CLRF   x1E
6B62:  CLRF   x20
6B64:  MOVLW  FE
6B66:  MOVWF  x1F
6B68:  CLRF   x20
6B6A:  MOVLW  01
6B6C:  MOVWF  x21
6B6E:  CLRF   x29
6B70:  CLRF   x2A
6B72:  CLRF   x2B
6B74:  CLRF   x2C
6B76:  CLRF   x2D
6B78:  CLRF   x2E
6B7A:  CLRF   x2F
6B7C:  CLRF   x30
6B7E:  CLRF   x31
6B80:  CLRF   x32
6B82:  CLRF   x33
6B84:  CLRF   x34
6B86:  CLRF   x35
6B88:  CLRF   x36
6B8A:  CLRF   x37
6B8C:  CLRF   x38
6B8E:  CLRF   x39
6B90:  CLRF   x3A
6B92:  CLRF   x3B
6B94:  CLRF   x3C
6B96:  CLRF   x3D
6B98:  CLRF   x3E
6B9A:  CLRF   x3F
6B9C:  CLRF   x40
6B9E:  CLRF   x41
6BA0:  CLRF   x42
6BA2:  CLRF   x43
6BA4:  CLRF   x44
6BA6:  CLRF   x45
6BA8:  CLRF   x46
6BAA:  CLRF   x47
6BAC:  CLRF   x48
6BAE:  CLRF   x49
6BB0:  CLRF   x4A
6BB2:  CLRF   x4B
6BB4:  CLRF   x4C
6BB6:  CLRF   x4D
6BB8:  CLRF   x4E
6BBA:  CLRF   x4F
6BBC:  CLRF   x50
6BBE:  CLRF   x51
6BC0:  MOVLW  20
6BC2:  MOVWF  x52
6BC4:  CLRF   x53
6BC6:  MOVLW  3F
6BC8:  MOVWF  x54
6BCA:  CLRF   x55
6BCC:  MOVLW  47
6BCE:  MOVWF  x56
6BD0:  MOVLW  45
6BD2:  MOVWF  x57
6BD4:  MOVLW  54
6BD6:  MOVWF  x58
6BD8:  CLRF   x59
6BDA:  MOVLW  50
6BDC:  MOVWF  x5A
6BDE:  MOVLW  4F
6BE0:  MOVWF  x5B
6BE2:  MOVLW  53
6BE4:  MOVWF  x5C
6BE6:  MOVLW  54
6BE8:  MOVWF  x5D
6BEA:  CLRF   x5E
6BEC:  MOVLW  43
6BEE:  MOVWF  x5F
6BF0:  MOVLW  6F
6BF2:  MOVWF  x60
6BF4:  MOVLW  6E
6BF6:  MOVWF  x61
6BF8:  MOVLW  74
6BFA:  MOVWF  x62
6BFC:  MOVLW  65
6BFE:  MOVWF  x63
6C00:  MOVLW  6E
6C02:  MOVWF  x64
6C04:  MOVLW  74
6C06:  MOVWF  x65
6C08:  MOVLW  2D
6C0A:  MOVWF  x66
6C0C:  MOVLW  4C
6C0E:  MOVWF  x67
6C10:  MOVLW  65
6C12:  MOVWF  x68
6C14:  MOVLW  6E
6C16:  MOVWF  x69
6C18:  MOVLW  67
6C1A:  MOVWF  x6A
6C1C:  MOVLW  74
6C1E:  MOVWF  x6B
6C20:  MOVLW  68
6C22:  MOVWF  x6C
6C24:  MOVLW  3A
6C26:  MOVWF  x6D
6C28:  CLRF   x6E
6C2A:  CLRF   x6F
6C2C:  CLRF   x70
6C2E:  CLRF   x71
6C30:  CLRF   x72
6C32:  CLRF   x73
6C34:  CLRF   x74
6C36:  CLRF   x75
6C38:  CLRF   x76
6C3A:  CLRF   x77
6C3C:  CLRF   x78
6C3E:  CLRF   x79
6C40:  CLRF   x7A
6C42:  CLRF   x7B
6C44:  CLRF   x7C
6C46:  CLRF   x7D
6C48:  CLRF   x7E
6C4A:  CLRF   x7F
6C4C:  CLRF   x80
6C4E:  CLRF   x81
6C50:  CLRF   x82
6C52:  CLRF   x83
6C54:  CLRF   x84
6C56:  CLRF   x85
6C58:  CLRF   x86
6C5A:  CLRF   x87
6C5C:  CLRF   x88
6C5E:  CLRF   x89
6C60:  CLRF   x8A
6C62:  CLRF   x8B
6C64:  CLRF   x8C
6C66:  CLRF   x8D
6C68:  CLRF   x8E
6C6A:  CLRF   x8F
6C6C:  CLRF   x90
6C6E:  CLRF   x91
6C70:  CLRF   x92
6C72:  CLRF   x93
6C74:  CLRF   x94
6C76:  CLRF   x95
6C78:  CLRF   x96
6C7A:  CLRF   x97
6C7C:  CLRF   x98
6C7E:  CLRF   x99
6C80:  CLRF   x9A
6C82:  CLRF   x9B
6C84:  CLRF   x9C
6C86:  CLRF   x9D
6C88:  CLRF   x9E
6C8A:  CLRF   x9F
6C8C:  CLRF   xA0
6C8E:  CLRF   xA1
6C90:  CLRF   xA2
6C92:  CLRF   xA3
6C94:  CLRF   xA4
6C96:  CLRF   xA5
6C98:  CLRF   xA6
6C9A:  CLRF   xA7
6C9C:  CLRF   xA8
6C9E:  CLRF   xA9
6CA0:  CLRF   xAA
6CA2:  CLRF   xAB
6CA4:  CLRF   xAC
6CA6:  CLRF   xAD
6CA8:  CLRF   xAE
6CAA:  CLRF   xAF
6CAC:  CLRF   xB0
6CAE:  CLRF   xB1
6CB0:  CLRF   xB2
6CB2:  CLRF   xB3
6CB4:  CLRF   xB4
6CB6:  CLRF   xB5
6CB8:  CLRF   xB6
6CBA:  CLRF   xB7
6CBC:  CLRF   xB8
6CBE:  CLRF   xB9
6CC0:  CLRF   xBA
6CC2:  CLRF   xBB
6CC4:  CLRF   xBC
6CC6:  CLRF   xBD
6CC8:  CLRF   xBE
6CCA:  CLRF   xBF
6CCC:  CLRF   xC0
6CCE:  CLRF   xC1
6CD0:  CLRF   xC2
6CD2:  CLRF   xC3
6CD4:  CLRF   xC4
6CD6:  CLRF   xC5
6CD8:  CLRF   xC6
6CDA:  CLRF   xC7
6CDC:  CLRF   xC8
6CDE:  CLRF   xC9
6CE0:  CLRF   xCA
6CE2:  CLRF   xCB
6CE4:  CLRF   xCC
6CE6:  CLRF   xCD
6CE8:  CLRF   xCE
6CEA:  CLRF   xCF
6CEC:  CLRF   xD0
6CEE:  CLRF   xD1
6CF0:  CLRF   xD2
6CF2:  CLRF   xD3
6CF4:  CLRF   xD4
6CF6:  CLRF   xD5
6CF8:  CLRF   xD6
6CFA:  CLRF   xD7
6CFC:  CLRF   xD8
6CFE:  CLRF   xD9
6D00:  CLRF   xDA
6D02:  CLRF   xDB
6D04:  CLRF   xDC
6D06:  CLRF   xDD
6D08:  CLRF   xDE
6D0A:  CLRF   xDF
6D0C:  CLRF   xE0
6D0E:  CLRF   xE1
6D10:  CLRF   xE2
6D12:  CLRF   xE3
6D14:  CLRF   xE4
6D16:  CLRF   xE5
6D18:  CLRF   xE6
6D1A:  CLRF   xE7
6D1C:  CLRF   xE8
6D1E:  CLRF   xE9
6D20:  CLRF   xEA
6D22:  CLRF   xEB
6D24:  CLRF   xEC
6D26:  CLRF   xED
6D28:  CLRF   xEE
6D2A:  CLRF   xEF
6D2C:  CLRF   xF0
6D2E:  CLRF   xF1
6D30:  CLRF   xF2
6D32:  CLRF   xF3
6D34:  CLRF   xF4
6D36:  CLRF   xF5
6D38:  CLRF   xF6
6D3A:  CLRF   xF7
6D3C:  CLRF   xF8
6D3E:  CLRF   xF9
6D40:  CLRF   xFA
6D42:  CLRF   xFB
6D44:  CLRF   xFC
6D46:  CLRF   xFD
6D48:  CLRF   xFE
6D4A:  CLRF   xFF
6D4C:  MOVLB  2
6D4E:  CLRF   x00
6D50:  CLRF   x01
6D52:  CLRF   x02
6D54:  CLRF   x03
6D56:  CLRF   x04
6D58:  CLRF   x05
6D5A:  CLRF   x06
6D5C:  CLRF   x07
6D5E:  CLRF   x08
6D60:  CLRF   x09
6D62:  CLRF   x0A
6D64:  CLRF   x0B
6D66:  CLRF   x0C
6D68:  CLRF   x0D
6D6A:  CLRF   x0E
6D6C:  CLRF   x0F
6D6E:  CLRF   x10
6D70:  CLRF   x11
6D72:  CLRF   x12
6D74:  CLRF   x13
6D76:  CLRF   x14
6D78:  CLRF   x15
6D7A:  CLRF   x16
6D7C:  CLRF   x17
6D7E:  CLRF   x18
6D80:  CLRF   x19
6D82:  CLRF   x1A
6D84:  CLRF   x1B
6D86:  CLRF   x1C
6D88:  CLRF   x1D
6D8A:  CLRF   x1E
6D8C:  CLRF   x1F
6D8E:  CLRF   x20
6D90:  CLRF   x21
6D92:  CLRF   x22
6D94:  CLRF   x23
6D96:  CLRF   x24
6D98:  CLRF   x25
6D9A:  CLRF   x26
6D9C:  CLRF   x27
6D9E:  CLRF   x28
6DA0:  CLRF   x29
6DA2:  CLRF   x2A
6DA4:  CLRF   x2B
6DA6:  CLRF   x2C
6DA8:  CLRF   x2D
6DAA:  CLRF   x2E
6DAC:  CLRF   x2F
6DAE:  CLRF   x30
6DB0:  CLRF   x31
6DB2:  CLRF   x32
6DB4:  CLRF   x33
6DB6:  CLRF   x34
6DB8:  CLRF   x35
6DBA:  CLRF   x36
6DBC:  CLRF   x37
6DBE:  CLRF   x38
6DC0:  CLRF   x39
6DC2:  CLRF   x3A
6DC4:  CLRF   x3B
6DC6:  CLRF   x3C
6DC8:  CLRF   x3D
6DCA:  CLRF   x3E
6DCC:  CLRF   x3F
6DCE:  CLRF   x40
6DD0:  CLRF   x41
6DD2:  CLRF   x42
6DD4:  CLRF   x43
6DD6:  CLRF   x44
6DD8:  CLRF   x45
6DDA:  CLRF   x46
6DDC:  CLRF   x47
6DDE:  CLRF   x48
6DE0:  CLRF   x49
6DE2:  CLRF   x4A
6DE4:  CLRF   x4B
6DE6:  CLRF   x4C
6DE8:  CLRF   x4D
6DEA:  CLRF   x4E
6DEC:  CLRF   x4F
6DEE:  CLRF   x50
6DF0:  CLRF   x51
6DF2:  CLRF   x52
6DF4:  CLRF   x53
6DF6:  CLRF   x54
6DF8:  CLRF   x55
6DFA:  CLRF   x56
6DFC:  CLRF   x57
6DFE:  CLRF   x58
6E00:  CLRF   x59
6E02:  CLRF   x5A
6E04:  CLRF   x5B
6E06:  CLRF   x5C
6E08:  CLRF   x5D
6E0A:  CLRF   x5E
6E0C:  CLRF   x5F
6E0E:  CLRF   x60
6E10:  CLRF   x61
6E12:  CLRF   x62
6E14:  CLRF   x63
6E16:  CLRF   x64
6E18:  CLRF   x65
6E1A:  CLRF   x66
6E1C:  CLRF   x67
6E1E:  CLRF   x68
6E20:  CLRF   x69
6E22:  CLRF   x6A
6E24:  CLRF   x6B
6E26:  CLRF   x6C
6E28:  CLRF   x6E
6E2A:  CLRF   x6D
6E2C:  CLRF   x6F
6E2E:  CLRF   x6E
6E30:  CLRF   x6F
6E32:  CLRF   x70
6E34:  CLRF   x71
6E36:  CLRF   x72
6E38:  CLRF   x73
6E3A:  CLRF   x74
6E3C:  CLRF   x75
6E3E:  CLRF   x76
6E40:  CLRF   x77
6E42:  CLRF   x82
6E44:  CLRF   x83
6E46:  CLRF   x84
6E48:  CLRF   x85
6E4A:  CLRF   x86
6E4C:  CLRF   x87
6E4E:  CLRF   x88
6E50:  CLRF   x89
6E52:  CLRF   x8A
6E54:  CLRF   x8B
6E56:  CLRF   x8C
6E58:  CLRF   x8D
6E5A:  CLRF   x8E
6E5C:  CLRF   x8F
6E5E:  CLRF   x90
6E60:  CLRF   x91
6E62:  CLRF   x92
6E64:  CLRF   x93
6E66:  CLRF   x94
6E68:  CLRF   x95
6E6A:  CLRF   x96
6E6C:  CLRF   x97
6E6E:  CLRF   x98
6E70:  CLRF   x99
6E72:  CLRF   x9A
6E74:  CLRF   x9B
6E76:  CLRF   x9C
6E78:  CLRF   x9D
6E7A:  CLRF   x9E
6E7C:  CLRF   x9F
6E7E:  CLRF   xA0
6E80:  CLRF   xA1
6E82:  CLRF   xA2
6E84:  CLRF   xA3
6E86:  CLRF   xA4
6E88:  CLRF   xA5
6E8A:  CLRF   xA6
6E8C:  CLRF   xA7
6E8E:  CLRF   xA8
6E90:  CLRF   xA9
6E92:  CLRF   xAA
6E94:  CLRF   xAB
6E96:  CLRF   xAC
6E98:  CLRF   xAD
6E9A:  CLRF   xAE
6E9C:  CLRF   xAF
6E9E:  CLRF   xB0
6EA0:  CLRF   xB1
6EA2:  CLRF   xB2
6EA4:  CLRF   xB3
6EA6:  CLRF   xB4
6EA8:  CLRF   xB5
6EAA:  CLRF   xB6
6EAC:  CLRF   xB7
6EAE:  CLRF   xB8
6EB0:  CLRF   xB9
6EB2:  CLRF   xBA
6EB4:  CLRF   xBB
6EB6:  CLRF   xBC
6EB8:  CLRF   xBD
6EBA:  CLRF   xBE
6EBC:  CLRF   xBF
6EBE:  CLRF   xC0
6EC0:  CLRF   xC1
6EC2:  CLRF   xC2
6EC4:  CLRF   xC3
6EC6:  CLRF   xC4
6EC8:  CLRF   xC5
6ECA:  CLRF   xC6
6ECC:  CLRF   xC7
6ECE:  MOVLW  45
6ED0:  MOVWF  xC8
6ED2:  CLRF   xC9
6ED4:  CLRF   xCA
6ED6:  MOVLW  20
6ED8:  MOVWF  xCB
6EDA:  CLRF   xCC
6EDC:  CLRF   xCD
6EDE:  CLRF   xCE
6EE0:  CLRF   xCF
6EE2:  MOVLW  64
6EE4:  MOVWF  xD0
6EE6:  MOVLW  11
6EE8:  MOVWF  xD1
6EEA:  MOVLW  2A
6EEC:  MOVWF  xD2
6EEE:  MOVLW  9D
6EF0:  MOVWF  xD3
6EF2:  MOVLW  0A
6EF4:  MOVWF  xD4
6EF6:  MOVLW  0B
6EF8:  MOVWF  xD5
6EFA:  MOVLW  0C
6EFC:  MOVWF  xD6
6EFE:  MOVLW  0D
6F00:  MOVWF  xD7
6F02:  MOVLW  0A
6F04:  MOVWF  xD8
6F06:  MOVLW  0B
6F08:  MOVWF  xD9
6F0A:  MOVLW  0C
6F0C:  MOVWF  xDA
6F0E:  MOVLW  0E
6F10:  MOVWF  xDB
6F12:  MOVLW  04
6F14:  MOVWF  xDC
6F16:  CLRF   xDD
6F18:  MOVWF  xDE
6F1A:  MOVLW  01
6F1C:  MOVWF  xDF
6F1E:  CLRF   xE0
6F20:  MOVLW  08
6F22:  MOVWF  xE1
6F24:  CLRF   xE2
6F26:  CLRF   xE3
6F28:  MOVLW  01
6F2A:  MOVWF  xE4
6F2C:  MOVLW  02
6F2E:  MOVWF  xE5
6F30:  MOVLW  03
6F32:  MOVWF  xE6
6F34:  MOVLW  04
6F36:  MOVWF  xE7
6F38:  MOVLW  2F
6F3A:  MOVWF  xE8
6F3C:  CLRF   xE9
6F3E:  MOVWF  xEA
6F40:  MOVLW  61
6F42:  MOVWF  xEB
6F44:  MOVLW  6E
6F46:  MOVWF  xEC
6F48:  MOVLW  61
6F4A:  MOVWF  xED
6F4C:  MOVLW  6C
6F4E:  MOVWF  xEE
6F50:  MOVLW  6F
6F52:  MOVWF  xEF
6F54:  MOVLW  67
6F56:  MOVWF  xF0
6F58:  CLRF   xF1
6F5A:  CLRF   xF2
6F5C:  CLRF   xF3
6F5E:  MOVLW  6C
6F60:  MOVWF  xF4
6F62:  MOVLW  65
6F64:  MOVWF  xF5
6F66:  MOVLW  64
6F68:  MOVWF  xF6
6F6A:  MOVLW  31
6F6C:  MOVWF  xF7
6F6E:  CLRF   xF8
6F70:  MOVLW  6C
6F72:  MOVWF  xF9
6F74:  MOVLW  65
6F76:  MOVWF  xFA
6F78:  MOVLW  64
6F7A:  MOVWF  xFB
6F7C:  MOVLW  32
6F7E:  MOVWF  xFC
6F80:  CLRF   xFD
6F82:  MOVLW  6C
6F84:  MOVWF  xFE
6F86:  MOVLW  63
6F88:  MOVWF  xFF
6F8A:  MOVLW  64
6F8C:  MOVLB  3
6F8E:  MOVWF  x00
6F90:  CLRF   x01
....................    MACAddrInit(); 
6F92:  MOVLB  0
6F94:  GOTO   0552
....................    IPAddrInit(); 
6F98:  GOTO   056C
....................  
....................    init_user_io(); 
6F9C:  GOTO   0596
....................  
....................    //lcd_init();                                    //ALUX: 
....................    //printf(lcd_putc,"\fCCS CGI Example\nWaiting"); //ALUX: 
....................    //printf("\r\n\nCCS CGI Example\r\nWaiting");    //ALUX: 
....................  
....................    set_adc_channel(0); 
6FA0:  MOVLW  00
6FA2:  MOVWF  01
6FA4:  MOVF   FC2,W
6FA6:  ANDLW  C3
6FA8:  IORWF  01,W
6FAA:  MOVWF  FC2
....................  
....................    StackInit(); 
6FAC:  GOTO   0EAC
....................  
....................    while(TRUE) { 
....................       StackTask(); 
6FB0:  BRA    6924
....................    } 
6FB2:  BRA    6FB0
.................... } 
6FB4:  SLEEP 

Configuration Fuses:
   Word  1: 0E29   NOIESO NOFCMEN HSPLL PLL2 CPUDIV2 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8100   NOPBADEN CCP2C1 MCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
