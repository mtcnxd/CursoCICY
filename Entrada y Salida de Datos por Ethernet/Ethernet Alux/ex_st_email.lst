CCS PCH C Compiler, Version 4.099, 49659               15-feb-11 09:14

               Filename: C:\Otros Ejemplos Ethernet\ex_st_email.lst

               ROM used: 39870 bytes (61%)
                         Largest free fragment is 25664
               RAM used: 863 (22%) at main() level
                         1046 (26%) worst case
               Stack:    12 worst case (11 in main + 1 for interrupts)

*
00000:  GOTO   997E
*
00008:  MOVWF  05
0000A:  MOVFF  FD8,06
0000E:  MOVFF  FE0,07
00012:  MOVLB  0
00014:  MOVFF  FE9,0D
00018:  MOVFF  FEA,08
0001C:  MOVFF  FE1,09
00020:  MOVFF  FE2,0A
00024:  MOVFF  FD9,0B
00028:  MOVFF  FDA,0C
0002C:  MOVFF  FF3,14
00030:  MOVFF  FF4,15
00034:  MOVFF  FFA,16
00038:  MOVFF  00,0F
0003C:  MOVFF  01,10
00040:  MOVFF  02,11
00044:  MOVFF  03,12
00048:  MOVFF  04,13
0004C:  BTFSS  FF2.5
0004E:  GOTO   0058
00052:  BTFSC  FF2.2
00054:  GOTO   0D80
00058:  MOVFF  0F,00
0005C:  MOVFF  10,01
00060:  MOVFF  11,02
00064:  MOVFF  12,03
00068:  MOVFF  13,04
0006C:  MOVFF  0D,FE9
00070:  MOVFF  08,FEA
00074:  BSF    08.7
00076:  MOVFF  09,FE1
0007A:  MOVFF  0A,FE2
0007E:  MOVFF  0B,FD9
00082:  MOVFF  0C,FDA
00086:  MOVFF  14,FF3
0008A:  MOVFF  15,FF4
0008E:  MOVFF  16,FFA
00092:  MOVF   05,W
00094:  MOVFF  07,FE0
00098:  MOVFF  06,FD8
0009C:  RETFIE 0
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         EX_ST_EMAIL.C                             //// 
.................... ////                                                                   //// 
.................... //// An example program demonstrating using Microchip's TCP/IP stack   //// 
.................... //// with CCS's PCH C Compiler.                                        //// 
.................... ////                                                                   //// 
.................... //// You can send an e-mail by either pressing the button or using     //// 
.................... //// the serial interface.  Make sure your TCP/IP is connected         //// 
.................... //// properly before trying to send an e-mail.  You will see debug     //// 
.................... //// information about the SMTP session using the serial link.         //// 
.................... ////                                                                   //// 
.................... //// Use the serial link to setup the SMTP settings, such as the       //// 
.................... //// IP address of the STMP server, the TCP/IP port to use, and        //// 
.................... //// the body, subject, to and from address of the e-mail.             //// 
.................... ////                                                                   //// 
.................... //// If you are having problems, try telneting into your SMTP server   //// 
.................... //// and manually sending an e-mail using the proper SMTP commands     //// 
.................... //// to make sure they work.  To fight the war on spam, many SMTP      //// 
.................... //// servers are locking down to prevent un-authorized users.          //// 
.................... ////                                                                   //// 
.................... //// LCD display is not used you are using a Microchip PICDEM.net      //// 
.................... //// board with a PIC18F452 because there wasn't enough program memory //// 
.................... //// to fit this.                                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// ABOUT CCS TCP/IP EXAMPLES:                                        //// 
.................... ////                                                                   //// 
.................... //// Connect your prototype board to serial cable, and open a serial   //// 
.................... //// connection at 9600bps.  With this link you can change all the     //// 
.................... //// ethernet and PPP settings.  You can also see the current status   //// 
.................... //// of the TCP/IP link.  Pressing any key will bring up the menu.     //// 
.................... ////                                                                   //// 
.................... //// If you are using PPP, you will need to initiate and disconnect a  //// 
.................... //// PPP connection using this serial link.  Until PPP is connected    //// 
.................... //// the board will not be connected to TCP/IP.                        //// 
.................... ////                                                                   //// 
.................... //// If the LCD is enabled in the code (it is enabled by default), the //// 
.................... //// last line displayed will be IP address of the unit.  If your      //// 
.................... //// ISP / Network doesn't filter ICMP/PING you can use the PING       //// 
.................... //// utility to test your connection.  If the last line doesn't        //// 
.................... //// display the IP address then the unit is connected (PPP not        //// 
.................... //// connected, ethernet cable not connected, a problem with ethernet  //// 
.................... //// DHCP, etc).                                                       //// 
.................... ////                                                                   //// 
.................... //// CAUTION: All settings are saved to the external EEPROM.  If you   //// 
.................... //// are using the Microchip PICDEM.net board that has an example      //// 
.................... //// file-system with webpages it will be deleted/corrupted by these   //// 
.................... //// examples.                                                         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// Sep 20, 2006 -                                                    //// 
.................... ////     Updated and tested with Microchip's 3.02 stack.               //// 
.................... ////                                                                   //// 
.................... //// Mar 06, 2006 -                                                    //// 
.................... ////     Updated for CCS PICENS Board                                  //// 
.................... ////                                                                   //// 
.................... //// Mar 06, 2004 -                                                    //// 
.................... ////     Initial Public Release                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //quick auto configure for different tcp/ip demo boards 
.................... #define STACK_USE_CCS_PICNET        0  //PICNET rev 0-2 board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F6620 
.................... #define STACK_USE_CCS_PICNET3       0  //PICNET rv 3 and up board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F8622 
.................... #define STACK_USE_CCS_PICENS        1  //CCS PICENS (Embedded Ethernet) development kit.  18F4620 + ENC28J60 
.................... #define STACK_USE_CCS_PICEEC        0  //CCS PICEEC (Embedded Ethernet) development kit.  18F67J60 
....................  
.................... //You must set one (and only) one of these to TRUE to tell the stack what hardware layer you are using 
.................... #define STACK_USE_MAC   1      //use the nic card 
.................... #define STACK_USE_PPP   0     //use PPP on modem 
.................... #define STACK_USE_SLIP  0    //use slip (NOT TESTED) 
....................  
.................... /// *** END USER CONFIGURABLE DEFINITIONS 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC>1) 
....................  #error You can only use one hardware definition 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC==0) 
....................  #error You must define one hardware definition 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET3 
....................  #undef STACK_USE_CCS_PICNET 
....................  #define STACK_USE_CCS_PICNET 1 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_CCS_PICNET3 
....................  #include <18f6722.h> 
....................  #use delay(clock=40000000 
....................  #fuses H4 
....................  #fuses CCP2C1 
....................  #fuses MCLR 
.................... #elif STACK_USE_CCS_PICNET 
....................  #include <18f6720.h> 
....................  #use delay(clock=20000000) //CCS picnet is 20Mhz 
....................  #fuses HS 
....................  #fuses CCP2C1 
.................... #elif STACK_USE_CCS_PICENS 
....................  #include <18f4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
....................  #use delay(clock=40000000) 
*
00DF4:  MOVLW  03
00DF6:  MOVWF  FEA
00DF8:  MOVLW  65
00DFA:  MOVWF  FE9
00DFC:  MOVF   FEF,W
00DFE:  BZ    0E1C
00E00:  MOVLW  0C
00E02:  MOVWF  01
00E04:  CLRF   00
00E06:  DECFSZ 00,F
00E08:  BRA    0E06
00E0A:  DECFSZ 01,F
00E0C:  BRA    0E04
00E0E:  MOVLW  F7
00E10:  MOVWF  00
00E12:  DECFSZ 00,F
00E14:  BRA    0E12
00E16:  BRA    0E18
00E18:  DECFSZ FEF,F
00E1A:  BRA    0E00
00E1C:  RETLW  00
....................  #fuses H4 
....................  #fuses NOFCMEN 
....................  #fuses NOXINST 
....................  #fuses NOIESO 
....................  #fuses NOPBADEN 
....................  #fuses MCLR 
.................... #elif STACK_USE_CCS_PICEEC 
....................  #include <18F67J60.H> 
....................  #use delay(clock=25M) 
....................  #fuses HS 
....................  #fuses NOIESO 
....................  #fuses NOFCMEN 
....................  #fuses PRIMARY 
....................  #fuses ETHLEDNOEMB 
.................... #endif 
....................  
.................... #fuses NOWDT 
.................... #fuses NOPROTECT 
.................... #fuses NODEBUG 
.................... #fuses NOSTVREN 
....................  
.................... #if !STACK_USE_CCS_PICEEC 
....................  #fuses PUT 
....................  #fuses NOLVP 
....................  #fuses NOBROWNOUT 
....................  #fuses NOCPD 
....................  #fuses WRT 
....................  #fuses NOWRTD 
....................  #fuses NOEBTR 
....................  #fuses NOCPB 
....................  #fuses NOEBTRB 
....................  #fuses WRTB 
.................... #endif 
....................  
.................... #define STACK_USE_PICDEM_LCD     TRUE     //set to true to put out information on the LCD screen 
....................  
.................... #if STACK_USE_MAC 
....................  #define STACK_USE_DHCP  TRUE  //for auto resolution of IP address 
....................  #define STACK_USE_ARP   TRUE  //needed to resolve MAC addresses of IP addresses 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICENS && STACK_USE_MAC 
....................  #define STACK_USE_MCPENC  TRUE     //tell the stack to use the ENC28J60 driver 
.................... #else 
....................  #define STACK_USE_MCPENC  FALSE    //tell the stack to use the Realtek driver 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICEEC && STACK_USE_MAC 
....................  #define STACK_USE_MCPINC  TRUE 
.................... #else 
....................  #define STACK_USE_MCPINC  FALSE 
.................... #endif 
....................  
.................... #define STACK_USE_UDP         TRUE   //needed for dhcp & dns 
.................... #define STACK_USE_DNS         TRUE   //we shall use DNS in this example 
.................... #define STACK_USE_ICMP        TRUE   //for ping 
.................... #define STACK_USE_TCP         TRUE   //To send TCP packets (talk to HTTP clients) 
.................... #define STACK_USE_SMTP        TRUE   //enable the CCS SMTP Engine 
.................... #define STACK_USE_IP_GLEANING FALSE 
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, STREAM=USER) 
.................... #define debug_printf   printf 
....................  
.................... #include "tcpip/stacktsk.c"    //include Microchip's TCP/IP stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... /*#ifndef STACK_USE_CCS_PICNET         //ALUX: 
.................... #define STACK_USE_CCS_PICNET  FALSE    //ALUX: 
.................... #endif                                 //ALUX: 
....................  
.................... #ifndef STACK_USE_CCS_PICENS           //ALUX: 
.................... #define STACK_USE_CCS_PICENS  FALSE    //ALUX: 
.................... #endif*/                               //ALUX: 
....................  
.................... #use fast_io(A)                        //ALUX: 
.................... #use fast_io(B)                        //ALUX: 
.................... #use fast_io(C)                        //ALUX: 
.................... //#use fast_io(D)                      //ALUX: 
.................... //#use fast_io(E)                      //ALUX:    
.................... /*#if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC //ALUX: 
....................  #use fast_io(F)                                   //ALUX: 
.................... #endif*/                                           //ALUX: 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS.                       //ALUX: 
.................... /*   #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   60000    //time to wait for modem to make a connection (in ms) 
.................... */ 
....................  
.................... //// VARIOUS MAC/NIC SETTINGS.               //ALUX: 
.................... /*   #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................   NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 */ 
....................   
....................                                         //SE MODIFICARON TODOS LOS PINES ORIGINALES PARA TARJETA ALUX 1.1 
....................   #ifdef STACK_USE_CCS_PICENS           //#elif se cambio por #ifdef 
....................       #define PIN_ENC_MAC_SO  PIN_B0    // PIC <<<< ENC  //ANTES C4 
....................       #define PIN_ENC_MAC_SI  PIN_C7    // PIC >>>> ENC  //ANTES C5 
....................       #define PIN_ENC_MAC_CLK PIN_B1    // ANTES C3 
....................       #define PIN_ENC_MAC_CS  PIN_C1    // ANTES D1 
....................       #define PIN_ENC_MAC_RST PIN_C0    // ANTES D0 
....................       #define PIN_ENC_MAC_INT PIN_B2    // ANTES B0 
....................       #define PIN_ENC_MAC_WOL PIN_B3    // ANTES B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()    *0xF93=(*0xF93 & 0b11111101) | 0b101; *0xF94 = *0xF94 & 0x7C;   //SE MODIFICO PARA ALUX 1.1 
....................       //#elif STACK_USE_CCS_PICEEC 
....................       //no hardware definitions - everything is internal 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
....................  
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03808:  MOVLB  3
0380A:  CLRF   xB4
....................    sign = 0; 
0380C:  CLRF   xB2
....................    base = 10; 
0380E:  MOVLW  0A
03810:  MOVWF  xB3
....................    result = 0; 
03812:  CLRF   xB1
03814:  CLRF   xB0
....................  
....................    if (!s) 
03816:  MOVF   xAE,W
03818:  IORWF  xAF,W
0381A:  BNZ   3824
....................       return 0; 
0381C:  MOVLW  00
0381E:  MOVWF  01
03820:  MOVWF  02
03822:  BRA    39F4
....................    c = s[index++]; 
03824:  MOVF   xB4,W
03826:  INCF   xB4,F
03828:  CLRF   03
0382A:  ADDWF  xAE,W
0382C:  MOVWF  FE9
0382E:  MOVF   xAF,W
03830:  ADDWFC 03,W
03832:  MOVWF  FEA
03834:  MOVFF  FEF,3B5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03838:  MOVF   xB5,W
0383A:  SUBLW  2D
0383C:  BNZ   3858
....................    { 
....................       sign = 1;         // Set the sign to negative 
0383E:  MOVLW  01
03840:  MOVWF  xB2
....................       c = s[index++]; 
03842:  MOVF   xB4,W
03844:  INCF   xB4,F
03846:  CLRF   03
03848:  ADDWF  xAE,W
0384A:  MOVWF  FE9
0384C:  MOVF   xAF,W
0384E:  ADDWFC 03,W
03850:  MOVWF  FEA
03852:  MOVFF  FEF,3B5
....................    } 
....................    else if (c == '+') 
03856:  BRA    3872
03858:  MOVF   xB5,W
0385A:  SUBLW  2B
0385C:  BNZ   3872
....................    { 
....................       c = s[index++]; 
0385E:  MOVF   xB4,W
03860:  INCF   xB4,F
03862:  CLRF   03
03864:  ADDWF  xAE,W
03866:  MOVWF  FE9
03868:  MOVF   xAF,W
0386A:  ADDWFC 03,W
0386C:  MOVWF  FEA
0386E:  MOVFF  FEF,3B5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03872:  MOVF   xB5,W
03874:  SUBLW  2F
03876:  BTFSC  FD8.0
03878:  BRA    39D8
0387A:  MOVF   xB5,W
0387C:  SUBLW  39
0387E:  BTFSS  FD8.0
03880:  BRA    39D8
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
03882:  MOVF   xB5,W
03884:  SUBLW  30
03886:  BNZ   38CA
03888:  CLRF   03
0388A:  MOVF   xB4,W
0388C:  ADDWF  xAE,W
0388E:  MOVWF  FE9
03890:  MOVF   xAF,W
03892:  ADDWFC 03,W
03894:  MOVWF  FEA
03896:  MOVF   FEF,W
03898:  SUBLW  78
0389A:  BZ    38B0
0389C:  CLRF   03
0389E:  MOVF   xB4,W
038A0:  ADDWF  xAE,W
038A2:  MOVWF  FE9
038A4:  MOVF   xAF,W
038A6:  ADDWFC 03,W
038A8:  MOVWF  FEA
038AA:  MOVF   FEF,W
038AC:  SUBLW  58
038AE:  BNZ   38CA
....................       { 
....................          base = 16; 
038B0:  MOVLW  10
038B2:  MOVWF  xB3
....................          index++; 
038B4:  INCF   xB4,F
....................          c = s[index++]; 
038B6:  MOVF   xB4,W
038B8:  INCF   xB4,F
038BA:  CLRF   03
038BC:  ADDWF  xAE,W
038BE:  MOVWF  FE9
038C0:  MOVF   xAF,W
038C2:  ADDWFC 03,W
038C4:  MOVWF  FEA
038C6:  MOVFF  FEF,3B5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
038CA:  MOVF   xB3,W
038CC:  SUBLW  0A
038CE:  BNZ   3916
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
038D0:  MOVF   xB5,W
038D2:  SUBLW  2F
038D4:  BC    3914
038D6:  MOVF   xB5,W
038D8:  SUBLW  39
038DA:  BNC   3914
....................             result = 10*result + (c - '0'); 
038DC:  CLRF   xB7
038DE:  MOVLW  0A
038E0:  MOVWF  xB6
038E2:  MOVFF  3B1,3B9
038E6:  MOVFF  3B0,3B8
038EA:  MOVLB  0
038EC:  RCALL  37E6
038EE:  MOVLW  30
038F0:  MOVLB  3
038F2:  SUBWF  xB5,W
038F4:  ADDWF  01,W
038F6:  MOVWF  xB0
038F8:  MOVLW  00
038FA:  ADDWFC 02,W
038FC:  MOVWF  xB1
....................             c = s[index++]; 
038FE:  MOVF   xB4,W
03900:  INCF   xB4,F
03902:  CLRF   03
03904:  ADDWF  xAE,W
03906:  MOVWF  FE9
03908:  MOVF   xAF,W
0390A:  ADDWFC 03,W
0390C:  MOVWF  FEA
0390E:  MOVFF  FEF,3B5
....................          } 
03912:  BRA    38D0
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
03914:  BRA    39D8
03916:  MOVF   xB3,W
03918:  SUBLW  10
0391A:  BNZ   39D8
....................       { 
....................          c = toupper(c); 
0391C:  MOVF   xB5,W
0391E:  SUBLW  60
03920:  BC    392E
03922:  MOVF   xB5,W
03924:  SUBLW  7A
03926:  BNC   392E
03928:  MOVF   xB5,W
0392A:  ANDLW  DF
0392C:  BRA    3930
0392E:  MOVF   xB5,W
03930:  MOVWF  xB5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
03932:  MOVF   xB5,W
03934:  SUBLW  2F
03936:  BC    393E
03938:  MOVF   xB5,W
0393A:  SUBLW  39
0393C:  BC    394A
0393E:  MOVF   xB5,W
03940:  SUBLW  40
03942:  BC    39D8
03944:  MOVF   xB5,W
03946:  SUBLW  46
03948:  BNC   39D8
....................             if (c >= '0' && c <= '9') 
0394A:  MOVF   xB5,W
0394C:  SUBLW  2F
0394E:  BC    3982
03950:  MOVF   xB5,W
03952:  SUBLW  39
03954:  BNC   3982
....................                result = (result << 4) + (c - '0'); 
03956:  RLCF   xB0,W
03958:  MOVWF  xB6
0395A:  RLCF   xB1,W
0395C:  MOVWF  xB7
0395E:  RLCF   xB6,F
03960:  RLCF   xB7,F
03962:  RLCF   xB6,F
03964:  RLCF   xB7,F
03966:  RLCF   xB6,F
03968:  RLCF   xB7,F
0396A:  MOVLW  F0
0396C:  ANDWF  xB6,F
0396E:  MOVLW  30
03970:  SUBWF  xB5,W
03972:  ADDWF  xB6,W
03974:  MOVWF  01
03976:  MOVLW  00
03978:  ADDWFC xB7,W
0397A:  MOVFF  01,3B0
0397E:  MOVWF  xB1
....................             else 
03980:  BRA    39AE
....................                result = (result << 4) + (c - 'A' + 10); 
03982:  RLCF   xB0,W
03984:  MOVWF  xB6
03986:  RLCF   xB1,W
03988:  MOVWF  xB7
0398A:  RLCF   xB6,F
0398C:  RLCF   xB7,F
0398E:  RLCF   xB6,F
03990:  RLCF   xB7,F
03992:  RLCF   xB6,F
03994:  RLCF   xB7,F
03996:  MOVLW  F0
03998:  ANDWF  xB6,F
0399A:  MOVLW  41
0399C:  SUBWF  xB5,W
0399E:  ADDLW  0A
039A0:  ADDWF  xB6,W
039A2:  MOVWF  01
039A4:  MOVLW  00
039A6:  ADDWFC xB7,W
039A8:  MOVFF  01,3B0
039AC:  MOVWF  xB1
....................  
....................             c = s[index++];c = toupper(c); 
039AE:  MOVF   xB4,W
039B0:  INCF   xB4,F
039B2:  CLRF   03
039B4:  ADDWF  xAE,W
039B6:  MOVWF  FE9
039B8:  MOVF   xAF,W
039BA:  ADDWFC 03,W
039BC:  MOVWF  FEA
039BE:  MOVF   FEF,W
039C0:  MOVWF  xB5
039C2:  SUBLW  60
039C4:  BC    39D2
039C6:  MOVF   xB5,W
039C8:  SUBLW  7A
039CA:  BNC   39D2
039CC:  MOVF   xB5,W
039CE:  ANDLW  DF
039D0:  BRA    39D4
039D2:  MOVF   xB5,W
039D4:  MOVWF  xB5
....................          } 
039D6:  BRA    3932
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
039D8:  MOVF   xB3,W
039DA:  SUBLW  0A
039DC:  BNZ   39EC
039DE:  DECFSZ xB2,W
039E0:  BRA    39EC
....................       result = -result; 
039E2:  COMF   xB0,F
039E4:  COMF   xB1,F
039E6:  INCF   xB0,F
039E8:  BTFSC  FD8.2
039EA:  INCF   xB1,F
....................  
....................    return(result); 
039EC:  MOVFF  3B0,01
039F0:  MOVFF  3B1,02
.................... } 
039F4:  MOVLB  0
039F6:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01722:  MOVFF  4E,365
01726:  MOVFF  4D,364
0172A:  MOVFF  4C,363
0172E:  MOVFF  4B,362
01732:  MOVLW  41
01734:  MOVLB  3
01736:  MOVWF  x69
01738:  MOVLW  C6
0173A:  MOVWF  x68
0173C:  MOVLW  4E
0173E:  MOVWF  x67
01740:  MOVLW  6D
01742:  MOVWF  x66
01744:  MOVLB  0
01746:  BRA    167C
01748:  MOVLW  39
0174A:  MOVLB  3
0174C:  ADDWF  00,W
0174E:  MOVWF  4B
01750:  MOVLW  30
01752:  ADDWFC 01,W
01754:  MOVWF  4C
01756:  MOVLW  00
01758:  ADDWFC 02,W
0175A:  MOVWF  4D
0175C:  MOVLW  00
0175E:  ADDWFC 03,W
01760:  MOVWF  4E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
01762:  MOVFF  4D,00
01766:  MOVFF  4E,01
0176A:  CLRF   02
0176C:  CLRF   03
0176E:  MOVFF  4E,364
01772:  MOVFF  4D,363
01776:  MOVFF  4E,366
0177A:  MOVFF  4D,365
0177E:  MOVLW  7F
01780:  MOVWF  x68
01782:  MOVLW  FF
01784:  MOVWF  x67
01786:  MOVLB  0
01788:  BRA    16DA
0178A:  MOVFF  00,01
0178E:  MOVFF  03,02
.................... } 
01792:  GOTO   18A8 (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01668:  MOVFF  365,4E
0166C:  MOVFF  364,4D
01670:  MOVFF  363,4C
01674:  MOVFF  362,4B
.................... } 
01678:  GOTO   18A6 (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
01CDA:  MOVFF  40B,40C
....................     new.v[1]=v.v[0]; 
01CDE:  MOVFF  40A,40D
....................  
....................     return(new.Val); 
01CE2:  MOVLB  4
01CE4:  MOVFF  40C,01
01CE8:  MOVFF  40D,02
.................... } 
01CEC:  MOVLB  0
01CEE:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
01CF0:  MOVFF  3F6,3F7
....................     new.v[1]=v.v[2]; 
01CF4:  MOVFF  3F5,3F8
....................     new.v[2]=v.v[1]; 
01CF8:  MOVFF  3F4,3F9
....................     new.v[3]=v.v[0]; 
01CFC:  MOVFF  3F3,3FA
....................  
....................     return(new.Val); 
01D00:  MOVFF  3F7,00
01D04:  MOVFF  3F8,01
01D08:  MOVFF  3F9,02
01D0C:  MOVFF  3FA,03
.................... } 
01D10:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
01F2E:  MOVLB  3
01F30:  CLRF   xFC
01F32:  CLRF   xFB
01F34:  CLRF   xFA
01F36:  CLRF   xF9
....................  
.................... 	i = count >> 1; 
01F38:  BCF    FD8.0
01F3A:  RRCF   xF0,W
01F3C:  MOVWF  xF2
01F3E:  RRCF   xEF,W
01F40:  MOVWF  xF1
.................... 	val = (WORD *)buffer; 
01F42:  MOVFF  3EE,3F4
01F46:  MOVFF  3ED,3F3
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
01F4A:  MOVFF  3F2,03
01F4E:  MOVF   xF1,W
01F50:  BTFSC  FD8.2
01F52:  DECF   xF2,F
01F54:  DECF   xF1,F
01F56:  IORWF  03,W
01F58:  BZ    1F88
01F5A:  MOVFF  3F4,03
01F5E:  MOVFF  3F3,00
01F62:  MOVLW  02
01F64:  ADDWF  xF3,F
01F66:  BTFSC  FD8.0
01F68:  INCF   xF4,F
01F6A:  MOVFF  00,FE9
01F6E:  MOVFF  03,FEA
01F72:  MOVFF  FEC,03
01F76:  MOVF   FED,F
01F78:  MOVF   FEF,W
01F7A:  ADDWF  xF9,F
01F7C:  MOVF   03,W
01F7E:  ADDWFC xFA,F
01F80:  MOVLW  00
01F82:  ADDWFC xFB,F
01F84:  ADDWFC xFC,F
01F86:  BRA    1F4A
....................  
.................... 	if ( count & 1 ) 
01F88:  MOVF   xEF,W
01F8A:  ANDLW  01
01F8C:  MOVWF  00
01F8E:  CLRF   03
01F90:  MOVF   00,W
01F92:  IORWF  03,W
01F94:  BZ    1FAA
.................... 		sum.Val += *(BYTE *)val; 
01F96:  MOVFF  3F3,FE9
01F9A:  MOVFF  3F4,FEA
01F9E:  MOVF   FEF,W
01FA0:  ADDWF  xF9,F
01FA2:  MOVLW  00
01FA4:  ADDWFC xFA,F
01FA6:  ADDWFC xFB,F
01FA8:  ADDWFC xFC,F
....................  
.................... 	tempSum.Val = sum.Val; 
01FAA:  MOVFF  3FC,3F8
01FAE:  MOVFF  3FB,3F7
01FB2:  MOVFF  3FA,3F6
01FB6:  MOVFF  3F9,3F5
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
01FBA:  MOVFF  3F8,3F2
01FBE:  MOVFF  3F7,3F1
01FC2:  MOVF   xF1,F
01FC4:  BNZ   1FCA
01FC6:  MOVF   xF2,F
01FC8:  BZ    2010
.................... 		sum.words.MSB.Val = 0; 
01FCA:  CLRF   xFC
01FCC:  CLRF   xFB
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
01FCE:  MOVLB  4
01FD0:  CLRF   x00
01FD2:  MOVLB  3
01FD4:  CLRF   xFF
01FD6:  MOVFF  3FA,3FE
01FDA:  MOVFF  3F9,3FD
01FDE:  CLRF   02
01FE0:  CLRF   03
01FE2:  MOVF   xF1,W
01FE4:  ADDWF  xF9,W
01FE6:  MOVWF  xF9
01FE8:  MOVF   xF2,W
01FEA:  ADDWFC xFA,W
01FEC:  MOVWF  xFA
01FEE:  MOVF   02,W
01FF0:  ADDWFC xFF,W
01FF2:  MOVWF  xFB
01FF4:  MOVF   03,W
01FF6:  MOVLB  4
01FF8:  ADDWFC x00,W
01FFA:  MOVLB  3
01FFC:  MOVWF  xFC
.................... 		tempSum.Val = sum.Val; 
01FFE:  MOVFF  3FC,3F8
02002:  MOVFF  3FB,3F7
02006:  MOVFF  3FA,3F6
0200A:  MOVFF  3F9,3F5
.................... 	} 
0200E:  BRA    1FBA
....................  
.................... 	return (~sum.words.LSB.Val); 
02010:  MOVFF  3FA,03
02014:  COMF   03,F
02016:  MOVF   xF9,W
02018:  XORLW  FF
0201A:  MOVWF  01
0201C:  MOVFF  03,02
.................... } 
02020:  MOVLB  0
02022:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
010FC:  MOVLW  83
010FE:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
01100:  MOVLW  0B
01102:  MOVWF  FD7
01104:  MOVLW  DB
01106:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
01108:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
0110A:  MOVLW  C0
0110C:  IORWF  FF2,F
.................... } 
0110E:  GOTO   2BF4 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
0514A:  BCF    FF2.5
....................     ret=TickCount; 
0514C:  MOVFF  51,3B2
05150:  MOVFF  50,3B1
....................     enable_interrupts(INT_TIMER0); 
05154:  BSF    FF2.5
....................     return ret; 
05156:  MOVLB  3
05158:  MOVFF  3B1,01
0515C:  MOVFF  3B2,02
.................... } 
05160:  MOVLB  0
05162:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00D80:  INCF   50,F
00D82:  BTFSC  FD8.2
00D84:  INCF   51,F
....................  
....................         second_counter_intermediate++; 
00D86:  INCF   53,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00D88:  MOVF   53,W
00D8A:  SUBLW  09
00D8C:  BC    0D92
....................             second_counter++; //increment this ever 1s 
00D8E:  INCF   52,F
....................             second_counter_intermediate=0; 
00D90:  CLRF   53
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00D92:  MOVLW  0B
00D94:  MOVWF  FD7
00D96:  MOVLW  DB
00D98:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO               //SE MODIFICARON TODOS LOS PINES PARA TRABAJO CON ALUX 1.1 
....................       #define PIN_ENC_MAC_SO  PIN_B0    //PIC <<<< ENC  //ANTES C4 
....................       #define PIN_ENC_MAC_SI  PIN_C7    //PIC >>>> ENC  //ANTES C5 
....................       #define PIN_ENC_MAC_CLK PIN_B1    //ANTES C3 
....................       #define PIN_ENC_MAC_CS  PIN_C1    //ANTES D1 
....................       #define PIN_ENC_MAC_RST PIN_C0    //ANTES D0 
....................       #define PIN_ENC_MAC_INT PIN_B2    //ANTES B0 
....................       #define PIN_ENC_MAC_WOL PIN_B3    //ANTES B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()    *0xF93=(*0xF93 & 0b11111101) | 0b101; *0xF94 = *0xF94 & 0x7C;  //MODIFICADO PARA ALUX 1.1 
....................    #endif  
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
00D9A:  BCF    FF2.2
00D9C:  GOTO   0058
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
00DA0:  MOVF   F93,W
00DA2:  ANDLW  FD
00DA4:  IORLW  05
00DA6:  MOVWF  F93
00DA8:  MOVLW  7C
00DAA:  ANDWF  F94,F
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
00DAC:  BCF    FC6.5
00DAE:  MOVLW  20
00DB0:  MOVWF  FC6
00DB2:  MOVLW  40
00DB4:  MOVWF  FC7
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
00DB6:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00DB8:  BSF    F8B.0
.................... } 
00DBA:  RETLW  00
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
*
01112:  MOVF   FC9,W
01114:  MOVFF  415,FC9
01118:  RRCF   FC7,W
0111A:  BNC   1118
0111C:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
01120:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
013DE:  RCALL  0DA0
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
013E0:  MOVLW  1D
013E2:  MOVLB  4
013E4:  MOVWF  x0A
013E6:  MOVLB  0
013E8:  RCALL  1122
013EA:  MOVFF  01,35F
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
013EE:  MOVLB  3
013F0:  BTFSS  x5F.3
013F2:  BRA    13F8
013F4:  MOVLB  0
013F6:  BRA    13E0
013F8:  MOVF   x5F,W
013FA:  XORLW  FF
013FC:  ANDLW  01
013FE:  BTFSC  FD8.2
01400:  BRA    1406
01402:  MOVLB  0
01404:  BRA    13E0
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
01406:  MOVLB  0
01408:  BRA    1148
....................     delay_ms(1); 
0140A:  MOVLW  01
0140C:  MOVLB  3
0140E:  MOVWF  x65
01410:  MOVLB  0
01412:  RCALL  0DF4
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
01414:  CLRF   4F
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
01416:  BSF    58.0
....................    NextPacketLocation.Val = RXSTART; 
01418:  CLRF   55
0141A:  CLRF   54
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0141C:  MOVLW  08
0141E:  MOVLB  4
01420:  MOVWF  x10
01422:  CLRF   x11
01424:  MOVLB  0
01426:  RCALL  115A
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
01428:  MOVLW  09
0142A:  MOVLB  4
0142C:  MOVWF  x10
0142E:  CLRF   x11
01430:  MOVLB  0
01432:  RCALL  115A
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
01434:  MOVLW  0C
01436:  MOVLB  4
01438:  MOVWF  x10
0143A:  MOVLW  F7
0143C:  MOVWF  x11
0143E:  MOVLB  0
01440:  RCALL  115A
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
01442:  MOVLW  0D
01444:  MOVLB  4
01446:  MOVWF  x10
01448:  MOVLW  1B
0144A:  MOVWF  x11
0144C:  MOVLB  0
0144E:  RCALL  115A
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
01450:  MOVLW  0A
01452:  MOVLB  4
01454:  MOVWF  x10
01456:  MOVLW  F7
01458:  MOVWF  x11
0145A:  MOVLB  0
0145C:  RCALL  115A
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0145E:  MOVLW  0B
01460:  MOVLB  4
01462:  MOVWF  x10
01464:  MOVLW  1B
01466:  MOVWF  x11
01468:  MOVLB  0
0146A:  RCALL  115A
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0146C:  MOVLW  04
0146E:  MOVLB  4
01470:  MOVWF  x10
01472:  MOVLW  F8
01474:  MOVWF  x11
01476:  MOVLB  0
01478:  RCALL  115A
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
0147A:  MOVLW  05
0147C:  MOVLB  4
0147E:  MOVWF  x10
01480:  MOVLW  1B
01482:  MOVWF  x11
01484:  MOVLB  0
01486:  RCALL  115A
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
01488:  MOVLW  02
0148A:  MOVLB  4
0148C:  MOVWF  x0E
0148E:  CLRF   x0D
01490:  MOVLB  0
01492:  RCALL  11A8
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
01494:  MOVLB  4
01496:  CLRF   x10
01498:  MOVLW  0D
0149A:  MOVWF  x11
0149C:  MOVLB  0
0149E:  RCALL  115A
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
014A0:  MOVLW  02
014A2:  MOVLB  4
014A4:  MOVWF  x10
014A6:  MOVLW  32
014A8:  MOVWF  x11
014AA:  MOVLB  0
014AC:  RCALL  115A
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
014AE:  MOVLW  03
014B0:  MOVLB  4
014B2:  MOVWF  x10
014B4:  MOVLW  40
014B6:  MOVWF  x11
014B8:  MOVLB  0
014BA:  RCALL  115A
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
014BC:  MOVLW  09
014BE:  MOVLB  4
014C0:  MOVWF  x10
014C2:  MOVLW  3F
014C4:  MOVWF  x11
014C6:  MOVLB  0
014C8:  RCALL  115A
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
014CA:  MOVLW  06
014CC:  MOVLB  4
014CE:  MOVWF  x10
014D0:  MOVLW  12
014D2:  MOVWF  x11
014D4:  MOVLB  0
014D6:  RCALL  115A
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
014D8:  MOVLW  07
014DA:  MOVLB  4
014DC:  MOVWF  x10
014DE:  MOVLW  0C
014E0:  MOVWF  x11
014E2:  MOVLB  0
014E4:  RCALL  115A
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
014E6:  MOVLW  0A
014E8:  MOVLB  4
014EA:  MOVWF  x10
014EC:  MOVLW  EE
014EE:  MOVWF  x11
014F0:  MOVLB  0
014F2:  RCALL  115A
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
014F4:  MOVLW  0B
014F6:  MOVLB  4
014F8:  MOVWF  x10
014FA:  MOVLW  05
014FC:  MOVWF  x11
014FE:  MOVLB  0
01500:  RCALL  115A
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
01502:  MOVLW  03
01504:  MOVLB  4
01506:  MOVWF  x0E
01508:  MOVLW  04
0150A:  MOVWF  x0D
0150C:  MOVLB  0
0150E:  RCALL  11A8
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
01510:  MOVLW  04
01512:  MOVLB  4
01514:  MOVWF  x10
01516:  MOVFF  1C,411
0151A:  MOVLB  0
0151C:  RCALL  115A
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0151E:  MOVLW  05
01520:  MOVLB  4
01522:  MOVWF  x10
01524:  MOVFF  1D,411
01528:  MOVLB  0
0152A:  RCALL  115A
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0152C:  MOVLW  02
0152E:  MOVLB  4
01530:  MOVWF  x10
01532:  MOVFF  1E,411
01536:  MOVLB  0
01538:  RCALL  115A
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0153A:  MOVLW  03
0153C:  MOVLB  4
0153E:  MOVWF  x10
01540:  MOVFF  1F,411
01544:  MOVLB  0
01546:  RCALL  115A
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
01548:  MOVLB  4
0154A:  CLRF   x10
0154C:  MOVFF  20,411
01550:  MOVLB  0
01552:  RCALL  115A
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
01554:  MOVLW  01
01556:  MOVLB  4
01558:  MOVWF  x10
0155A:  MOVFF  21,411
0155E:  MOVLB  0
01560:  RCALL  115A
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
01562:  MOVLW  12
01564:  MOVLB  4
01566:  MOVWF  x0A
01568:  MOVLB  0
0156A:  RCALL  1122
0156C:  MOVFF  01,59
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
01570:  MOVLW  10
01572:  MOVLB  3
01574:  MOVWF  x64
01576:  MOVLW  01
01578:  MOVWF  x66
0157A:  CLRF   x65
0157C:  MOVLB  0
0157E:  RCALL  120C
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
01580:  MOVLW  14
01582:  MOVLB  3
01584:  MOVWF  x64
01586:  MOVLW  04
01588:  MOVWF  x66
0158A:  MOVLW  72
0158C:  MOVWF  x65
0158E:  MOVLB  0
01590:  RCALL  120C
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
01592:  MOVLB  3
01594:  CLRF   x60
01596:  MOVLB  0
01598:  BRA    133E
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
0159A:  MOVLW  1F
0159C:  MOVLB  4
0159E:  MOVWF  x12
015A0:  MOVLW  04
015A2:  MOVWF  x13
015A4:  MOVLB  0
015A6:  RCALL  118E
.................... }//end MACInit 
015A8:  GOTO   2BF8 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
04520:  MOVLW  01
04522:  MOVLB  3
04524:  MOVWF  x65
04526:  MOVLB  0
04528:  CALL   12A2
0452C:  MOVFF  01,365
04530:  MOVLW  00
04532:  MOVLB  3
04534:  BTFSC  01.2
04536:  MOVLW  01
04538:  MOVWF  01
.................... } 
0453A:  MOVLB  0
0453C:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
01AC0:  MOVLW  1F
01AC2:  MOVLB  4
01AC4:  MOVWF  x0A
01AC6:  MOVLB  0
01AC8:  CALL   1122
01ACC:  MOVFF  01,3EC
01AD0:  MOVLW  00
01AD2:  MOVLB  3
01AD4:  BTFSC  01.3
01AD6:  MOVLW  01
01AD8:  XORLW  00
01ADA:  BZ    1AE0
01ADC:  MOVLW  00
01ADE:  BRA    1AE2
01AE0:  MOVLW  01
01AE2:  MOVWF  01
01AE4:  BRA    1AE6
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
01AE6:  MOVLB  0
01AE8:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
01AEA:  MOVLW  1F
01AEC:  MOVLB  4
01AEE:  MOVWF  x0A
01AF0:  MOVLB  0
01AF2:  CALL   1122
01AF6:  MOVFF  01,3EC
01AFA:  MOVLW  00
01AFC:  MOVLB  3
01AFE:  BTFSC  01.3
01B00:  MOVLW  01
01B02:  XORLW  00
01B04:  BNZ   1B0A
01B06:  MOVLW  00
01B08:  BRA    1B0C
01B0A:  MOVLW  FF
01B0C:  MOVWF  01
01B0E:  BRA    1B10
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
01B10:  MOVLB  0
01B12:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
00004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
01908:  BTFSS  58.0
0190A:  BRA    190E
....................       return; 
0190C:  BRA    1970
....................    WasDiscarded = TRUE; 
0190E:  BSF    58.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
01910:  MOVLW  01
01912:  SUBWF  54,W
01914:  MOVLB  3
01916:  MOVWF  xB1
01918:  MOVLW  00
0191A:  SUBWFB 55,W
0191C:  MOVWF  xB2
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
0191E:  MOVF   xB2,W
01920:  SUBLW  1A
01922:  BC    1936
01924:  XORLW  FF
01926:  BNZ   192E
01928:  MOVF   xB1,W
0192A:  SUBLW  F7
0192C:  BC    1936
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
0192E:  MOVLW  1B
01930:  MOVWF  xB2
01932:  MOVLW  F7
01934:  MOVWF  xB1
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
01936:  MOVLW  1E
01938:  MOVLB  4
0193A:  MOVWF  x12
0193C:  MOVLW  40
0193E:  MOVWF  x13
01940:  MOVLB  0
01942:  RCALL  118E
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
01944:  MOVLB  4
01946:  CLRF   x0E
01948:  MOVLW  0C
0194A:  MOVWF  x0D
0194C:  MOVLB  0
0194E:  RCALL  11A8
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
01950:  MOVLW  0C
01952:  MOVLB  4
01954:  MOVWF  x10
01956:  MOVFF  3B1,411
0195A:  MOVLB  0
0195C:  CALL   115A
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
01960:  MOVLW  0D
01962:  MOVLB  4
01964:  MOVWF  x10
01966:  MOVFF  3B2,411
0196A:  MOVLB  0
0196C:  CALL   115A
.................... } 
01970:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
01BBE:  MOVLW  01
01BC0:  MOVLB  4
01BC2:  MOVWF  x0E
01BC4:  MOVLW  19
01BC6:  MOVWF  x0D
01BC8:  MOVLB  0
01BCA:  CALL   11A8
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
01BCE:  MOVLW  19
01BD0:  MOVLB  4
01BD2:  MOVWF  x0A
01BD4:  MOVLB  0
01BD6:  CALL   1122
01BDA:  MOVFF  01,3EB
....................  
....................       BankSel(ERXWRPTL); 
01BDE:  MOVLB  4
01BE0:  CLRF   x0E
01BE2:  MOVLW  0E
01BE4:  MOVWF  x0D
01BE6:  MOVLB  0
01BE8:  CALL   11A8
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
01BEC:  MOVLW  0E
01BEE:  MOVLB  4
01BF0:  MOVWF  x0A
01BF2:  MOVLB  0
01BF4:  CALL   1122
01BF8:  MOVFF  01,3ED
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
01BFC:  MOVLW  0F
01BFE:  MOVLB  4
01C00:  MOVWF  x0A
01C02:  MOVLB  0
01C04:  CALL   1122
01C08:  MOVFF  01,3EE
....................  
....................       BankSel(EPKTCNT); 
01C0C:  MOVLW  01
01C0E:  MOVLB  4
01C10:  MOVWF  x0E
01C12:  MOVLW  19
01C14:  MOVWF  x0D
01C16:  MOVLB  0
01C18:  CALL   11A8
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
01C1C:  MOVLW  19
01C1E:  MOVLB  4
01C20:  MOVWF  x0A
01C22:  MOVLB  0
01C24:  CALL   1122
01C28:  MOVFF  01,3EF
01C2C:  MOVLB  3
01C2E:  MOVF   xEB,W
01C30:  SUBWF  01,W
01C32:  BTFSC  FD8.2
01C34:  BRA    1C3A
01C36:  MOVLB  0
01C38:  BRA    1BCE
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
01C3A:  MOVLB  4
01C3C:  CLRF   x0E
01C3E:  MOVLW  0C
01C40:  MOVWF  x0D
01C42:  MOVLB  0
01C44:  CALL   11A8
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
01C48:  MOVLW  0C
01C4A:  MOVLB  4
01C4C:  MOVWF  x0A
01C4E:  MOVLB  0
01C50:  CALL   1122
01C54:  MOVFF  01,3EB
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
01C58:  MOVLW  0D
01C5A:  MOVLB  4
01C5C:  MOVWF  x0A
01C5E:  MOVLB  0
01C60:  CALL   1122
01C64:  MOVFF  01,3EC
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
01C68:  MOVLB  3
01C6A:  MOVF   xEC,W
01C6C:  SUBWF  xEE,W
01C6E:  BNC   1C9C
01C70:  BNZ   1C78
01C72:  MOVF   xED,W
01C74:  SUBWF  xEB,W
01C76:  BC    1C9C
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
01C78:  MOVF   xEB,W
01C7A:  SUBWF  xED,W
01C7C:  MOVWF  00
01C7E:  MOVF   xEC,W
01C80:  SUBWFB xEE,W
01C82:  MOVWF  03
01C84:  MOVF   00,W
01C86:  XORLW  FF
01C88:  ADDLW  F8
01C8A:  MOVWF  00
01C8C:  MOVLW  1B
01C8E:  SUBFWB 03,F
01C90:  MOVFF  00,01
01C94:  MOVFF  03,02
01C98:  BRA    1CD4
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
01C9A:  BRA    1CD4
01C9C:  MOVF   xEB,W
01C9E:  SUBWF  xED,W
01CA0:  BNZ   1CB4
01CA2:  MOVF   xEC,W
01CA4:  SUBWF  xEE,W
01CA6:  BNZ   1CB4
....................    { 
....................       return RXSIZE - 1; 
01CA8:  MOVLW  F7
01CAA:  MOVWF  01
01CAC:  MOVLW  1B
01CAE:  MOVWF  02
01CB0:  BRA    1CD4
....................    } 
....................    else 
01CB2:  BRA    1CD4
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
01CB4:  MOVF   xED,W
01CB6:  SUBWF  xEB,W
01CB8:  MOVWF  xEF
01CBA:  MOVF   xEE,W
01CBC:  SUBWFB xEC,W
01CBE:  MOVWF  xF0
01CC0:  MOVLW  01
01CC2:  SUBWF  xEF,W
01CC4:  MOVWF  00
01CC6:  MOVLW  00
01CC8:  SUBWFB xF0,W
01CCA:  MOVWF  03
01CCC:  MOVFF  00,01
01CD0:  MOVWF  02
01CD2:  BRA    1CD4
....................    } 
.................... } 
01CD4:  MOVLB  0
01CD6:  GOTO   28E0 (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
043E2:  MOVLW  01
043E4:  MOVLB  4
043E6:  MOVWF  x0E
043E8:  MOVLW  19
043EA:  MOVWF  x0D
043EC:  MOVLB  0
043EE:  CALL   11A8
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
043F2:  MOVLW  19
043F4:  MOVLB  4
043F6:  MOVWF  x0A
043F8:  MOVLB  0
043FA:  CALL   1122
043FE:  MOVFF  01,37D
04402:  MOVLB  3
04404:  MOVF   x7D,F
04406:  BNZ   440E
....................       return FALSE; 
04408:  MOVLW  00
0440A:  MOVWF  01
0440C:  BRA    451A
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
0440E:  BTFSC  58.0
04410:  BRA    4420
....................    { 
....................       MACDiscardRx(); 
04412:  MOVLB  0
04414:  CALL   1908
....................       return FALSE; 
04418:  MOVLW  00
0441A:  MOVWF  01
0441C:  MOVLB  3
0441E:  BRA    451A
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
04420:  MOVFF  55,57
04424:  MOVFF  54,56
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
04428:  MOVLB  4
0442A:  CLRF   x0E
0442C:  CLRF   x0D
0442E:  MOVLB  0
04430:  CALL   11A8
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
04434:  MOVLB  4
04436:  CLRF   x10
04438:  MOVFF  54,411
0443C:  MOVLB  0
0443E:  CALL   115A
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
04442:  MOVLW  01
04444:  MOVLB  4
04446:  MOVWF  x10
04448:  MOVFF  55,411
0444C:  MOVLB  0
0444E:  CALL   115A
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
04452:  MOVLW  03
04454:  MOVLB  3
04456:  MOVWF  x7E
04458:  MOVLW  69
0445A:  MOVFF  37E,3FA
0445E:  MOVWF  xF9
04460:  CLRF   xFC
04462:  MOVLW  14
04464:  MOVWF  xFB
04466:  MOVLB  0
04468:  CALL   25BE
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
0446C:  MOVFF  37C,40B
04470:  MOVFF  37B,40A
04474:  CALL   1CDA
04478:  MOVFF  02,37C
0447C:  MOVFF  01,37B
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
04480:  MOVLB  3
04482:  MOVF   x6A,W
04484:  SUBLW  1A
04486:  BC    4492
04488:  XORLW  FF
0448A:  BNZ   44BE
0448C:  MOVF   x69,W
0448E:  SUBLW  F7
04490:  BNC   44BE
04492:  MOVLW  03
04494:  MOVWF  x7E
04496:  MOVLW  69
04498:  MOVWF  FE9
0449A:  MOVFF  37E,FEA
0449E:  BTFSC  FEF.0
044A0:  BRA    44BE
044A2:  BTFSC  x6E.7
044A4:  BRA    44BE
044A6:  BTFSC  x6D.4
044A8:  BRA    44BE
044AA:  MOVF   x6C,W
044AC:  SUBLW  04
044AE:  BC    44BA
044B0:  XORLW  FF
044B2:  BNZ   44BE
044B4:  MOVF   x6B,W
044B6:  SUBLW  EE
044B8:  BNC   44BE
044BA:  BTFSC  x6D.7
044BC:  BRA    44C0
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
044BE:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
044C0:  MOVFF  36A,55
044C4:  MOVFF  369,54
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
044C8:  MOVFF  365,37D
044CC:  MOVFF  366,37E
044D0:  MOVFF  366,FEA
044D4:  MOVFF  365,FE9
044D8:  MOVLW  03
044DA:  MOVWF  FE2
044DC:  MOVLW  75
044DE:  MOVWF  FE1
044E0:  MOVLW  06
044E2:  MOVWF  01
044E4:  MOVFF  FE6,FEE
044E8:  DECFSZ 01,F
044EA:  BRA    44E4
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
044EC:  MOVFF  367,FE9
044F0:  MOVFF  368,FEA
044F4:  MOVLW  FF
044F6:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
044F8:  MOVF   x7C,W
044FA:  SUBLW  08
044FC:  BNZ   4514
044FE:  MOVF   x7B,F
04500:  BZ    4508
04502:  MOVF   x7B,W
04504:  SUBLW  06
04506:  BNZ   4514
....................     { 
....................        *type = header.Type.v[0]; 
04508:  MOVFF  367,FE9
0450C:  MOVFF  368,FEA
04510:  MOVFF  37B,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
04514:  BCF    58.0
....................    return TRUE; 
04516:  MOVLW  01
04518:  MOVWF  01
.................... } 
0451A:  MOVLB  0
0451C:  GOTO   8856 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
02162:  MOVLB  4
02164:  CLRF   x0E
02166:  MOVLW  02
02168:  MOVWF  x0D
0216A:  MOVLB  0
0216C:  CALL   11A8
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
02170:  MOVLW  02
02172:  MOVLB  4
02174:  MOVWF  x10
02176:  MOVLW  F8
02178:  MOVWF  x11
0217A:  MOVLB  0
0217C:  CALL   115A
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
02180:  MOVLW  03
02182:  MOVLB  4
02184:  MOVWF  x10
02186:  MOVLW  1B
02188:  MOVWF  x11
0218A:  MOVLB  0
0218C:  CALL   115A
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
02190:  MOVLW  06
02192:  MOVLB  4
02194:  ADDWF  x0B,F
02196:  MOVLW  1C
02198:  ADDWFC x0C,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
0219A:  MOVLW  04
0219C:  MOVWF  x0E
0219E:  MOVLW  0B
021A0:  MOVWF  FE9
021A2:  MOVFF  40E,FEA
021A6:  MOVFF  FEF,40F
021AA:  MOVLW  06
021AC:  MOVWF  x10
021AE:  MOVFF  40F,411
021B2:  MOVLB  0
021B4:  CALL   115A
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
021B8:  MOVLW  04
021BA:  MOVLB  4
021BC:  MOVWF  x0E
021BE:  MOVLW  0B
021C0:  MOVWF  x0D
021C2:  MOVLW  01
021C4:  ADDWF  x0D,W
021C6:  MOVWF  FE9
021C8:  MOVLW  00
021CA:  ADDWFC x0E,W
021CC:  MOVWF  FEA
021CE:  MOVFF  FEF,40F
021D2:  MOVLW  07
021D4:  MOVWF  x10
021D6:  MOVFF  40F,411
021DA:  MOVLB  0
021DC:  CALL   115A
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
021E0:  MOVLB  4
021E2:  CLRF   x0E
021E4:  MOVLB  0
021E6:  RCALL  20FE
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
021E8:  MOVFF  409,410
021EC:  MOVFF  408,40F
021F0:  MOVLB  4
021F2:  CLRF   x12
021F4:  MOVLW  06
021F6:  MOVWF  x11
021F8:  MOVLB  0
021FA:  RCALL  2118
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
021FC:  MOVLB  4
021FE:  CLRF   x0E
02200:  MOVLW  1C
02202:  MOVFF  40E,410
02206:  MOVWF  x0F
02208:  CLRF   x12
0220A:  MOVLW  06
0220C:  MOVWF  x11
0220E:  MOVLB  0
02210:  RCALL  2118
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
02212:  MOVLW  08
02214:  MOVLB  4
02216:  MOVWF  x0E
02218:  MOVLB  0
0221A:  RCALL  20FE
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
0221C:  MOVLB  4
0221E:  MOVF   x0A,F
02220:  BNZ   2226
02222:  MOVLW  00
02224:  BRA    2228
02226:  MOVLW  06
02228:  MOVWF  x0E
0222A:  MOVLB  0
0222C:  RCALL  20FE
.................... } 
0222E:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
*
02622:  MOVLW  1C
02624:  MOVLB  4
02626:  MOVWF  x0A
02628:  MOVLB  0
0262A:  CALL   1122
0262E:  MOVFF  01,3F7
02632:  MOVLW  00
02634:  MOVLB  3
02636:  BTFSC  01.1
02638:  MOVLW  01
0263A:  XORLW  00
0263C:  BZ    265E
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
0263E:  MOVLW  1F
02640:  MOVLB  4
02642:  MOVWF  x12
02644:  MOVLW  80
02646:  MOVWF  x13
02648:  MOVLB  0
0264A:  CALL   118E
....................       BFCReg(ECON1, ECON1_TXRST); 
0264E:  MOVLW  1F
02650:  MOVLB  4
02652:  MOVWF  x0F
02654:  MOVLW  80
02656:  MOVWF  x10
02658:  MOVLB  0
0265A:  CALL   1174
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
0265E:  MOVLW  1C
02660:  MOVLB  4
02662:  MOVWF  x0F
02664:  MOVLW  0A
02666:  MOVWF  x10
02668:  MOVLB  0
0266A:  CALL   1174
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
0266E:  MOVLW  1F
02670:  MOVLB  4
02672:  MOVWF  x12
02674:  MOVLW  08
02676:  MOVWF  x13
02678:  MOVLB  0
0267A:  CALL   118E
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
0267E:  MOVF   59,W
02680:  SUBLW  05
02682:  BTFSS  FD8.2
02684:  BRA    2854
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
02686:  MOVLW  1C
02688:  MOVLB  4
0268A:  MOVWF  x0A
0268C:  MOVLB  0
0268E:  CALL   1122
02692:  MOVFF  01,3F7
02696:  MOVLB  3
02698:  MOVF   01,W
0269A:  ANDLW  0A
0269C:  BTFSS  FD8.2
0269E:  BRA    26A4
026A0:  MOVLB  0
026A2:  BRA    2686
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
026A4:  MOVLW  1C
026A6:  MOVLB  4
026A8:  MOVWF  x0A
026AA:  MOVLB  0
026AC:  CALL   1122
026B0:  MOVFF  01,3F7
026B4:  MOVLW  00
026B6:  MOVLB  3
026B8:  BTFSC  01.1
026BA:  MOVLW  01
026BC:  XORLW  00
026BE:  BTFSC  FD8.2
026C0:  BRA    2856
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
026C2:  MOVLW  1F
026C4:  MOVLB  4
026C6:  MOVWF  x0F
026C8:  MOVLW  08
026CA:  MOVWF  x10
026CC:  MOVLB  0
026CE:  CALL   1174
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
026D2:  MOVLB  4
026D4:  CLRF   x0E
026D6:  CLRF   x0D
026D8:  MOVLB  0
026DA:  CALL   11A8
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
026DE:  MOVLB  4
026E0:  CLRF   x0A
026E2:  MOVLB  0
026E4:  CALL   1122
026E8:  MOVFF  01,3EB
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
026EC:  MOVLW  01
026EE:  MOVLB  4
026F0:  MOVWF  x0A
026F2:  MOVLB  0
026F4:  CALL   1122
026F8:  MOVFF  01,3EC
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
026FC:  MOVLW  06
026FE:  MOVLB  4
02700:  MOVWF  x0A
02702:  MOVLB  0
02704:  CALL   1122
02708:  MOVFF  01,3ED
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
0270C:  MOVLW  07
0270E:  MOVLB  4
02710:  MOVWF  x0A
02712:  MOVLB  0
02714:  CALL   1122
02718:  MOVFF  01,3EE
....................          TXEnd.Val++; 
0271C:  MOVLB  3
0271E:  INCF   xED,F
02720:  BTFSC  FD8.2
02722:  INCF   xEE,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
02724:  MOVLB  4
02726:  CLRF   x10
02728:  MOVFF  3ED,411
0272C:  MOVLB  0
0272E:  CALL   115A
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
02732:  MOVLW  01
02734:  MOVLB  4
02736:  MOVWF  x10
02738:  MOVFF  3EE,411
0273C:  MOVLB  0
0273E:  CALL   115A
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02742:  MOVLW  03
02744:  MOVLB  3
02746:  MOVWF  xF8
02748:  MOVLW  EF
0274A:  MOVFF  3F8,3FA
0274E:  MOVWF  xF9
02750:  CLRF   xFC
02752:  MOVLW  07
02754:  MOVWF  xFB
02756:  MOVLB  0
02758:  RCALL  25BE
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
0275A:  MOVLB  3
0275C:  CLRF   xF6
0275E:  MOVF   xF6,W
02760:  SUBLW  0F
02762:  BNC   2836
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
02764:  MOVLW  1C
02766:  MOVLB  4
02768:  MOVWF  x0A
0276A:  MOVLB  0
0276C:  CALL   1122
02770:  MOVFF  01,3F7
02774:  MOVLW  00
02776:  MOVLB  3
02778:  BTFSC  01.1
0277A:  MOVLW  01
0277C:  XORLW  00
0277E:  BZ    282C
02780:  BTFSS  xF2.5
02782:  BRA    282C
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
02784:  MOVLW  1F
02786:  MOVLB  4
02788:  MOVWF  x12
0278A:  MOVLW  80
0278C:  MOVWF  x13
0278E:  MOVLB  0
02790:  CALL   118E
....................                BFCReg(ECON1, ECON1_TXRST); 
02794:  MOVLW  1F
02796:  MOVLB  4
02798:  MOVWF  x0F
0279A:  MOVLW  80
0279C:  MOVWF  x10
0279E:  MOVLB  0
027A0:  CALL   1174
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
027A4:  MOVLW  1C
027A6:  MOVLB  4
027A8:  MOVWF  x0F
027AA:  MOVLW  0A
027AC:  MOVWF  x10
027AE:  MOVLB  0
027B0:  CALL   1174
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
027B4:  MOVLW  1F
027B6:  MOVLB  4
027B8:  MOVWF  x12
027BA:  MOVLW  08
027BC:  MOVWF  x13
027BE:  MOVLB  0
027C0:  CALL   118E
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
027C4:  MOVLW  1C
027C6:  MOVLB  4
027C8:  MOVWF  x0A
027CA:  MOVLB  0
027CC:  CALL   1122
027D0:  MOVFF  01,3F7
027D4:  MOVLB  3
027D6:  MOVF   01,W
027D8:  ANDLW  0A
027DA:  BTFSS  FD8.2
027DC:  BRA    27E2
027DE:  MOVLB  0
027E0:  BRA    27C4
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
027E2:  MOVLW  1F
027E4:  MOVLB  4
027E6:  MOVWF  x0F
027E8:  MOVLW  08
027EA:  MOVWF  x10
027EC:  MOVLB  0
027EE:  CALL   1174
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
027F2:  MOVLB  4
027F4:  CLRF   x10
027F6:  MOVFF  3ED,411
027FA:  MOVLB  0
027FC:  CALL   115A
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
02800:  MOVLW  01
02802:  MOVLB  4
02804:  MOVWF  x10
02806:  MOVFF  3EE,411
0280A:  MOVLB  0
0280C:  CALL   115A
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02810:  MOVLW  03
02812:  MOVLB  3
02814:  MOVWF  xF8
02816:  MOVLW  EF
02818:  MOVFF  3F8,3FA
0281C:  MOVWF  xF9
0281E:  CLRF   xFC
02820:  MOVLW  07
02822:  MOVWF  xFB
02824:  MOVLB  0
02826:  RCALL  25BE
....................             } 
....................             else 
02828:  BRA    2830
0282A:  MOVLB  3
....................             { 
....................                break; 
0282C:  BRA    2836
0282E:  MOVLB  0
....................             } 
....................          } 
02830:  MOVLB  3
02832:  INCF   xF6,F
02834:  BRA    275E
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
02836:  MOVLB  4
02838:  CLRF   x10
0283A:  MOVFF  3EB,411
0283E:  MOVLB  0
02840:  CALL   115A
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
02844:  MOVLW  01
02846:  MOVLB  4
02848:  MOVWF  x10
0284A:  MOVFF  3EC,411
0284E:  MOVLB  0
02850:  CALL   115A
02854:  MOVLB  3
....................       } 
....................    } 
.................... } 
02856:  MOVLB  0
02858:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
04A36:  MOVLW  14
04A38:  ADDWF  56,W
04A3A:  MOVLB  3
04A3C:  MOVWF  x9A
04A3E:  MOVLW  00
04A40:  ADDWFC 57,W
04A42:  MOVWF  x9B
04A44:  MOVF   x96,W
04A46:  ADDWF  x9A,W
04A48:  MOVWF  x98
04A4A:  MOVF   x97,W
04A4C:  ADDWFC x9B,W
04A4E:  MOVWF  x99
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
04A50:  MOVF   x99,W
04A52:  SUBLW  1A
04A54:  BC    4A68
04A56:  XORLW  FF
04A58:  BNZ   4A60
04A5A:  MOVF   x98,W
04A5C:  SUBLW  F7
04A5E:  BC    4A68
....................       ReadPT.Val -= RXSIZE; 
04A60:  MOVLW  F8
04A62:  SUBWF  x98,F
04A64:  MOVLW  1B
04A66:  SUBWFB x99,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
04A68:  MOVLB  4
04A6A:  CLRF   x0E
04A6C:  CLRF   x0D
04A6E:  MOVLB  0
04A70:  CALL   11A8
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
04A74:  MOVLB  4
04A76:  CLRF   x10
04A78:  MOVFF  398,411
04A7C:  MOVLB  0
04A7E:  CALL   115A
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
04A82:  MOVLW  01
04A84:  MOVLB  4
04A86:  MOVWF  x10
04A88:  MOVFF  399,411
04A8C:  MOVLB  0
04A8E:  CALL   115A
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
04A92:  MOVLW  02
04A94:  MOVLB  4
04A96:  MOVWF  x10
04A98:  MOVFF  398,411
04A9C:  MOVLB  0
04A9E:  CALL   115A
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
04AA2:  MOVLW  03
04AA4:  MOVLB  4
04AA6:  MOVWF  x10
04AA8:  MOVFF  399,411
04AAC:  MOVLB  0
04AAE:  CALL   115A
.................... } 
04AB2:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01B14:  MOVFF  404,4F
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
01B18:  MOVLW  07
01B1A:  MOVLB  4
01B1C:  ADDWF  x05,F
01B1E:  MOVLW  1C
01B20:  ADDWFC x06,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
01B22:  CLRF   x0E
01B24:  MOVLW  02
01B26:  MOVWF  x0D
01B28:  MOVLB  0
01B2A:  CALL   11A8
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01B2E:  MOVLW  04
01B30:  MOVLB  4
01B32:  MOVWF  x08
01B34:  MOVLW  05
01B36:  MOVWF  FE9
01B38:  MOVFF  408,FEA
01B3C:  MOVFF  FEF,409
01B40:  CLRF   x10
01B42:  MOVFF  409,411
01B46:  MOVLB  0
01B48:  CALL   115A
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
01B4C:  MOVLW  04
01B4E:  MOVLB  4
01B50:  MOVWF  x08
01B52:  MOVLW  05
01B54:  MOVWF  x07
01B56:  MOVLW  01
01B58:  ADDWF  x07,W
01B5A:  MOVWF  FE9
01B5C:  MOVLW  00
01B5E:  ADDWFC x08,W
01B60:  MOVWF  FEA
01B62:  MOVFF  FEF,409
01B66:  MOVLW  01
01B68:  MOVWF  x10
01B6A:  MOVFF  409,411
01B6E:  MOVLB  0
01B70:  CALL   115A
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01B74:  MOVLW  04
01B76:  MOVLB  4
01B78:  MOVWF  x08
01B7A:  MOVLW  05
01B7C:  MOVWF  FE9
01B7E:  MOVFF  408,FEA
01B82:  MOVFF  FEF,409
01B86:  MOVLW  02
01B88:  MOVWF  x10
01B8A:  MOVFF  409,411
01B8E:  MOVLB  0
01B90:  CALL   115A
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
01B94:  MOVLW  04
01B96:  MOVLB  4
01B98:  MOVWF  x08
01B9A:  MOVLW  05
01B9C:  MOVWF  x07
01B9E:  MOVLW  01
01BA0:  ADDWF  x07,W
01BA2:  MOVWF  FE9
01BA4:  MOVLW  00
01BA6:  ADDWFC x08,W
01BA8:  MOVWF  FEA
01BAA:  MOVFF  FEF,409
01BAE:  MOVLW  03
01BB0:  MOVWF  x10
01BB2:  MOVFF  409,411
01BB6:  MOVLB  0
01BB8:  CALL   115A
.................... } 
01BBC:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
04928:  MOVLW  14
0492A:  ADDWF  56,W
0492C:  MOVLB  3
0492E:  MOVWF  xC4
04930:  MOVLW  00
04932:  ADDWFC 57,W
04934:  MOVWF  xC5
04936:  MOVF   xBE,W
04938:  ADDWF  xC4,W
0493A:  MOVWF  xC2
0493C:  MOVF   xBF,W
0493E:  ADDWFC xC5,W
04940:  MOVWF  xC3
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
04942:  MOVF   xC3,W
04944:  SUBLW  1A
04946:  BC    495A
04948:  XORLW  FF
0494A:  BNZ   4952
0494C:  MOVF   xC2,W
0494E:  SUBLW  F7
04950:  BC    495A
....................    { 
....................       temp.Val -= RXSIZE; 
04952:  MOVLW  F8
04954:  SUBWF  xC2,F
04956:  MOVLW  1B
04958:  SUBWFB xC3,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
0495A:  MOVLB  4
0495C:  CLRF   x0E
0495E:  MOVLW  10
04960:  MOVWF  x0D
04962:  MOVLB  0
04964:  CALL   11A8
....................    WriteReg(EDMASTL, temp.v[0]); 
04968:  MOVLW  10
0496A:  MOVLB  4
0496C:  MOVWF  x10
0496E:  MOVFF  3C2,411
04972:  MOVLB  0
04974:  CALL   115A
....................    WriteReg(EDMASTH, temp.v[1]); 
04978:  MOVLW  11
0497A:  MOVLB  4
0497C:  MOVWF  x10
0497E:  MOVFF  3C3,411
04982:  MOVLB  0
04984:  CALL   115A
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
04988:  MOVLW  01
0498A:  MOVLB  3
0498C:  SUBWF  xC0,W
0498E:  MOVWF  00
04990:  MOVLW  00
04992:  SUBWFB xC1,W
04994:  MOVWF  03
04996:  MOVF   00,W
04998:  ADDWF  xC2,F
0499A:  MOVF   03,W
0499C:  ADDWFC xC3,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
0499E:  MOVF   xC3,W
049A0:  SUBLW  1A
049A2:  BC    49B6
049A4:  XORLW  FF
049A6:  BNZ   49AE
049A8:  MOVF   xC2,W
049AA:  SUBLW  F7
049AC:  BC    49B6
....................    { 
....................       temp.Val -= RXSIZE; 
049AE:  MOVLW  F8
049B0:  SUBWF  xC2,F
049B2:  MOVLW  1B
049B4:  SUBWFB xC3,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
049B6:  MOVLW  12
049B8:  MOVLB  4
049BA:  MOVWF  x10
049BC:  MOVFF  3C2,411
049C0:  MOVLB  0
049C2:  CALL   115A
....................    WriteReg(EDMANDH, temp.v[1]); 
049C6:  MOVLW  13
049C8:  MOVLB  4
049CA:  MOVWF  x10
049CC:  MOVFF  3C3,411
049D0:  MOVLB  0
049D2:  CALL   115A
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
049D6:  MOVLW  1F
049D8:  MOVLB  4
049DA:  MOVWF  x12
049DC:  MOVLW  30
049DE:  MOVWF  x13
049E0:  MOVLB  0
049E2:  CALL   118E
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
049E6:  MOVLW  1F
049E8:  MOVLB  4
049EA:  MOVWF  x0A
049EC:  MOVLB  0
049EE:  CALL   1122
049F2:  MOVFF  01,3C4
049F6:  MOVLW  00
049F8:  MOVLB  3
049FA:  BTFSC  01.5
049FC:  MOVLW  01
049FE:  XORLW  00
04A00:  BTFSC  FD8.2
04A02:  BRA    4A08
04A04:  MOVLB  0
04A06:  BRA    49E6
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
04A08:  MOVLW  16
04A0A:  MOVLB  4
04A0C:  MOVWF  x0A
04A0E:  MOVLB  0
04A10:  CALL   1122
04A14:  MOVFF  01,3C3
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
04A18:  MOVLW  17
04A1A:  MOVLB  4
04A1C:  MOVWF  x0A
04A1E:  MOVLB  0
04A20:  CALL   1122
04A24:  MOVFF  01,3C2
....................    return temp.Val; 
04A28:  MOVLB  3
04A2A:  MOVFF  3C2,01
04A2E:  MOVFF  3C3,02
.................... } 
04A32:  MOVLB  0
04A34:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
02230:  MOVLW  06
02232:  MOVLB  4
02234:  ADDWF  x04,W
02236:  MOVWF  x0A
02238:  MOVLW  1C
0223A:  ADDWFC x05,W
0223C:  MOVWF  x0B
0223E:  MOVLW  01
02240:  ADDWF  x0A,W
02242:  MOVWF  x08
02244:  MOVLW  00
02246:  ADDWFC x0B,W
02248:  MOVWF  x09
.................... #endif 
....................    BankSel(EDMASTL); 
0224A:  CLRF   x0E
0224C:  MOVLW  10
0224E:  MOVWF  x0D
02250:  MOVLB  0
02252:  CALL   11A8
....................    WriteReg(EDMASTL, temp.v[0]); 
02256:  MOVLW  10
02258:  MOVLB  4
0225A:  MOVWF  x10
0225C:  MOVFF  408,411
02260:  MOVLB  0
02262:  CALL   115A
....................    WriteReg(EDMASTH, temp.v[1]); 
02266:  MOVLW  11
02268:  MOVLB  4
0226A:  MOVWF  x10
0226C:  MOVFF  409,411
02270:  MOVLB  0
02272:  CALL   115A
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
02276:  MOVLW  01
02278:  MOVLB  4
0227A:  SUBWF  x06,W
0227C:  MOVWF  00
0227E:  MOVLW  00
02280:  SUBWFB x07,W
02282:  MOVWF  03
02284:  MOVF   00,W
02286:  ADDWF  x08,F
02288:  MOVF   03,W
0228A:  ADDWFC x09,F
....................    WriteReg(EDMANDL, temp.v[0]); 
0228C:  MOVLW  12
0228E:  MOVWF  x10
02290:  MOVFF  408,411
02294:  MOVLB  0
02296:  CALL   115A
....................    WriteReg(EDMANDH, temp.v[1]); 
0229A:  MOVLW  13
0229C:  MOVLB  4
0229E:  MOVWF  x10
022A0:  MOVFF  409,411
022A4:  MOVLB  0
022A6:  CALL   115A
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
022AA:  MOVLW  1F
022AC:  MOVLB  4
022AE:  MOVWF  x12
022B0:  MOVLW  30
022B2:  MOVWF  x13
022B4:  MOVLB  0
022B6:  CALL   118E
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
022BA:  MOVLW  1F
022BC:  MOVLB  4
022BE:  MOVWF  x0A
022C0:  MOVLB  0
022C2:  CALL   1122
022C6:  MOVFF  01,40A
022CA:  MOVLW  00
022CC:  MOVLB  4
022CE:  BTFSC  01.5
022D0:  MOVLW  01
022D2:  XORLW  00
022D4:  BTFSC  FD8.2
022D6:  BRA    22DC
022D8:  MOVLB  0
022DA:  BRA    22BA
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
022DC:  MOVLW  16
022DE:  MOVWF  x0A
022E0:  MOVLB  0
022E2:  CALL   1122
022E6:  MOVFF  01,409
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
022EA:  MOVLW  17
022EC:  MOVLB  4
022EE:  MOVWF  x0A
022F0:  MOVLB  0
022F2:  CALL   1122
022F6:  MOVFF  01,408
....................    return temp.Val; 
022FA:  MOVLB  4
022FC:  MOVFF  408,01
02300:  MOVFF  409,02
.................... } 
02304:  MOVLB  0
02306:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
02460:  MOVLB  3
02462:  MOVF   xEB,F
02464:  BNZ   2474
02466:  MOVF   xEC,F
02468:  BNZ   2474
....................    { 
....................       return 0xFFFF; 
0246A:  MOVLW  FF
0246C:  MOVWF  01
0246E:  MOVWF  02
02470:  BRA    25BA
....................    } 
....................    else if(len == 1u) 
02472:  BRA    24A2
02474:  DECFSZ xEB,W
02476:  BRA    24A2
02478:  MOVF   xEC,F
0247A:  BNZ   24A2
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
0247C:  MOVLB  0
0247E:  RCALL  2438
02480:  MOVLB  3
02482:  CLRF   xF0
02484:  MOVFF  01,3EF
02488:  MOVFF  01,03
0248C:  MOVLW  00
0248E:  CLRF   00
02490:  DECF   00,F
02492:  XORWF  00,F
02494:  MOVLW  FF
02496:  XORWF  03,F
02498:  MOVFF  00,01
0249C:  MOVFF  03,02
024A0:  BRA    25BA
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
024A2:  MOVLB  4
024A4:  CLRF   x0E
024A6:  CLRF   x0D
024A8:  MOVLB  0
024AA:  CALL   11A8
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
024AE:  MOVLB  4
024B0:  CLRF   x0A
024B2:  MOVLB  0
024B4:  CALL   1122
024B8:  MOVFF  01,3ED
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
024BC:  MOVLW  01
024BE:  MOVLB  4
024C0:  MOVWF  x0A
024C2:  MOVLB  0
024C4:  CALL   1122
024C8:  MOVFF  01,3EE
....................    WriteReg(EDMASTL, temp.v[0]); 
024CC:  MOVLW  10
024CE:  MOVLB  4
024D0:  MOVWF  x10
024D2:  MOVFF  3ED,411
024D6:  MOVLB  0
024D8:  CALL   115A
....................    WriteReg(EDMASTH, temp.v[1]); 
024DC:  MOVLW  11
024DE:  MOVLB  4
024E0:  MOVWF  x10
024E2:  MOVFF  3EE,411
024E6:  MOVLB  0
024E8:  CALL   115A
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
024EC:  MOVLB  3
024EE:  MOVF   xEE,W
024F0:  SUBLW  1B
024F2:  BNC   252A
024F4:  BNZ   24FC
024F6:  MOVF   xED,W
024F8:  SUBLW  F7
024FA:  BNC   252A
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
024FC:  MOVLW  01
024FE:  SUBWF  xEB,W
02500:  MOVWF  00
02502:  MOVLW  00
02504:  SUBWFB xEC,W
02506:  MOVWF  03
02508:  MOVF   00,W
0250A:  ADDWF  xED,F
0250C:  MOVF   03,W
0250E:  ADDWFC xEE,F
....................       if(temp.Val > RXSTOP) 
02510:  MOVF   xEE,W
02512:  SUBLW  1A
02514:  BC    2528
02516:  XORLW  FF
02518:  BNZ   2520
0251A:  MOVF   xED,W
0251C:  SUBLW  F7
0251E:  BC    2528
....................       { 
....................          temp.Val -= RXSIZE; 
02520:  MOVLW  F8
02522:  SUBWF  xED,F
02524:  MOVLW  1B
02526:  SUBWFB xEE,F
....................       } 
....................    } 
....................    else 
02528:  BRA    253E
....................    { 
....................       temp.Val += len-1; 
0252A:  MOVLW  01
0252C:  SUBWF  xEB,W
0252E:  MOVWF  00
02530:  MOVLW  00
02532:  SUBWFB xEC,W
02534:  MOVWF  03
02536:  MOVF   00,W
02538:  ADDWF  xED,F
0253A:  MOVF   03,W
0253C:  ADDWFC xEE,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
0253E:  MOVLW  12
02540:  MOVLB  4
02542:  MOVWF  x10
02544:  MOVFF  3ED,411
02548:  MOVLB  0
0254A:  CALL   115A
....................    WriteReg(EDMANDH, temp.v[1]); 
0254E:  MOVLW  13
02550:  MOVLB  4
02552:  MOVWF  x10
02554:  MOVFF  3EE,411
02558:  MOVLB  0
0255A:  CALL   115A
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
0255E:  MOVLW  1F
02560:  MOVLB  4
02562:  MOVWF  x12
02564:  MOVLW  30
02566:  MOVWF  x13
02568:  MOVLB  0
0256A:  CALL   118E
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0256E:  MOVLW  1F
02570:  MOVLB  4
02572:  MOVWF  x0A
02574:  MOVLB  0
02576:  CALL   1122
0257A:  MOVFF  01,3EF
0257E:  MOVLW  00
02580:  MOVLB  3
02582:  BTFSC  01.5
02584:  MOVLW  01
02586:  XORLW  00
02588:  BTFSC  FD8.2
0258A:  BRA    2590
0258C:  MOVLB  0
0258E:  BRA    256E
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
02590:  MOVLW  16
02592:  MOVLB  4
02594:  MOVWF  x0A
02596:  MOVLB  0
02598:  CALL   1122
0259C:  MOVFF  01,3ED
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
025A0:  MOVLW  17
025A2:  MOVLB  4
025A4:  MOVWF  x0A
025A6:  MOVLB  0
025A8:  CALL   1122
025AC:  MOVFF  01,3EE
....................    return temp.Val; 
025B0:  MOVLB  3
025B2:  MOVFF  3ED,01
025B6:  MOVFF  3EE,02
.................... } 
025BA:  MOVLB  0
025BC:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
02438:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
0243A:  MOVLW  3A
0243C:  MOVLB  4
0243E:  MOVWF  x15
02440:  MOVLB  0
02442:  CALL   1112
....................    c=ENCSPIXfer(0); 
02446:  MOVLB  4
02448:  CLRF   x15
0244A:  MOVLB  0
0244C:  CALL   1112
02450:  MOVFF  01,3EF
....................    SPIUnselectEthernet(); 
02454:  BSF    F8B.1
....................    return(c); 
02456:  MOVLB  3
02458:  MOVFF  3EF,01
.................... }//end MACGet 
0245C:  MOVLB  0
0245E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
025BE:  MOVLB  3
025C0:  CLRF   xFD
025C2:  CLRF   xFE
....................  
....................    SPISelectEthernet(); 
025C4:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
025C6:  MOVLW  3A
025C8:  MOVLB  4
025CA:  MOVWF  x15
025CC:  MOVLB  0
025CE:  CALL   1112
....................    while(i<len) 
....................    { 
025D2:  MOVLB  3
025D4:  MOVF   xFE,W
025D6:  SUBWF  xFC,W
025D8:  BNC   2614
025DA:  BNZ   25E2
025DC:  MOVF   xFB,W
025DE:  SUBWF  xFD,W
025E0:  BC    2614
....................       *val=ENCSPIXfer(0); 
025E2:  MOVFF  3FA,03
025E6:  MOVFF  3F9,3FF
025EA:  MOVFF  3FA,400
025EE:  MOVLB  4
025F0:  CLRF   x15
025F2:  MOVLB  0
025F4:  CALL   1112
025F8:  MOVFF  400,FEA
025FC:  MOVFF  3FF,FE9
02600:  MOVFF  01,FEF
....................       val++; 
02604:  MOVLB  3
02606:  INCF   xF9,F
02608:  BTFSC  FD8.2
0260A:  INCF   xFA,F
....................       i++; 
0260C:  INCF   xFD,F
0260E:  BTFSC  FD8.2
02610:  INCF   xFE,F
....................    } 
02612:  BRA    25D4
....................    SPIUnselectEthernet(); 
02614:  BSF    F8B.1
....................  
....................    return(i); 
02616:  MOVFF  3FD,01
0261A:  MOVFF  3FE,02
.................... }//end MACGetArray 
0261E:  MOVLB  0
02620:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
020FE:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
02100:  MOVLW  7A
02102:  MOVLB  4
02104:  MOVWF  x15
02106:  MOVLB  0
02108:  CALL   1112
....................    ENCSPIXfer(val); 
0210C:  MOVFF  40E,415
02110:  CALL   1112
....................    SPIUnselectEthernet(); 
02114:  BSF    F8B.1
.................... }//end MACPut 
02116:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
02118:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
0211A:  MOVLW  7A
0211C:  MOVLB  4
0211E:  MOVWF  x15
02120:  MOVLB  0
02122:  CALL   1112
....................    while(len--) 
....................    { 
02126:  MOVLB  4
02128:  MOVFF  412,03
0212C:  MOVF   x11,W
0212E:  BTFSC  FD8.2
02130:  DECF   x12,F
02132:  DECF   x11,F
02134:  IORWF  03,W
02136:  BZ    215C
....................       ENCSPIXfer(*val); 
02138:  MOVFF  410,03
0213C:  MOVFF  40F,FE9
02140:  MOVFF  410,FEA
02144:  MOVFF  FEF,413
02148:  MOVFF  413,415
0214C:  MOVLB  0
0214E:  CALL   1112
....................       val++; 
02152:  MOVLB  4
02154:  INCF   x0F,F
02156:  BTFSC  FD8.2
02158:  INCF   x10,F
....................    } 
0215A:  BRA    2128
....................    SPIUnselectEthernet(); 
0215C:  BSF    F8B.1
.................... }//end MACPutArray 
0215E:  MOVLB  0
02160:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01148:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
0114A:  MOVLW  FF
0114C:  MOVLB  4
0114E:  MOVWF  x15
01150:  MOVLB  0
01152:  RCALL  1112
....................    SPIUnselectEthernet(); 
01154:  BSF    F8B.1
.................... }//end SendSystemReset 
01156:  GOTO   140A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
01122:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
01124:  MOVFF  40A,40C
01128:  MOVFF  40A,415
0112C:  MOVLB  0
0112E:  RCALL  1112
....................    c=ENCSPIXfer(0); 
01130:  MOVLB  4
01132:  CLRF   x15
01134:  MOVLB  0
01136:  RCALL  1112
01138:  MOVFF  01,40B
....................    SPIUnselectEthernet(); 
0113C:  BSF    F8B.1
....................    return(c); 
0113E:  MOVLB  4
01140:  MOVFF  40B,01
.................... }//end ReadETHReg 
01144:  MOVLB  0
01146:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
011DE:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
011E0:  MOVFF  368,36A
011E4:  MOVFF  368,415
011E8:  MOVLB  0
011EA:  RCALL  1112
....................    ENCSPIXfer(0); 
011EC:  MOVLB  4
011EE:  CLRF   x15
011F0:  MOVLB  0
011F2:  RCALL  1112
....................    c=ENCSPIXfer(0); 
011F4:  MOVLB  4
011F6:  CLRF   x15
011F8:  MOVLB  0
011FA:  RCALL  1112
011FC:  MOVFF  01,369
....................  
....................    SPIUnselectEthernet(); 
01200:  BSF    F8B.1
....................  
....................    return(c); 
01202:  MOVLB  3
01204:  MOVFF  369,01
.................... }//end ReadMACReg 
01208:  MOVLB  0
0120A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
012A2:  MOVLW  02
012A4:  MOVLB  4
012A6:  MOVWF  x0E
012A8:  MOVLW  14
012AA:  MOVWF  x0D
012AC:  MOVLB  0
012AE:  RCALL  11A8
....................    WriteReg(MIREGADR, Register); 
012B0:  MOVLW  14
012B2:  MOVLB  4
012B4:  MOVWF  x10
012B6:  MOVFF  365,411
012BA:  MOVLB  0
012BC:  RCALL  115A
....................    WriteReg(MICMD, MICMD_MIIRD); 
012BE:  MOVLW  12
012C0:  MOVLB  4
012C2:  MOVWF  x10
012C4:  MOVLW  01
012C6:  MOVWF  x11
012C8:  MOVLB  0
012CA:  RCALL  115A
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
012CC:  MOVLW  03
012CE:  MOVLB  4
012D0:  MOVWF  x0E
012D2:  MOVLW  0A
012D4:  MOVWF  x0D
012D6:  MOVLB  0
012D8:  RCALL  11A8
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
012DA:  MOVLW  0A
012DC:  MOVLB  3
012DE:  MOVWF  x68
012E0:  MOVLB  0
012E2:  RCALL  11DE
012E4:  MOVFF  01,368
012E8:  MOVLW  00
012EA:  MOVLB  3
012EC:  BTFSC  01.0
012EE:  MOVLW  01
012F0:  XORLW  00
012F2:  BTFSC  FD8.2
012F4:  BRA    12FA
012F6:  MOVLB  0
012F8:  BRA    12DA
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
012FA:  MOVLW  02
012FC:  MOVLB  4
012FE:  MOVWF  x0E
01300:  MOVLW  14
01302:  MOVWF  x0D
01304:  MOVLB  0
01306:  RCALL  11A8
....................    WriteReg(MICMD, 0x00); 
01308:  MOVLW  12
0130A:  MOVLB  4
0130C:  MOVWF  x10
0130E:  CLRF   x11
01310:  MOVLB  0
01312:  RCALL  115A
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
01314:  MOVLW  18
01316:  MOVLB  3
01318:  MOVWF  x68
0131A:  MOVLB  0
0131C:  RCALL  11DE
0131E:  MOVFF  01,366
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
01322:  MOVLW  19
01324:  MOVLB  3
01326:  MOVWF  x68
01328:  MOVLB  0
0132A:  RCALL  11DE
0132C:  MOVFF  01,367
....................    return Result; 
01330:  MOVLB  3
01332:  MOVFF  366,01
01336:  MOVFF  367,02
.................... }//end ReadPHYReg 
0133A:  MOVLB  0
0133C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0115A:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
0115C:  MOVLB  4
0115E:  MOVF   x10,W
01160:  IORLW  40
01162:  MOVWF  x12
01164:  MOVWF  x15
01166:  MOVLB  0
01168:  RCALL  1112
....................    ENCSPIXfer(Data); 
0116A:  MOVFF  411,415
0116E:  RCALL  1112
....................    SPIUnselectEthernet(); 
01170:  BSF    F8B.1
.................... }//end WriteReg 
01172:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01174:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
01176:  MOVLB  4
01178:  MOVF   x0F,W
0117A:  IORLW  A0
0117C:  MOVWF  x11
0117E:  MOVWF  x15
01180:  MOVLB  0
01182:  RCALL  1112
....................    ENCSPIXfer(Data); 
01184:  MOVFF  410,415
01188:  RCALL  1112
....................    SPIUnselectEthernet(); 
0118A:  BSF    F8B.1
.................... }//end BFCReg 
0118C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0118E:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
01190:  MOVLB  4
01192:  MOVF   x12,W
01194:  IORLW  80
01196:  MOVWF  x14
01198:  MOVWF  x15
0119A:  MOVLB  0
0119C:  RCALL  1112
....................    ENCSPIXfer(Data); 
0119E:  MOVFF  413,415
011A2:  RCALL  1112
....................    SPIUnselectEthernet(); 
011A4:  BSF    F8B.1
.................... }//end BFSReg 
011A6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0120C:  MOVLW  02
0120E:  MOVLB  4
01210:  MOVWF  x0E
01212:  MOVLW  14
01214:  MOVWF  x0D
01216:  MOVLB  0
01218:  RCALL  11A8
....................    WriteReg(MIREGADR, Register); 
0121A:  MOVLW  14
0121C:  MOVLB  4
0121E:  MOVWF  x10
01220:  MOVFF  364,411
01224:  MOVLB  0
01226:  RCALL  115A
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
01228:  MOVLW  03
0122A:  MOVLB  3
0122C:  MOVWF  x68
0122E:  MOVLW  65
01230:  MOVWF  FE9
01232:  MOVFF  368,FEA
01236:  MOVFF  FEF,369
0123A:  MOVLW  16
0123C:  MOVLB  4
0123E:  MOVWF  x10
01240:  MOVFF  369,411
01244:  MOVLB  0
01246:  RCALL  115A
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
01248:  MOVLW  03
0124A:  MOVLB  3
0124C:  MOVWF  x68
0124E:  MOVLW  65
01250:  MOVWF  x67
01252:  MOVLW  01
01254:  ADDWF  x67,W
01256:  MOVWF  FE9
01258:  MOVLW  00
0125A:  ADDWFC x68,W
0125C:  MOVWF  FEA
0125E:  MOVFF  FEF,369
01262:  MOVLW  17
01264:  MOVLB  4
01266:  MOVWF  x10
01268:  MOVFF  369,411
0126C:  MOVLB  0
0126E:  RCALL  115A
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
01270:  MOVLW  03
01272:  MOVLB  4
01274:  MOVWF  x0E
01276:  MOVLW  0A
01278:  MOVWF  x0D
0127A:  MOVLB  0
0127C:  RCALL  11A8
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0127E:  MOVLW  0A
01280:  MOVLB  3
01282:  MOVWF  x68
01284:  MOVLB  0
01286:  RCALL  11DE
01288:  MOVFF  01,367
0128C:  MOVLW  00
0128E:  MOVLB  3
01290:  BTFSC  01.0
01292:  MOVLW  01
01294:  XORLW  00
01296:  BTFSC  FD8.2
01298:  BRA    129E
0129A:  MOVLB  0
0129C:  BRA    127E
.................... }//end WritePHYReg 
0129E:  MOVLB  0
012A0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
011A8:  MOVLW  1F
011AA:  MOVLB  4
011AC:  MOVWF  x0F
011AE:  MOVLW  03
011B0:  MOVWF  x10
011B2:  MOVLB  0
011B4:  RCALL  1174
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
011B6:  MOVLW  04
011B8:  MOVLB  4
011BA:  MOVWF  x10
011BC:  MOVLW  0D
011BE:  MOVWF  x0F
011C0:  MOVLW  01
011C2:  ADDWF  x0F,W
011C4:  MOVWF  FE9
011C6:  MOVLW  00
011C8:  ADDWFC x10,W
011CA:  MOVWF  FEA
011CC:  MOVFF  FEF,411
011D0:  MOVLW  1F
011D2:  MOVWF  x12
011D4:  MOVFF  411,413
011D8:  MOVLB  0
011DA:  RCALL  118E
.................... }//end BankSel 
011DC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0133E:  MOVLW  1F
01340:  MOVLB  4
01342:  MOVWF  x0F
01344:  MOVLW  0C
01346:  MOVWF  x10
01348:  MOVLB  0
0134A:  RCALL  1174
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0134C:  MOVLB  3
0134E:  CLRF   x65
01350:  MOVLB  0
01352:  RCALL  12A2
01354:  MOVFF  02,363
01358:  MOVFF  01,362
....................    if(DuplexState == USE_PHY) 
0135C:  MOVLB  3
0135E:  MOVF   x60,W
01360:  SUBLW  02
01362:  BNZ   136C
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
01364:  CLRF   x60
01366:  BTFSC  x63.0
01368:  INCF   x60,F
....................    } 
....................    else 
0136A:  BRA    1380
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0136C:  BCF    x63.0
0136E:  BTFSC  x60.0
01370:  BSF    x63.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
01372:  CLRF   x64
01374:  MOVFF  363,366
01378:  MOVFF  362,365
0137C:  MOVLB  0
0137E:  RCALL  120C
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
01380:  MOVLW  02
01382:  MOVLB  4
01384:  MOVWF  x0E
01386:  MOVWF  x0D
01388:  MOVLB  0
0138A:  RCALL  11A8
....................    Register = ReadMACReg(MACON3); 
0138C:  MOVLW  02
0138E:  MOVLB  3
01390:  MOVWF  x68
01392:  MOVLB  0
01394:  RCALL  11DE
01396:  MOVFF  01,361
....................    Register.MACON3bits.FULDPX = DuplexState; 
0139A:  MOVLB  3
0139C:  BCF    x61.0
0139E:  BTFSC  x60.0
013A0:  BSF    x61.0
....................    WriteReg(MACON3, Register.Val); 
013A2:  MOVLW  02
013A4:  MOVLB  4
013A6:  MOVWF  x10
013A8:  MOVFF  361,411
013AC:  MOVLB  0
013AE:  RCALL  115A
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
013B0:  MOVLB  3
013B2:  MOVF   x60,F
013B4:  BZ    13BA
013B6:  MOVLW  15
013B8:  BRA    13BC
013BA:  MOVLW  12
013BC:  MOVWF  x64
013BE:  MOVLW  04
013C0:  MOVLB  4
013C2:  MOVWF  x10
013C4:  MOVFF  364,411
013C8:  MOVLB  0
013CA:  RCALL  115A
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
013CC:  MOVLW  1F
013CE:  MOVLB  4
013D0:  MOVWF  x12
013D2:  MOVLW  04
013D4:  MOVWF  x13
013D6:  MOVLB  0
013D8:  RCALL  118E
.................... }//end MACSetDuplex 
013DA:  GOTO   159A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
*
07848:  MOVFF  37E,5A
....................    return(MACIsTxReady(TRUE)); 
0784C:  MOVLW  01
0784E:  MOVLB  3
07850:  MOVWF  xEB
07852:  MOVLB  0
07854:  CALL   1AC0
07858:  MOVF   01,W
.................... } 
0785A:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... typedef enum __SMTP_EC { 
....................    SMTP_EC_OK = 0, 
....................    SMTP_EC_CLOSE_PREVIOUS = 1, 
....................    SMTP_EC_MAC_TX_FAIL = 2,   //MAC transmit buffer never became free 
....................    SMTP_EC_ARP_FAIL = 3,   //didn't get an arp response 
....................    SMTP_EC_INVALID_SOCKET = 4,   //TCPConnect() returned INVALID_SOCKET (too many TCP sockets open?) 
....................    SMTP_EC_CONNECT_FAIL = 5,  //TCPIsConnected() never returned TRUE within timeout window 
....................    SMTP_EC_BAD_EHLO = 6, //no or bad response to ehlo command 
....................    SMTP_EC_BAD_MAILFROM = 7,  //no or bad response to mail from: command 
....................    SMTP_EC_BAD_RCPTTO = 8, //no or bad response to rcpt to: command 
....................    SMTP_EC_BAD_DATACMD = 9, //no or bad response to data command 
....................    SMTP_EC_PUT_HEADER = 10, //timeout waiting for socket to be ready to transmit mail headers 
....................    SMTP_EC_BAD_WELCOME = 11, //after making a TCP connection, didn't get proper welcome message from server 
....................    SMTP_EC_BODY_NOT_ACCEPTED = 12 //after sending <CRLF>.<CRLF> we didn't get right response 
.................... } SMTP_EC; 
....................  
.................... //user functions 
.................... int8 SMTPConnect(IP_ADDR *ip, int16 port, char *from, char *to, char *subject); 
.................... int8 SMTPIsPutReady(void); 
.................... void SMTPPut(char c); 
.................... void SMTPDisconnect(void); 
....................  
.................... //stack functions 
.................... void SMTPInit(void); 
.................... void SMTPTask(void); 
.................... void SMTPReadResultCodeReset(void); 
.................... int8 SMTPReadResultCode(int16 *smtp_result); 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... /********************************************************************* 
....................  * 
....................  *   DNS Client Module Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *               Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06  Original 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef DNS_H 
.................... #define DNS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void   DNSResolve(BYTE *HostName); 
.................... BOOL   DNSIsResolved(IP_ADDR *HostIP); 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
04AB4:  MOVLW  03
04AB6:  MOVLB  3
04AB8:  MOVWF  x84
04ABA:  MOVLW  6F
04ABC:  MOVFF  384,3FA
04AC0:  MOVWF  xF9
04AC2:  CLRF   xFC
04AC4:  MOVLW  14
04AC6:  MOVWF  xFB
04AC8:  MOVLB  0
04ACA:  CALL   25BE
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
04ACE:  MOVLB  3
04AD0:  MOVF   x6F,W
04AD2:  ANDLW  F0
04AD4:  SUBLW  40
04AD6:  BZ    4ADE
....................     	return FALSE; 
04AD8:  MOVLW  00
04ADA:  MOVWF  01
04ADC:  BRA    4B9A
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
04ADE:  MOVF   x6F,W
04AE0:  ANDLW  0F
04AE2:  MOVWF  00
04AE4:  RLCF   00,W
04AE6:  MOVLB  0
04AE8:  MOVWF  x8B
04AEA:  RLCF   x8B,F
04AEC:  MOVLW  FC
04AEE:  ANDWF  x8B,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
04AF0:  MOVLB  3
04AF2:  CLRF   xBF
04AF4:  CLRF   xBE
04AF6:  CLRF   xC1
04AF8:  MOVFF  8B,3C0
04AFC:  MOVLB  0
04AFE:  RCALL  4928
04B00:  MOVFF  02,36E
04B04:  MOVFF  01,36D
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
04B08:  MOVLB  3
04B0A:  CLRF   x97
04B0C:  MOVFF  8B,396
04B10:  MOVLB  0
04B12:  RCALL  4A36
....................  
....................     if(CalcChecksum.Val) 
04B14:  MOVLB  3
04B16:  MOVF   x6D,W
04B18:  IORWF  x6E,W
04B1A:  BZ    4B22
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
04B1C:  MOVLW  00
04B1E:  MOVWF  01
04B20:  BRA    4B9A
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
04B22:  MOVLW  03
04B24:  MOVLB  4
04B26:  MOVWF  x05
04B28:  MOVLW  6F
04B2A:  MOVWF  x04
04B2C:  MOVLB  0
04B2E:  CALL   2024
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
04B32:  MOVLB  3
04B34:  MOVF   x65,W
04B36:  IORWF  x66,W
04B38:  BZ    4B52
....................         localIP->Val    = header.DestAddress.Val; 
04B3A:  MOVFF  365,FE9
04B3E:  MOVFF  366,FEA
04B42:  MOVFF  37F,FEF
04B46:  MOVFF  380,FEC
04B4A:  MOVFF  381,FEC
04B4E:  MOVFF  382,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
04B52:  MOVLW  06
04B54:  ADDWF  x67,W
04B56:  MOVWF  FE9
04B58:  MOVLW  00
04B5A:  ADDWFC x68,W
04B5C:  MOVWF  FEA
04B5E:  MOVFF  37B,FEF
04B62:  MOVFF  37C,FEC
04B66:  MOVFF  37D,FEC
04B6A:  MOVFF  37E,FEC
....................     *protocol           = header.Protocol; 
04B6E:  MOVFF  369,FE9
04B72:  MOVFF  36A,FEA
04B76:  MOVFF  378,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
04B7A:  MOVFF  36B,FE9
04B7E:  MOVFF  36C,FEA
04B82:  MOVLB  0
04B84:  MOVF   x8B,W
04B86:  MOVLB  3
04B88:  SUBWF  x71,W
04B8A:  MOVWF  00
04B8C:  MOVLW  00
04B8E:  SUBWFB x72,W
04B90:  MOVFF  00,FEF
04B94:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
04B96:  MOVLW  01
04B98:  MOVWF  01
.................... } 
04B9A:  MOVLB  0
04B9C:  GOTO   88DE (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02308:  MOVLW  14
0230A:  MOVWF  x8B
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
0230C:  MOVLW  45
0230E:  MOVLB  3
02310:  MOVWF  xF0
....................     header.TypeOfService    = IP_SERVICE; 
02312:  CLRF   xF1
....................     header.TotalLength      = sizeof(header) + len; 
02314:  MOVLW  14
02316:  ADDWF  xEE,W
02318:  MOVWF  xF2
0231A:  MOVLW  00
0231C:  ADDWFC xEF,W
0231E:  MOVWF  xF3
....................     header.Identification   = ++_Identifier; 
02320:  MOVLB  0
02322:  INCF   x89,F
02324:  BTFSC  FD8.2
02326:  INCF   x8A,F
02328:  MOVFF  8A,3F5
0232C:  MOVFF  89,3F4
....................     header.FragmentInfo     = 0; 
02330:  MOVLB  3
02332:  CLRF   xF7
02334:  CLRF   xF6
....................     header.TimeToLive       = MY_IP_TTL; 
02336:  MOVLW  64
02338:  MOVWF  xF8
....................     header.Protocol         = protocol; 
0233A:  MOVFF  3ED,3F9
....................     header.HeaderChecksum   = 0; 
0233E:  CLRF   xFB
02340:  CLRF   xFA
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
02342:  MOVFF  1B,3FF
02346:  MOVFF  1A,3FE
0234A:  MOVFF  19,3FD
0234E:  MOVFF  18,3FC
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02352:  MOVLW  06
02354:  ADDWF  xEB,W
02356:  MOVWF  FE9
02358:  MOVLW  00
0235A:  ADDWFC xEC,W
0235C:  MOVWF  FEA
0235E:  MOVFF  FEF,00
02362:  MOVFF  FEC,01
02366:  MOVFF  FEC,02
0236A:  MOVFF  FEC,03
0236E:  MOVFF  03,403
02372:  MOVFF  02,402
02376:  MOVFF  01,401
0237A:  MOVFF  00,400
....................  
....................     SwapIPHeader(&header); 
0237E:  MOVLW  03
02380:  MOVLB  4
02382:  MOVWF  x05
02384:  MOVLW  F0
02386:  MOVWF  x04
02388:  MOVLB  0
0238A:  RCALL  2024
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
0238C:  MOVFF  3EB,01
02390:  MOVFF  3EC,03
02394:  MOVFF  3EB,404
02398:  MOVFF  3EC,405
0239C:  MOVLW  14
0239E:  MOVLB  3
023A0:  ADDWF  xEE,W
023A2:  MOVLB  4
023A4:  MOVWF  x06
023A6:  MOVLW  00
023A8:  MOVLB  3
023AA:  ADDWFC xEF,W
023AC:  MOVLB  4
023AE:  MOVWF  x07
023B0:  MOVFF  3EC,409
023B4:  MOVFF  3EB,408
023B8:  CLRF   x0A
023BA:  MOVWF  x0C
023BC:  MOVFF  406,40B
023C0:  MOVLB  0
023C2:  RCALL  2162
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
023C4:  MOVLW  03
023C6:  MOVLB  4
023C8:  MOVWF  x05
023CA:  MOVLW  F0
023CC:  MOVFF  405,410
023D0:  MOVWF  x0F
023D2:  CLRF   x12
023D4:  MOVLW  14
023D6:  MOVWF  x11
023D8:  MOVLB  0
023DA:  RCALL  2118
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
023DC:  MOVLB  4
023DE:  CLRF   x05
023E0:  CLRF   x04
023E2:  CLRF   x07
023E4:  MOVLW  14
023E6:  MOVWF  x06
023E8:  MOVLB  0
023EA:  RCALL  2230
023EC:  MOVFF  02,3FB
023F0:  MOVFF  01,3FA
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
023F4:  MOVFF  4F,404
023F8:  MOVLB  4
023FA:  CLRF   x06
023FC:  MOVLW  0A
023FE:  MOVWF  x05
02400:  MOVLB  0
02402:  CALL   1B14
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02406:  MOVLW  03
02408:  MOVLB  4
0240A:  MOVWF  x05
0240C:  MOVLW  FA
0240E:  MOVFF  405,410
02412:  MOVWF  x0F
02414:  CLRF   x12
02416:  MOVLW  02
02418:  MOVWF  x11
0241A:  MOVLB  0
0241C:  RCALL  2118
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
0241E:  MOVFF  4F,404
02422:  MOVLB  4
02424:  CLRF   x06
02426:  MOVLW  14
02428:  MOVWF  x05
0242A:  MOVLB  0
0242C:  CALL   1B14
.................... #endif 
....................  
....................     return 0x0; 
02430:  MOVLW  00
02432:  MOVWF  01
02434:  MOVWF  02
.................... } 
02436:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
04BA0:  MOVF   x8B,W
04BA2:  MOVLB  3
04BA4:  ADDWF  x92,W
04BA6:  MOVWF  x94
04BA8:  MOVLW  00
04BAA:  ADDWFC x93,W
04BAC:  MOVWF  x95
04BAE:  MOVWF  x97
04BB0:  MOVFF  394,396
04BB4:  MOVLB  0
04BB6:  RCALL  4A36
.................... } 
04BB8:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
02024:  MOVLW  02
02026:  MOVLB  4
02028:  ADDWF  x04,W
0202A:  MOVWF  01
0202C:  MOVLW  00
0202E:  ADDWFC x05,W
02030:  MOVWF  03
02032:  MOVFF  01,406
02036:  MOVWF  x07
02038:  MOVLW  02
0203A:  ADDWF  x04,W
0203C:  MOVWF  FE9
0203E:  MOVLW  00
02040:  ADDWFC x05,W
02042:  MOVWF  FEA
02044:  MOVFF  FEC,409
02048:  MOVF   FED,F
0204A:  MOVFF  FEF,408
0204E:  MOVFF  409,40B
02052:  MOVFF  408,40A
02056:  MOVLB  0
02058:  RCALL  1CDA
0205A:  MOVFF  407,FEA
0205E:  MOVFF  406,FE9
02062:  MOVFF  02,FEC
02066:  MOVF   FED,F
02068:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
0206C:  MOVLW  04
0206E:  MOVLB  4
02070:  ADDWF  x04,W
02072:  MOVWF  01
02074:  MOVLW  00
02076:  ADDWFC x05,W
02078:  MOVWF  03
0207A:  MOVFF  01,406
0207E:  MOVWF  x07
02080:  MOVLW  04
02082:  ADDWF  x04,W
02084:  MOVWF  FE9
02086:  MOVLW  00
02088:  ADDWFC x05,W
0208A:  MOVWF  FEA
0208C:  MOVFF  FEC,409
02090:  MOVF   FED,F
02092:  MOVFF  FEF,408
02096:  MOVFF  409,40B
0209A:  MOVFF  408,40A
0209E:  MOVLB  0
020A0:  RCALL  1CDA
020A2:  MOVFF  407,FEA
020A6:  MOVFF  406,FE9
020AA:  MOVFF  02,FEC
020AE:  MOVF   FED,F
020B0:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
020B4:  MOVLW  0A
020B6:  MOVLB  4
020B8:  ADDWF  x04,W
020BA:  MOVWF  01
020BC:  MOVLW  00
020BE:  ADDWFC x05,W
020C0:  MOVWF  03
020C2:  MOVFF  01,406
020C6:  MOVWF  x07
020C8:  MOVLW  0A
020CA:  ADDWF  x04,W
020CC:  MOVWF  FE9
020CE:  MOVLW  00
020D0:  ADDWFC x05,W
020D2:  MOVWF  FEA
020D4:  MOVFF  FEC,409
020D8:  MOVF   FED,F
020DA:  MOVFF  FEF,408
020DE:  MOVFF  409,40B
020E2:  MOVFF  408,40A
020E6:  MOVLB  0
020E8:  RCALL  1CDA
020EA:  MOVFF  407,FEA
020EE:  MOVFF  406,FE9
020F2:  MOVFF  02,FEC
020F6:  MOVF   FED,F
020F8:  MOVFF  01,FEF
.................... } 
020FC:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
01796:  MOVLB  3
01798:  CLRF   x5F
0179A:  MOVF   x5F,W
0179C:  SUBLW  04
0179E:  BNC   1872
....................     { 
....................         ps = &TCB[s]; 
017A0:  MOVF   x5F,W
017A2:  MULLW  24
017A4:  MOVF   FF3,W
017A6:  CLRF   03
017A8:  ADDLW  8E
017AA:  MOVWF  01
017AC:  MOVLW  00
017AE:  ADDWFC 03,F
017B0:  MOVFF  01,360
017B4:  MOVFF  03,361
....................  
....................         ps->smState             = TCP_CLOSED; 
017B8:  MOVFF  360,FE9
017BC:  MOVFF  361,FEA
017C0:  MOVLW  0A
017C2:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
017C4:  MOVLW  23
017C6:  ADDWF  x60,W
017C8:  MOVWF  FE9
017CA:  MOVLW  00
017CC:  ADDWFC x61,W
017CE:  MOVWF  FEA
017D0:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
017D2:  MOVLW  23
017D4:  ADDWF  x60,W
017D6:  MOVWF  FE9
017D8:  MOVLW  00
017DA:  ADDWFC x61,W
017DC:  MOVWF  FEA
017DE:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
017E0:  MOVLW  23
017E2:  ADDWF  x60,W
017E4:  MOVWF  FE9
017E6:  MOVLW  00
017E8:  ADDWFC x61,W
017EA:  MOVWF  FEA
017EC:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
017EE:  MOVLW  23
017F0:  ADDWF  x60,W
017F2:  MOVWF  FE9
017F4:  MOVLW  00
017F6:  ADDWFC x61,W
017F8:  MOVWF  FEA
017FA:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
017FC:  MOVLW  23
017FE:  ADDWF  x60,W
01800:  MOVWF  FE9
01802:  MOVLW  00
01804:  ADDWFC x61,W
01806:  MOVWF  FEA
01808:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
0180A:  MOVLW  0F
0180C:  ADDWF  x60,W
0180E:  MOVWF  FE9
01810:  MOVLW  00
01812:  ADDWFC x61,W
01814:  MOVWF  FEA
01816:  INCFSZ FEF,W
01818:  BRA    181C
0181A:  BRA    1848
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
0181C:  MOVLW  0F
0181E:  ADDWF  x60,W
01820:  MOVWF  FE9
01822:  MOVLW  00
01824:  ADDWFC x61,W
01826:  MOVWF  FEA
01828:  MOVFF  FEF,362
0182C:  MOVFF  362,3B2
01830:  MOVLB  0
01832:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
01836:  MOVLW  0F
01838:  MOVLB  3
0183A:  ADDWF  x60,W
0183C:  MOVWF  FE9
0183E:  MOVLW  00
01840:  ADDWFC x61,W
01842:  MOVWF  FEA
01844:  MOVLW  FF
01846:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
01848:  MOVLW  21
0184A:  ADDWF  x60,W
0184C:  MOVWF  FE9
0184E:  MOVLW  00
01850:  ADDWFC x61,W
01852:  MOVWF  FEA
01854:  CLRF   FEC
01856:  MOVF   FED,F
01858:  MOVLW  1E
0185A:  MOVWF  FEF
....................       ps->TxCount            = 0; 
0185C:  MOVLW  10
0185E:  ADDWF  x60,W
01860:  MOVWF  FE9
01862:  MOVLW  00
01864:  ADDWFC x61,W
01866:  MOVWF  FEA
01868:  CLRF   FEC
0186A:  MOVF   FED,F
0186C:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
0186E:  INCF   x5F,F
01870:  BRA    179A
....................     TCPInit_RandSeed+=get_timer0(); 
01872:  MOVF   FD6,W
01874:  MOVLB  1
01876:  ADDWF  x42,F
01878:  MOVF   FD7,W
0187A:  ADDWFC x43,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0187C:  MOVF   FCE,W
0187E:  ADDWF  x42,F
01880:  MOVF   FCF,W
01882:  ADDWFC x43,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
01884:  MOVF   FCC,W
01886:  ADDWF  x42,F
01888:  MOVLW  00
0188A:  ADDWFC x43,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0188C:  MOVF   FB2,W
0188E:  ADDWF  x42,F
01890:  MOVF   FB3,W
01892:  ADDWFC x43,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
01894:  MOVLB  3
01896:  CLRF   x65
01898:  CLRF   x64
0189A:  MOVFF  143,363
0189E:  MOVFF  142,362
018A2:  MOVLB  0
018A4:  BRA    1668
....................     _NextPort=rand(); 
018A6:  BRA    1722
018A8:  MOVFF  02,8D
018AC:  MOVFF  01,8C
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
018B0:  MOVLW  04
018B2:  ADDWF  x8D,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
018B4:  MOVF   x8D,W
018B6:  SUBLW  12
018B8:  BC    18CE
018BA:  XORLW  FF
018BC:  BNZ   18C4
018BE:  MOVF   x8C,W
018C0:  SUBLW  87
018C2:  BC    18CE
018C4:  MOVLW  88
018C6:  SUBWF  x8C,F
018C8:  MOVLW  13
018CA:  SUBWFB x8D,F
018CC:  BRA    18B4
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
018CE:  MOVF   x8D,W
018D0:  SUBLW  03
018D2:  BNC   18D8
018D4:  MOVLW  04
018D6:  ADDWF  x8D,F
.................... } 
018D8:  GOTO   2C04 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
06180:  MOVLB  3
06182:  BCF    x70.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
06184:  CLRF   x6D
06186:  MOVF   x6D,W
06188:  SUBLW  04
0618A:  BNC   61BA
....................    { 
....................       ps = &TCB[s]; 
0618C:  MOVF   x6D,W
0618E:  MULLW  24
06190:  MOVF   FF3,W
06192:  CLRF   03
06194:  ADDLW  8E
06196:  MOVWF  01
06198:  MOVLW  00
0619A:  ADDWFC 03,F
0619C:  MOVFF  01,36E
061A0:  MOVFF  03,36F
....................       if(ps->smState == TCP_CLOSED) 
061A4:  MOVFF  36E,FE9
061A8:  MOVFF  36F,FEA
061AC:  MOVF   FEF,W
061AE:  SUBLW  0A
061B0:  BNZ   61B6
....................       { 
....................          lbFound = TRUE; 
061B2:  BSF    x70.0
....................          break; 
061B4:  BRA    61BA
....................       } 
....................    } 
061B6:  INCF   x6D,F
061B8:  BRA    6186
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
061BA:  BTFSC  x70.0
061BC:  BRA    61C4
....................       return INVALID_SOCKET; 
061BE:  MOVLW  FE
061C0:  MOVWF  01
061C2:  BRA    6392
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
061C4:  MOVLW  0B
061C6:  ADDWF  x6E,W
061C8:  MOVWF  FE9
061CA:  MOVLW  00
061CC:  ADDWFC x6F,W
061CE:  MOVWF  FEA
061D0:  MOVLB  0
061D2:  INCF   x8C,F
061D4:  BTFSC  FD8.2
061D6:  INCF   x8D,F
061D8:  MOVFF  8D,FEC
061DC:  MOVF   FED,F
061DE:  MOVFF  8C,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
061E2:  MOVF   x8D,W
061E4:  SUBLW  12
061E6:  BC    61FA
061E8:  XORLW  FF
061EA:  BNZ   61F2
061EC:  MOVF   x8C,W
061EE:  SUBLW  87
061F0:  BC    61FA
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
061F2:  MOVLW  03
061F4:  MOVWF  x8D
061F6:  MOVLW  FF
061F8:  MOVWF  x8C
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
061FA:  MOVLW  23
061FC:  MOVLB  3
061FE:  ADDWF  x6E,W
06200:  MOVWF  FE9
06202:  MOVLW  00
06204:  ADDWFC x6F,W
06206:  MOVWF  FEA
06208:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
0620A:  MOVLW  0D
0620C:  ADDWF  x6E,W
0620E:  MOVWF  FE9
06210:  MOVLW  00
06212:  ADDWFC x6F,W
06214:  MOVWF  FEA
06216:  MOVFF  36C,FEC
0621A:  MOVF   FED,F
0621C:  MOVFF  36B,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
06220:  MOVLW  16
06222:  ADDWF  x6E,W
06224:  MOVWF  FE9
06226:  MOVLW  00
06228:  ADDWFC x6F,W
0622A:  MOVWF  FEA
0622C:  MOVLW  01
0622E:  ADDWF  FEE,F
06230:  MOVLW  00
06232:  ADDWFC FEE,F
06234:  ADDWFC FEE,F
06236:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
06238:  MOVLW  1A
0623A:  ADDWF  x6E,W
0623C:  MOVWF  FE9
0623E:  MOVLW  00
06240:  ADDWFC x6F,W
06242:  MOVWF  FEA
06244:  MOVF   FEE,F
06246:  MOVF   FEE,F
06248:  CLRF   FEC
0624A:  MOVF   FED,F
0624C:  CLRF   FEF
0624E:  MOVF   FED,F
06250:  CLRF   FEF
06252:  MOVF   FED,F
06254:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
06256:  MOVLW  01
06258:  ADDWF  x6E,W
0625A:  MOVWF  x71
0625C:  MOVLW  00
0625E:  ADDWFC x6F,W
06260:  MOVWF  x72
06262:  MOVWF  FEA
06264:  MOVFF  371,FE9
06268:  MOVFF  36A,FE2
0626C:  MOVFF  369,FE1
06270:  MOVLW  0A
06272:  MOVWF  01
06274:  MOVFF  FE6,FEE
06278:  DECFSZ 01,F
0627A:  BRA    6274
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
0627C:  MOVLW  01
0627E:  ADDWF  x6E,W
06280:  MOVWF  01
06282:  MOVLW  00
06284:  ADDWFC x6F,W
06286:  MOVWF  03
06288:  MOVFF  01,371
0628C:  MOVWF  x72
0628E:  MOVLW  0B
06290:  ADDWF  x6E,W
06292:  MOVWF  FE9
06294:  MOVLW  00
06296:  ADDWFC x6F,W
06298:  MOVWF  FEA
0629A:  MOVFF  FEC,374
0629E:  MOVF   FED,F
062A0:  MOVFF  FEF,373
062A4:  MOVLW  0D
062A6:  ADDWF  x6E,W
062A8:  MOVWF  FE9
062AA:  MOVLW  00
062AC:  ADDWFC x6F,W
062AE:  MOVWF  FEA
062B0:  MOVFF  FEC,376
062B4:  MOVF   FED,F
062B6:  MOVFF  FEF,375
062BA:  MOVLW  16
062BC:  ADDWF  x6E,W
062BE:  MOVWF  FE9
062C0:  MOVLW  00
062C2:  ADDWFC x6F,W
062C4:  MOVWF  FEA
062C6:  MOVFF  FEF,377
062CA:  MOVFF  FEC,378
062CE:  MOVFF  FEC,379
062D2:  MOVFF  FEC,37A
062D6:  MOVLW  1A
062D8:  ADDWF  x6E,W
062DA:  MOVWF  FE9
062DC:  MOVLW  00
062DE:  ADDWFC x6F,W
062E0:  MOVWF  FEA
062E2:  MOVFF  FEF,37B
062E6:  MOVFF  FEC,37C
062EA:  MOVFF  FEC,37D
062EE:  MOVFF  FEC,37E
062F2:  MOVFF  03,3B4
062F6:  MOVFF  01,3B3
062FA:  MOVFF  374,3B6
062FE:  MOVFF  373,3B5
06302:  MOVFF  376,3B8
06306:  MOVFF  375,3B7
0630A:  MOVFF  37A,3BC
0630E:  MOVFF  379,3BB
06312:  MOVFF  378,3BA
06316:  MOVFF  377,3B9
0631A:  MOVFF  37E,3C0
0631E:  MOVFF  37D,3BF
06322:  MOVFF  37C,3BE
06326:  MOVFF  37B,3BD
0632A:  MOVLW  02
0632C:  MOVWF  xC1
0632E:  MOVLW  FF
06330:  MOVWF  xC2
06332:  CLRF   xC4
06334:  CLRF   xC3
06336:  MOVLB  0
06338:  CALL   285A
....................  
....................    ps->smState = TCP_SYN_SENT; 
0633C:  MOVLB  3
0633E:  MOVFF  36E,FE9
06342:  MOVFF  36F,FEA
06346:  MOVLW  01
06348:  MOVWF  FEF
....................    ps->SND_SEQ++; 
0634A:  MOVLW  16
0634C:  ADDWF  x6E,W
0634E:  MOVWF  FE9
06350:  MOVLW  00
06352:  ADDWFC x6F,W
06354:  MOVWF  FEA
06356:  MOVLW  01
06358:  ADDWF  FEE,F
0635A:  MOVLW  00
0635C:  ADDWFC FEE,F
0635E:  ADDWFC FEE,F
06360:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
06362:  MOVLW  1F
06364:  ADDWF  x6E,W
06366:  MOVWF  01
06368:  MOVLW  00
0636A:  ADDWFC x6F,W
0636C:  MOVWF  03
0636E:  MOVFF  01,371
06372:  MOVWF  x72
06374:  MOVLB  0
06376:  CALL   514A
0637A:  MOVFF  372,FEA
0637E:  MOVFF  371,FE9
06382:  MOVFF  02,FEC
06386:  MOVF   FED,F
06388:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
0638C:  MOVLB  3
0638E:  MOVFF  36D,01
.................... } 
06392:  MOVLB  0
06394:  GOTO   6ADE (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
06398:  MOVLB  3
0639A:  MOVF   x69,W
0639C:  MULLW  24
0639E:  MOVF   FF3,W
063A0:  CLRF   x6B
063A2:  MOVWF  x6A
063A4:  MOVLW  8E
063A6:  ADDWF  x6A,W
063A8:  MOVWF  FE9
063AA:  MOVLW  00
063AC:  ADDWFC x6B,W
063AE:  MOVWF  FEA
063B0:  MOVF   FEF,W
063B2:  SUBLW  03
063B4:  BZ    63BA
063B6:  MOVLW  00
063B8:  BRA    63BC
063BA:  MOVLW  01
063BC:  MOVWF  01
.................... } 
063BE:  MOVLB  0
063C0:  GOTO   6B10 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
02A92:  MOVLB  3
02A94:  MOVF   x69,W
02A96:  MULLW  24
02A98:  MOVF   FF3,W
02A9A:  CLRF   03
02A9C:  ADDLW  8E
02A9E:  MOVWF  01
02AA0:  MOVLW  00
02AA2:  ADDWFC 03,F
02AA4:  MOVFF  01,36A
02AA8:  MOVFF  03,36B
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
02AAC:  MOVFF  36A,FE9
02AB0:  MOVFF  36B,FEA
02AB4:  MOVF   FEF,W
02AB6:  SUBLW  03
02AB8:  BZ    2AD8
02ABA:  MOVFF  36A,FE9
02ABE:  MOVFF  36B,FEA
02AC2:  MOVF   FEF,W
02AC4:  SUBLW  02
02AC6:  BZ    2AD8
....................    { 
....................       CloseSocket(ps); 
02AC8:  MOVFF  36B,3B0
02ACC:  MOVFF  36A,3AF
02AD0:  MOVLB  0
02AD2:  CALL   1972
....................       return; 
02AD6:  BRA    2BC8
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
02AD8:  MOVFF  369,36C
02ADC:  MOVLB  0
02ADE:  CALL   1A74
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
02AE2:  MOVLW  01
02AE4:  MOVLB  3
02AE6:  ADDWF  x6A,W
02AE8:  MOVWF  01
02AEA:  MOVLW  00
02AEC:  ADDWFC x6B,W
02AEE:  MOVWF  03
02AF0:  MOVFF  01,36C
02AF4:  MOVWF  x6D
02AF6:  MOVLW  0B
02AF8:  ADDWF  x6A,W
02AFA:  MOVWF  FE9
02AFC:  MOVLW  00
02AFE:  ADDWFC x6B,W
02B00:  MOVWF  FEA
02B02:  MOVFF  FEC,36F
02B06:  MOVF   FED,F
02B08:  MOVFF  FEF,36E
02B0C:  MOVLW  0D
02B0E:  ADDWF  x6A,W
02B10:  MOVWF  FE9
02B12:  MOVLW  00
02B14:  ADDWFC x6B,W
02B16:  MOVWF  FEA
02B18:  MOVFF  FEC,371
02B1C:  MOVF   FED,F
02B1E:  MOVFF  FEF,370
02B22:  MOVLW  16
02B24:  ADDWF  x6A,W
02B26:  MOVWF  FE9
02B28:  MOVLW  00
02B2A:  ADDWFC x6B,W
02B2C:  MOVWF  FEA
02B2E:  MOVFF  FEF,372
02B32:  MOVFF  FEC,373
02B36:  MOVFF  FEC,374
02B3A:  MOVFF  FEC,375
02B3E:  MOVLW  1A
02B40:  ADDWF  x6A,W
02B42:  MOVWF  FE9
02B44:  MOVLW  00
02B46:  ADDWFC x6B,W
02B48:  MOVWF  FEA
02B4A:  MOVFF  FEF,376
02B4E:  MOVFF  FEC,377
02B52:  MOVFF  FEC,378
02B56:  MOVFF  FEC,379
02B5A:  MOVFF  03,3B4
02B5E:  MOVFF  01,3B3
02B62:  MOVFF  36F,3B6
02B66:  MOVFF  36E,3B5
02B6A:  MOVFF  371,3B8
02B6E:  MOVFF  370,3B7
02B72:  MOVFF  375,3BC
02B76:  MOVFF  374,3BB
02B7A:  MOVFF  373,3BA
02B7E:  MOVFF  372,3B9
02B82:  MOVFF  379,3C0
02B86:  MOVFF  378,3BF
02B8A:  MOVFF  377,3BE
02B8E:  MOVFF  376,3BD
02B92:  MOVLW  11
02B94:  MOVWF  xC1
02B96:  MOVLW  FF
02B98:  MOVWF  xC2
02B9A:  CLRF   xC4
02B9C:  CLRF   xC3
02B9E:  MOVLB  0
02BA0:  RCALL  285A
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
02BA2:  MOVLW  16
02BA4:  MOVLB  3
02BA6:  ADDWF  x6A,W
02BA8:  MOVWF  FE9
02BAA:  MOVLW  00
02BAC:  ADDWFC x6B,W
02BAE:  MOVWF  FEA
02BB0:  MOVLW  01
02BB2:  ADDWF  FEE,F
02BB4:  MOVLW  00
02BB6:  ADDWFC FEE,F
02BB8:  ADDWFC FEE,F
02BBA:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
02BBC:  MOVFF  36A,FE9
02BC0:  MOVFF  36B,FEA
02BC4:  MOVLW  04
02BC6:  MOVWF  FEF
02BC8:  MOVLB  0
....................  
....................    return; 
.................... } 
02BCA:  RETLW  00
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0646E:  MOVLB  3
06470:  MOVF   x72,W
06472:  MULLW  24
06474:  MOVF   FF3,W
06476:  CLRF   03
06478:  ADDLW  8E
0647A:  MOVWF  01
0647C:  MOVLW  00
0647E:  ADDWFC 03,F
06480:  MOVFF  01,373
06484:  MOVFF  03,374
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
06488:  MOVLW  0F
0648A:  ADDWF  x73,W
0648C:  MOVWF  FE9
0648E:  MOVLW  00
06490:  ADDWFC x74,W
06492:  MOVWF  FEA
06494:  INCFSZ FEF,W
06496:  BRA    649E
....................       return FALSE; 
06498:  MOVLW  00
0649A:  MOVWF  01
0649C:  BRA    6634
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
0649E:  MOVLW  23
064A0:  ADDWF  x73,W
064A2:  MOVWF  FE9
064A4:  MOVLW  00
064A6:  ADDWFC x74,W
064A8:  MOVWF  FEA
064AA:  MOVLW  00
064AC:  BTFSC  FEF.1
064AE:  MOVLW  01
064B0:  ANDLW  01
064B2:  BNZ   64BA
....................       return FALSE; 
064B4:  MOVLW  00
064B6:  MOVWF  01
064B8:  BRA    6634
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
064BA:  MOVLW  01
064BC:  ADDWF  x73,W
064BE:  MOVWF  01
064C0:  MOVLW  00
064C2:  ADDWFC x74,W
064C4:  MOVWF  03
064C6:  MOVFF  01,375
064CA:  MOVWF  x76
064CC:  MOVLW  0B
064CE:  ADDWF  x73,W
064D0:  MOVWF  FE9
064D2:  MOVLW  00
064D4:  ADDWFC x74,W
064D6:  MOVWF  FEA
064D8:  MOVFF  FEC,378
064DC:  MOVF   FED,F
064DE:  MOVFF  FEF,377
064E2:  MOVLW  0D
064E4:  ADDWF  x73,W
064E6:  MOVWF  FE9
064E8:  MOVLW  00
064EA:  ADDWFC x74,W
064EC:  MOVWF  FEA
064EE:  MOVFF  FEC,37A
064F2:  MOVF   FED,F
064F4:  MOVFF  FEF,379
064F8:  MOVLW  16
064FA:  ADDWF  x73,W
064FC:  MOVWF  FE9
064FE:  MOVLW  00
06500:  ADDWFC x74,W
06502:  MOVWF  FEA
06504:  MOVFF  FEF,37B
06508:  MOVFF  FEC,37C
0650C:  MOVFF  FEC,37D
06510:  MOVFF  FEC,37E
06514:  MOVLW  1A
06516:  ADDWF  x73,W
06518:  MOVWF  FE9
0651A:  MOVLW  00
0651C:  ADDWFC x74,W
0651E:  MOVWF  FEA
06520:  MOVFF  FEF,37F
06524:  MOVFF  FEC,380
06528:  MOVFF  FEC,381
0652C:  MOVFF  FEC,382
06530:  MOVLW  0F
06532:  ADDWF  x73,W
06534:  MOVWF  FE9
06536:  MOVLW  00
06538:  ADDWFC x74,W
0653A:  MOVWF  FEA
0653C:  MOVFF  FEF,383
06540:  MOVLW  10
06542:  ADDWF  x73,W
06544:  MOVWF  FE9
06546:  MOVLW  00
06548:  ADDWFC x74,W
0654A:  MOVWF  FEA
0654C:  MOVFF  FEC,385
06550:  MOVF   FED,F
06552:  MOVFF  FEF,384
06556:  MOVFF  03,3B4
0655A:  MOVFF  01,3B3
0655E:  MOVFF  378,3B6
06562:  MOVFF  377,3B5
06566:  MOVFF  37A,3B8
0656A:  MOVFF  379,3B7
0656E:  MOVFF  37E,3BC
06572:  MOVFF  37D,3BB
06576:  MOVFF  37C,3BA
0657A:  MOVFF  37B,3B9
0657E:  MOVFF  382,3C0
06582:  MOVFF  381,3BF
06586:  MOVFF  380,3BE
0658A:  MOVFF  37F,3BD
0658E:  MOVLW  18
06590:  MOVWF  xC1
06592:  MOVFF  383,3C2
06596:  MOVFF  385,3C4
0659A:  MOVFF  384,3C3
0659E:  MOVLB  0
065A0:  CALL   285A
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
065A4:  MOVLW  16
065A6:  MOVLB  3
065A8:  ADDWF  x73,W
065AA:  MOVWF  01
065AC:  MOVLW  00
065AE:  ADDWFC x74,W
065B0:  MOVWF  03
065B2:  MOVFF  01,375
065B6:  MOVWF  x76
065B8:  MOVWF  FEA
065BA:  MOVFF  01,FE9
065BE:  MOVFF  FEF,377
065C2:  MOVFF  FEC,378
065C6:  MOVFF  FEC,379
065CA:  MOVFF  FEC,37A
065CE:  MOVLW  10
065D0:  ADDWF  x73,W
065D2:  MOVWF  FE9
065D4:  MOVLW  00
065D6:  ADDWFC x74,W
065D8:  MOVWF  FEA
065DA:  MOVFF  FEC,03
065DE:  MOVF   FED,F
065E0:  MOVFF  FEF,00
065E4:  MOVFF  03,01
065E8:  CLRF   02
065EA:  CLRF   03
065EC:  MOVF   x77,W
065EE:  ADDWF  00,F
065F0:  MOVF   x78,W
065F2:  ADDWFC 01,F
065F4:  MOVF   x79,W
065F6:  ADDWFC 02,F
065F8:  MOVF   x7A,W
065FA:  ADDWFC 03,F
065FC:  MOVFF  376,FEA
06600:  MOVFF  375,FE9
06604:  MOVFF  00,FEF
06608:  MOVFF  01,FEC
0660C:  MOVFF  02,FEC
06610:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
06614:  MOVLW  23
06616:  ADDWF  x73,W
06618:  MOVWF  FE9
0661A:  MOVLW  00
0661C:  ADDWFC x74,W
0661E:  MOVWF  FEA
06620:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
06622:  MOVLW  23
06624:  ADDWF  x73,W
06626:  MOVWF  FE9
06628:  MOVLW  00
0662A:  ADDWFC x74,W
0662C:  MOVWF  FEA
0662E:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
06630:  MOVLW  01
06632:  MOVWF  01
.................... } 
06634:  MOVLB  0
06636:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
063D0:  MOVLB  3
063D2:  MOVF   x69,W
063D4:  MULLW  24
063D6:  MOVF   FF3,W
063D8:  CLRF   x6B
063DA:  MOVWF  x6A
063DC:  MOVLW  14
063DE:  ADDWF  x6A,W
063E0:  MOVWF  01
063E2:  MOVLW  00
063E4:  ADDWFC x6B,W
063E6:  MOVWF  03
063E8:  MOVF   01,W
063EA:  ADDLW  8E
063EC:  MOVWF  FE9
063EE:  MOVLW  00
063F0:  ADDWFC 03,W
063F2:  MOVWF  FEA
063F4:  MOVFF  FEC,36B
063F8:  MOVF   FED,F
063FA:  MOVFF  FEF,36A
063FE:  MOVF   x6A,F
06400:  BNZ   640C
06402:  MOVF   x6B,F
06404:  BNZ   640C
....................       return FALSE; 
06406:  MOVLW  00
06408:  MOVWF  01
0640A:  BRA    646A
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0640C:  MOVF   x69,W
0640E:  MULLW  24
06410:  MOVF   FF3,W
06412:  CLRF   x6B
06414:  MOVWF  x6A
06416:  MOVLW  0F
06418:  ADDWF  x6A,W
0641A:  MOVWF  01
0641C:  MOVLW  00
0641E:  ADDWFC x6B,W
06420:  MOVWF  03
06422:  MOVF   01,W
06424:  ADDLW  8E
06426:  MOVWF  FE9
06428:  MOVLW  00
0642A:  ADDWFC 03,W
0642C:  MOVWF  FEA
0642E:  INCFSZ FEF,W
06430:  BRA    6442
....................       return IPIsTxReady(FALSE); 
06432:  CLRF   xEB
06434:  MOVLB  0
06436:  CALL   1AC0
0643A:  MOVF   01,W
0643C:  MOVLB  3
0643E:  BRA    646A
....................    else 
06440:  BRA    646A
....................       return TCB[s].Flags.bIsPutReady; 
06442:  MOVF   x69,W
06444:  MULLW  24
06446:  MOVF   FF3,W
06448:  CLRF   x6B
0644A:  MOVWF  x6A
0644C:  MOVLW  23
0644E:  ADDWF  x6A,F
06450:  MOVLW  00
06452:  ADDWFC x6B,F
06454:  MOVLW  8E
06456:  ADDWF  x6A,W
06458:  MOVWF  FE9
0645A:  MOVLW  00
0645C:  ADDWFC x6B,W
0645E:  MOVWF  FEA
06460:  MOVLW  00
06462:  BTFSC  FEF.1
06464:  MOVLW  01
06466:  MOVWF  01
06468:  BRA    646A
.................... } 
0646A:  MOVLB  0
0646C:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
....................       return(0); 
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
....................       txCount = 0; 
....................    else 
....................       txCount = TCB[s].TxCount; 
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
....................  
....................    return(txAvail); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................     
....................    if (n>len) n=len; //AGREGADO 
....................     
....................    while (n--)   
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(n); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
06638:  MOVLB  3
0663A:  MOVF   x6C,W
0663C:  MULLW  24
0663E:  MOVF   FF3,W
06640:  CLRF   03
06642:  ADDLW  8E
06644:  MOVWF  01
06646:  MOVLW  00
06648:  ADDWFC 03,F
0664A:  MOVFF  01,36E
0664E:  MOVFF  03,36F
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
06652:  MOVLW  14
06654:  ADDWF  x6E,W
06656:  MOVWF  FE9
06658:  MOVLW  00
0665A:  ADDWFC x6F,W
0665C:  MOVWF  FEA
0665E:  MOVFF  FEC,373
06662:  MOVF   FED,F
06664:  MOVFF  FEF,372
06668:  MOVF   x72,F
0666A:  BNZ   6676
0666C:  MOVF   x73,F
0666E:  BNZ   6676
....................       return FALSE; 
06670:  MOVLW  00
06672:  MOVWF  01
06674:  BRA    677E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
06676:  MOVLW  0F
06678:  ADDWF  x6E,W
0667A:  MOVWF  FE9
0667C:  MOVLW  00
0667E:  ADDWFC x6F,W
06680:  MOVWF  FEA
06682:  INCFSZ FEF,W
06684:  BRA    66FA
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
06686:  MOVLW  0F
06688:  ADDWF  x6E,W
0668A:  MOVWF  01
0668C:  MOVLW  00
0668E:  ADDWFC x6F,W
06690:  MOVWF  03
06692:  MOVFF  01,372
06696:  MOVWF  x73
06698:  CLRF   xEB
0669A:  MOVLB  0
0669C:  CALL   1AEA
066A0:  MOVFF  373,FEA
066A4:  MOVFF  372,FE9
066A8:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
066AC:  MOVLW  0F
066AE:  MOVLB  3
066B0:  ADDWF  x6E,W
066B2:  MOVWF  FE9
066B4:  MOVLW  00
066B6:  ADDWFC x6F,W
066B8:  MOVWF  FEA
066BA:  INCFSZ FEF,W
066BC:  BRA    66C4
....................          return FALSE; 
066BE:  MOVLW  00
066C0:  MOVWF  01
066C2:  BRA    677E
....................  
....................       ps->TxCount = 0; 
066C4:  MOVLW  10
066C6:  ADDWF  x6E,W
066C8:  MOVWF  FE9
066CA:  MOVLW  00
066CC:  ADDWFC x6F,W
066CE:  MOVWF  FEA
066D0:  CLRF   FEC
066D2:  MOVF   FED,F
066D4:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
066D6:  MOVLW  0F
066D8:  ADDWF  x6E,W
066DA:  MOVWF  FE9
066DC:  MOVLW  00
066DE:  ADDWFC x6F,W
066E0:  MOVWF  FEA
066E2:  MOVFF  FEF,372
066E6:  MOVFF  372,404
066EA:  MOVLB  4
066EC:  CLRF   x06
066EE:  MOVLW  28
066F0:  MOVWF  x05
066F2:  MOVLB  0
066F4:  CALL   1B14
066F8:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
066FA:  MOVLW  23
066FC:  ADDWF  x6E,W
066FE:  MOVWF  FE9
06700:  MOVLW  00
06702:  ADDWFC x6F,W
06704:  MOVWF  FEA
06706:  BSF    FEF.4
....................  
....................    MACPut(byte); 
06708:  MOVFF  36D,40E
0670C:  MOVLB  0
0670E:  CALL   20FE
....................    ps->RemoteWindow--; 
06712:  MOVLW  14
06714:  MOVLB  3
06716:  ADDWF  x6E,W
06718:  MOVWF  FE9
0671A:  MOVLW  00
0671C:  ADDWFC x6F,W
0671E:  MOVWF  FEA
06720:  MOVLW  FF
06722:  ADDWF  FEF,F
06724:  BC    672A
06726:  MOVF   FEE,F
06728:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
0672A:  MOVLW  10
0672C:  ADDWF  x6E,W
0672E:  MOVWF  FE9
06730:  MOVLW  00
06732:  ADDWFC x6F,W
06734:  MOVWF  FEA
06736:  MOVFF  FEC,03
0673A:  MOVF   FED,F
0673C:  MOVFF  FEF,370
06740:  MOVFF  03,371
....................    tempCount++; 
06744:  INCF   x70,F
06746:  BTFSC  FD8.2
06748:  INCF   x71,F
....................    ps->TxCount = tempCount; 
0674A:  MOVLW  10
0674C:  ADDWF  x6E,W
0674E:  MOVWF  FE9
06750:  MOVLW  00
06752:  ADDWFC x6F,W
06754:  MOVWF  FEA
06756:  MOVFF  371,FEC
0675A:  MOVF   FED,F
0675C:  MOVFF  370,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
06760:  MOVF   x71,W
06762:  SUBLW  02
06764:  BC    677A
06766:  XORLW  FF
06768:  BNZ   6770
0676A:  MOVF   x70,W
0676C:  SUBLW  C9
0676E:  BC    677A
....................       TCPFlush(s); 
06770:  MOVFF  36C,372
06774:  MOVLB  0
06776:  RCALL  646E
06778:  MOVLB  3
....................  
....................    return TRUE; 
0677A:  MOVLW  01
0677C:  MOVWF  01
.................... } 
0677E:  MOVLB  0
06780:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
01A74:  MOVLB  3
01A76:  MOVF   x6C,W
01A78:  MULLW  24
01A7A:  MOVF   FF3,W
01A7C:  CLRF   03
01A7E:  ADDLW  8E
01A80:  MOVWF  01
01A82:  MOVLW  00
01A84:  ADDWFC 03,F
01A86:  MOVFF  01,36D
01A8A:  MOVFF  03,36E
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
01A8E:  MOVLW  23
01A90:  ADDWF  x6D,W
01A92:  MOVWF  FE9
01A94:  MOVLW  00
01A96:  ADDWFC x6E,W
01A98:  MOVWF  FEA
01A9A:  BTFSC  FEF.3
01A9C:  BRA    1AA4
....................         return FALSE; 
01A9E:  MOVLW  00
01AA0:  MOVWF  01
01AA2:  BRA    1ABC
....................  
....................     MACDiscardRx(); 
01AA4:  MOVLB  0
01AA6:  RCALL  1908
....................     ps->Flags.bIsGetReady = FALSE; 
01AA8:  MOVLW  23
01AAA:  MOVLB  3
01AAC:  ADDWF  x6D,W
01AAE:  MOVWF  FE9
01AB0:  MOVLW  00
01AB2:  ADDWFC x6E,W
01AB4:  MOVWF  FEA
01AB6:  BCF    FEF.3
....................  
....................     return TRUE; 
01AB8:  MOVLW  01
01ABA:  MOVWF  01
.................... } 
01ABC:  MOVLB  0
01ABE:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
067BA:  MOVLB  3
067BC:  MOVF   x6C,W
067BE:  MULLW  24
067C0:  MOVF   FF3,W
067C2:  CLRF   03
067C4:  ADDLW  8E
067C6:  MOVWF  01
067C8:  MOVLW  00
067CA:  ADDWFC 03,F
067CC:  MOVFF  01,36F
067D0:  MOVFF  03,370
....................  
....................     if ( ps->Flags.bIsGetReady ) 
067D4:  MOVLW  23
067D6:  ADDWF  x6F,W
067D8:  MOVWF  FE9
067DA:  MOVLW  00
067DC:  ADDWFC x70,W
067DE:  MOVWF  FEA
067E0:  BTFSS  FEF.3
067E2:  BRA    6886
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
067E4:  MOVLW  23
067E6:  ADDWF  x6F,W
067E8:  MOVWF  FE9
067EA:  MOVLW  00
067EC:  ADDWFC x70,W
067EE:  MOVWF  FEA
067F0:  BTFSS  FEF.2
067F2:  BRA    6810
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
067F4:  CLRF   x93
067F6:  MOVLW  14
067F8:  MOVWF  x92
067FA:  MOVLB  0
067FC:  CALL   4BA0
....................  
....................             ps->Flags.bFirstRead = FALSE; 
06800:  MOVLW  23
06802:  MOVLB  3
06804:  ADDWF  x6F,W
06806:  MOVWF  FE9
06808:  MOVLW  00
0680A:  ADDWFC x70,W
0680C:  MOVWF  FEA
0680E:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
06810:  MOVLW  12
06812:  ADDWF  x6F,W
06814:  MOVWF  FE9
06816:  MOVLW  00
06818:  ADDWFC x70,W
0681A:  MOVWF  FEA
0681C:  MOVFF  FEC,372
06820:  MOVF   FED,F
06822:  MOVFF  FEF,371
06826:  MOVF   x71,F
06828:  BNZ   684A
0682A:  MOVF   x72,F
0682C:  BNZ   684A
....................         { 
....................             MACDiscardRx(); 
0682E:  MOVLB  0
06830:  CALL   1908
....................             ps->Flags.bIsGetReady = FALSE; 
06834:  MOVLW  23
06836:  MOVLB  3
06838:  ADDWF  x6F,W
0683A:  MOVWF  FE9
0683C:  MOVLW  00
0683E:  ADDWFC x70,W
06840:  MOVWF  FEA
06842:  BCF    FEF.3
....................             return FALSE; 
06844:  MOVLW  00
06846:  MOVWF  01
06848:  BRA    688A
....................         } 
....................  
....................          ps->RxCount--; 
0684A:  MOVLW  12
0684C:  ADDWF  x6F,W
0684E:  MOVWF  FE9
06850:  MOVLW  00
06852:  ADDWFC x70,W
06854:  MOVWF  FEA
06856:  MOVLW  FF
06858:  ADDWF  FEF,F
0685A:  BC    6860
0685C:  MOVF   FEE,F
0685E:  DECF   FED,F
....................          *data = MACGet(); 
06860:  MOVFF  36E,03
06864:  MOVFF  36D,371
06868:  MOVFF  36E,372
0686C:  MOVLB  0
0686E:  CALL   2438
06872:  MOVFF  372,FEA
06876:  MOVFF  371,FE9
0687A:  MOVFF  01,FEF
....................         return TRUE; 
0687E:  MOVLW  01
06880:  MOVWF  01
06882:  MOVLB  3
06884:  BRA    688A
....................     } 
....................     return FALSE; 
06886:  MOVLW  00
06888:  MOVWF  01
.................... } 
0688A:  MOVLB  0
0688C:  GOTO   68A2 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
0678E:  MOVLB  3
06790:  MOVF   x69,W
06792:  MULLW  24
06794:  MOVF   FF3,W
06796:  CLRF   x6B
06798:  MOVWF  x6A
0679A:  MOVLW  23
0679C:  ADDWF  x6A,F
0679E:  MOVLW  00
067A0:  ADDWFC x6B,F
067A2:  MOVLW  8E
067A4:  ADDWF  x6A,W
067A6:  MOVWF  FE9
067A8:  MOVLW  00
067AA:  ADDWFC x6B,W
067AC:  MOVWF  FEA
067AE:  MOVLW  00
067B0:  BTFSC  FEF.3
067B2:  MOVLW  01
067B4:  MOVWF  01
.................... } 
067B6:  MOVLB  0
067B8:  RETLW  00
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
072B2:  MOVLB  3
072B4:  CLRF   x70
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
072B6:  CLRF   x65
072B8:  MOVF   x65,W
072BA:  SUBLW  04
072BC:  BTFSS  FD8.0
072BE:  BRA    7746
....................    { 
....................       ps = &TCB[s]; 
072C0:  MOVF   x65,W
072C2:  MULLW  24
072C4:  MOVF   FF3,W
072C6:  CLRF   03
072C8:  ADDLW  8E
072CA:  MOVWF  01
072CC:  MOVLW  00
072CE:  ADDWFC 03,F
072D0:  MOVFF  01,36A
072D4:  MOVFF  03,36B
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
072D8:  MOVLW  23
072DA:  ADDWF  x6A,W
072DC:  MOVWF  FE9
072DE:  MOVLW  00
072E0:  ADDWFC x6B,W
072E2:  MOVWF  FEA
072E4:  BTFSC  FEF.3
072E6:  BRA    72F8
072E8:  MOVLW  23
072EA:  ADDWF  x6A,W
072EC:  MOVWF  FE9
072EE:  MOVLW  00
072F0:  ADDWFC x6B,W
072F2:  MOVWF  FEA
072F4:  BTFSS  FEF.4
072F6:  BRA    72FA
....................          continue; 
072F8:  BRA    7742
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
072FA:  MOVFF  36A,FE9
072FE:  MOVFF  36B,FEA
07302:  MOVF   FEF,W
07304:  SUBLW  0A
07306:  BZ    732C
07308:  MOVFF  36A,FE9
0730C:  MOVFF  36B,FEA
07310:  MOVF   FEF,F
07312:  BNZ   732E
07314:  MOVLW  23
07316:  ADDWF  x6A,W
07318:  MOVWF  FE9
0731A:  MOVLW  00
0731C:  ADDWFC x6B,W
0731E:  MOVWF  FEA
07320:  MOVLW  00
07322:  BTFSC  FEF.0
07324:  MOVLW  01
07326:  ANDLW  01
07328:  SUBLW  01
0732A:  BNZ   732E
....................          continue; 
0732C:  BRA    7742
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
0732E:  MOVFF  36A,FE9
07332:  MOVFF  36B,FEA
07336:  MOVF   FEF,W
07338:  SUBLW  03
0733A:  BNZ   7356
0733C:  MOVLW  23
0733E:  ADDWF  x6A,W
07340:  MOVWF  FE9
07342:  MOVLW  00
07344:  ADDWFC x6B,W
07346:  MOVWF  FEA
07348:  MOVLW  00
0734A:  BTFSC  FEF.0
0734C:  MOVLW  01
0734E:  ANDLW  01
07350:  SUBLW  01
07352:  BNZ   7356
....................          continue; 
07354:  BRA    7742
....................  
....................  
....................       tick = TickGet(); 
07356:  MOVLB  0
07358:  CALL   514A
0735C:  MOVFF  02,369
07360:  MOVFF  01,368
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
07364:  MOVLW  1F
07366:  MOVLB  3
07368:  ADDWF  x6A,W
0736A:  MOVWF  FE9
0736C:  MOVLW  00
0736E:  ADDWFC x6B,W
07370:  MOVWF  FEA
07372:  MOVFF  FEC,03
07376:  MOVF   FED,F
07378:  MOVFF  FEF,01
0737C:  MOVF   x69,W
0737E:  SUBWF  03,W
07380:  BNC   738A
07382:  BNZ   738E
07384:  MOVF   01,W
07386:  SUBWF  x68,W
07388:  BNC   738E
0738A:  MOVLW  00
0738C:  BRA    7390
0738E:  MOVLW  01
07390:  CLRF   03
07392:  IORWF  03,W
07394:  BZ    73CC
07396:  MOVLW  1F
07398:  ADDWF  x6A,W
0739A:  MOVWF  FE9
0739C:  MOVLW  00
0739E:  ADDWFC x6B,W
073A0:  MOVWF  FEA
073A2:  MOVFF  FEC,03
073A6:  MOVF   FED,F
073A8:  MOVF   FEF,W
073AA:  SUBLW  FF
073AC:  MOVWF  x71
073AE:  MOVLW  FF
073B0:  SUBFWB 03,W
073B2:  MOVWF  x72
073B4:  MOVF   x68,W
073B6:  ADDWF  x71,F
073B8:  MOVF   x69,W
073BA:  ADDWFC x72,F
073BC:  MOVLW  01
073BE:  ADDWF  x71,W
073C0:  MOVWF  01
073C2:  MOVLW  00
073C4:  ADDWFC x72,W
073C6:  MOVWF  03
073C8:  MOVF   01,W
073CA:  BRA    73EC
073CC:  MOVLW  1F
073CE:  ADDWF  x6A,W
073D0:  MOVWF  FE9
073D2:  MOVLW  00
073D4:  ADDWFC x6B,W
073D6:  MOVWF  FEA
073D8:  MOVFF  FEC,03
073DC:  MOVF   FED,F
073DE:  MOVF   FEF,W
073E0:  SUBWF  x68,W
073E2:  MOVWF  00
073E4:  MOVF   03,W
073E6:  SUBWFB x69,W
073E8:  MOVWF  03
073EA:  MOVF   00,W
073EC:  MOVWF  x66
073EE:  MOVFF  03,367
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
073F2:  MOVLW  21
073F4:  ADDWF  x6A,W
073F6:  MOVWF  FE9
073F8:  MOVLW  00
073FA:  ADDWFC x6B,W
073FC:  MOVWF  FEA
073FE:  MOVFF  FEC,03
07402:  MOVF   FED,F
07404:  MOVFF  FEF,01
07408:  MOVF   x67,W
0740A:  SUBWF  03,W
0740C:  BNC   7418
0740E:  BNZ   7416
07410:  MOVF   x66,W
07412:  SUBWF  01,W
07414:  BNC   7418
....................          continue; 
07416:  BRA    7742
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
07418:  MOVLW  01
0741A:  MOVWF  xEB
0741C:  MOVLB  0
0741E:  CALL   1AC0
07422:  MOVF   01,F
07424:  BNZ   7428
....................          return; 
07426:  BRA    7746
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
07428:  MOVLW  1F
0742A:  MOVLB  3
0742C:  ADDWF  x6A,W
0742E:  MOVWF  01
07430:  MOVLW  00
07432:  ADDWFC x6B,W
07434:  MOVWF  03
07436:  MOVFF  01,371
0743A:  MOVWF  x72
0743C:  MOVLB  0
0743E:  CALL   514A
07442:  MOVFF  372,FEA
07446:  MOVFF  371,FE9
0744A:  MOVFF  02,FEC
0744E:  MOVF   FED,F
07450:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
07454:  MOVLW  21
07456:  MOVLB  3
07458:  ADDWF  x6A,W
0745A:  MOVWF  FE9
0745C:  MOVLW  00
0745E:  ADDWFC x6B,W
07460:  MOVWF  FEA
07462:  BCF    FD8.0
07464:  RLCF   FEF,W
07466:  MOVWF  02
07468:  RLCF   FEC,W
0746A:  MOVWF  03
0746C:  MOVF   02,W
0746E:  MOVF   FED,F
07470:  MOVWF  FEF
07472:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
07476:  MOVLW  1E
07478:  ADDWF  x6A,W
0747A:  MOVWF  FE9
0747C:  MOVLW  00
0747E:  ADDWFC x6B,W
07480:  MOVWF  FEA
07482:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
07484:  MOVFF  36A,FE9
07488:  MOVFF  36B,FEA
0748C:  MOVLW  01
0748E:  SUBWF  FEF,W
07490:  ADDLW  F7
07492:  BTFSC  FD8.0
07494:  BRA    7626
07496:  ADDLW  09
07498:  MOVLB  0
0749A:  GOTO   774C
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
0749E:  MOVLW  02
074A0:  MOVLB  3
074A2:  MOVWF  x70
....................          break; 
074A4:  BRA    7626
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
074A6:  MOVLW  1E
074A8:  MOVLB  3
074AA:  ADDWF  x6A,W
074AC:  MOVWF  FE9
074AE:  MOVLW  00
074B0:  ADDWFC x6B,W
074B2:  MOVWF  FEA
074B4:  MOVF   FEF,W
074B6:  SUBLW  03
074B8:  BNC   74C0
....................          { 
....................             flags = SYN | ACK; 
074BA:  MOVLW  12
074BC:  MOVWF  x70
....................          } 
....................          else 
074BE:  BRA    74EC
....................          { 
....................             if(ps->Flags.bServer) 
074C0:  MOVLW  23
074C2:  ADDWF  x6A,W
074C4:  MOVWF  FE9
074C6:  MOVLW  00
074C8:  ADDWFC x6B,W
074CA:  MOVWF  FEA
074CC:  BTFSS  FEF.0
074CE:  BRA    74DC
....................             { 
....................                ps->smState = TCP_LISTEN; 
074D0:  MOVFF  36A,FE9
074D4:  MOVFF  36B,FEA
074D8:  CLRF   FEF
....................             } 
....................             else 
074DA:  BRA    74EC
....................             { 
....................                flags = SYN; 
074DC:  MOVLW  02
074DE:  MOVWF  x70
....................                ps->smState = TCP_SYN_SENT; 
074E0:  MOVFF  36A,FE9
074E4:  MOVFF  36B,FEA
074E8:  MOVLW  01
074EA:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
074EC:  BRA    7626
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
074EE:  MOVLW  1E
074F0:  MOVLB  3
074F2:  ADDWF  x6A,W
074F4:  MOVWF  FE9
074F6:  MOVLW  00
074F8:  ADDWFC x6B,W
074FA:  MOVWF  FEA
074FC:  MOVF   FEF,W
074FE:  SUBLW  03
07500:  BNC   7546
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
07502:  MOVLW  0F
07504:  ADDWF  x6A,W
07506:  MOVWF  FE9
07508:  MOVLW  00
0750A:  ADDWFC x6B,W
0750C:  MOVWF  FEA
0750E:  INCFSZ FEF,W
07510:  BRA    7514
07512:  BRA    753C
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
07514:  MOVLW  0F
07516:  ADDWF  x6A,W
07518:  MOVWF  FE9
0751A:  MOVLW  00
0751C:  ADDWFC x6B,W
0751E:  MOVWF  FEA
07520:  MOVFF  FEF,371
07524:  MOVFF  371,404
07528:  MOVLB  4
0752A:  CLRF   x06
0752C:  CLRF   x05
0752E:  MOVLB  0
07530:  CALL   1B14
....................                MACFlush(); 
07534:  CALL   2622
....................             } 
....................             else 
07538:  BRA    7542
0753A:  MOVLB  3
....................                flags = ACK; 
0753C:  MOVLW  10
0753E:  MOVWF  x70
07540:  MOVLB  0
....................          } 
....................          else 
07542:  BRA    7594
07544:  MOVLB  3
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
07546:  MOVLW  0F
07548:  ADDWF  x6A,W
0754A:  MOVWF  FE9
0754C:  MOVLW  00
0754E:  ADDWFC x6B,W
07550:  MOVWF  FEA
07552:  INCFSZ FEF,W
07554:  BRA    7558
07556:  BRA    7584
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
07558:  MOVLW  0F
0755A:  ADDWF  x6A,W
0755C:  MOVWF  FE9
0755E:  MOVLW  00
07560:  ADDWFC x6B,W
07562:  MOVWF  FEA
07564:  MOVFF  FEF,371
07568:  MOVFF  371,3B2
0756C:  MOVLB  0
0756E:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
07572:  MOVLW  0F
07574:  MOVLB  3
07576:  ADDWF  x6A,W
07578:  MOVWF  FE9
0757A:  MOVLW  00
0757C:  ADDWFC x6B,W
0757E:  MOVWF  FEA
07580:  MOVLW  FF
07582:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
07584:  MOVLW  11
07586:  MOVWF  x70
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
07588:  MOVFF  36A,FE9
0758C:  MOVFF  36B,FEA
07590:  MOVLW  04
07592:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
07594:  MOVLB  3
07596:  BRA    7626
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
07598:  MOVLW  1E
0759A:  MOVLB  3
0759C:  ADDWF  x6A,W
0759E:  MOVWF  FE9
075A0:  MOVLW  00
075A2:  ADDWFC x6B,W
075A4:  MOVWF  FEA
075A6:  MOVF   FEF,W
075A8:  SUBLW  03
075AA:  BNC   75B2
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
075AC:  MOVLW  01
075AE:  MOVWF  x70
....................          } 
....................          else 
075B0:  BRA    75C2
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
075B2:  MOVFF  36B,3B0
075B6:  MOVFF  36A,3AF
075BA:  MOVLB  0
075BC:  CALL   1972
075C0:  MOVLB  3
....................          } 
....................          break; 
075C2:  BRA    7626
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
075C4:  MOVFF  36B,3B0
075C8:  MOVFF  36A,3AF
075CC:  CALL   1972
....................          break; 
075D0:  MOVLB  3
075D2:  BRA    7626
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
075D4:  MOVFF  36B,3B0
075D8:  MOVFF  36A,3AF
075DC:  CALL   1972
....................          break; 
075E0:  MOVLB  3
075E2:  BRA    7626
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
075E4:  MOVLW  01
075E6:  MOVLB  3
075E8:  MOVWF  x70
....................          ps->smState = TCP_LAST_ACK; 
075EA:  MOVFF  36A,FE9
075EE:  MOVFF  36B,FEA
075F2:  MOVLW  09
075F4:  MOVWF  FEF
....................          break; 
075F6:  BRA    7626
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
075F8:  MOVLW  1E
075FA:  MOVLB  3
075FC:  ADDWF  x6A,W
075FE:  MOVWF  FE9
07600:  MOVLW  00
07602:  ADDWFC x6B,W
07604:  MOVWF  FEA
07606:  MOVF   FEF,W
07608:  SUBLW  03
0760A:  BNC   7612
....................             flags = FIN; 
0760C:  MOVLW  01
0760E:  MOVWF  x70
....................          else 
07610:  BRA    7622
....................             CloseSocket(ps); 
07612:  MOVFF  36B,3B0
07616:  MOVFF  36A,3AF
0761A:  MOVLB  0
0761C:  CALL   1972
07620:  MOVLB  3
....................          break; 
07622:  BRA    7626
07624:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
07626:  MOVF   x70,F
07628:  BTFSC  FD8.2
0762A:  BRA    7742
....................       { 
....................          if(flags & ACK) 
0762C:  BTFSS  x70.4
0762E:  BRA    765E
....................             seq = ps->SND_SEQ; 
07630:  MOVLW  16
07632:  ADDWF  x6A,W
07634:  MOVWF  FE9
07636:  MOVLW  00
07638:  ADDWFC x6B,W
0763A:  MOVWF  FEA
0763C:  MOVFF  FEF,00
07640:  MOVFF  FEC,01
07644:  MOVFF  FEC,02
07648:  MOVFF  FEC,03
0764C:  MOVFF  03,36F
07650:  MOVFF  02,36E
07654:  MOVFF  01,36D
07658:  MOVFF  00,36C
....................          else 
0765C:  BRA    769C
....................             seq = ps->SND_SEQ++; 
0765E:  MOVLW  16
07660:  ADDWF  x6A,W
07662:  MOVWF  FE9
07664:  MOVLW  00
07666:  ADDWFC x6B,W
07668:  MOVWF  FEA
0766A:  MOVF   FEE,F
0766C:  MOVF   FEE,F
0766E:  MOVF   FEE,F
07670:  MOVFF  FED,03
07674:  MOVFF  FED,02
07678:  MOVFF  FED,01
0767C:  MOVFF  FEF,00
07680:  MOVLW  01
07682:  ADDWF  FEE,F
07684:  MOVLW  00
07686:  ADDWFC FEE,F
07688:  ADDWFC FEE,F
0768A:  ADDWFC FED,F
0768C:  MOVFF  03,36F
07690:  MOVFF  02,36E
07694:  MOVFF  01,36D
07698:  MOVFF  00,36C
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
0769C:  MOVLW  01
0769E:  ADDWF  x6A,W
076A0:  MOVWF  01
076A2:  MOVLW  00
076A4:  ADDWFC x6B,W
076A6:  MOVWF  03
076A8:  MOVFF  01,371
076AC:  MOVWF  x72
076AE:  MOVLW  0B
076B0:  ADDWF  x6A,W
076B2:  MOVWF  FE9
076B4:  MOVLW  00
076B6:  ADDWFC x6B,W
076B8:  MOVWF  FEA
076BA:  MOVFF  FEC,374
076BE:  MOVF   FED,F
076C0:  MOVFF  FEF,373
076C4:  MOVLW  0D
076C6:  ADDWF  x6A,W
076C8:  MOVWF  FE9
076CA:  MOVLW  00
076CC:  ADDWFC x6B,W
076CE:  MOVWF  FEA
076D0:  MOVFF  FEC,376
076D4:  MOVF   FED,F
076D6:  MOVFF  FEF,375
076DA:  MOVLW  1A
076DC:  ADDWF  x6A,W
076DE:  MOVWF  FE9
076E0:  MOVLW  00
076E2:  ADDWFC x6B,W
076E4:  MOVWF  FEA
076E6:  MOVFF  FEF,377
076EA:  MOVFF  FEC,378
076EE:  MOVFF  FEC,379
076F2:  MOVFF  FEC,37A
076F6:  MOVFF  03,3B4
076FA:  MOVFF  01,3B3
076FE:  MOVFF  374,3B6
07702:  MOVFF  373,3B5
07706:  MOVFF  376,3B8
0770A:  MOVFF  375,3B7
0770E:  MOVFF  36F,3BC
07712:  MOVFF  36E,3BB
07716:  MOVFF  36D,3BA
0771A:  MOVFF  36C,3B9
0771E:  MOVFF  37A,3C0
07722:  MOVFF  379,3BF
07726:  MOVFF  378,3BE
0772A:  MOVFF  377,3BD
0772E:  MOVFF  370,3C1
07732:  MOVLW  FF
07734:  MOVWF  xC2
07736:  CLRF   xC4
07738:  CLRF   xC3
0773A:  MOVLB  0
0773C:  CALL   285A
07740:  MOVLB  3
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
07742:  INCF   x65,F
07744:  BRA    72B8
07746:  MOVLB  0
.................... } 
07748:  GOTO   8A42 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
05C36:  MOVLW  06
05C38:  MOVLB  3
05C3A:  ADDWF  x65,W
05C3C:  MOVWF  FE9
05C3E:  MOVLW  00
05C40:  ADDWFC x66,W
05C42:  MOVWF  FEA
05C44:  MOVFF  FEF,00
05C48:  MOVFF  FEC,01
05C4C:  MOVFF  FEC,02
05C50:  MOVFF  FEC,03
05C54:  MOVFF  03,382
05C58:  MOVFF  02,381
05C5C:  MOVFF  01,380
05C60:  MOVFF  00,37F
....................    pseudoHeader.DestAddress        = *localIP; 
05C64:  MOVFF  367,FE9
05C68:  MOVFF  368,FEA
05C6C:  MOVFF  FEF,00
05C70:  MOVFF  FEC,01
05C74:  MOVFF  FEC,02
05C78:  MOVFF  FEC,03
05C7C:  MOVFF  03,386
05C80:  MOVFF  02,385
05C84:  MOVFF  01,384
05C88:  MOVFF  00,383
....................    pseudoHeader.Zero               = 0x0; 
05C8C:  CLRF   x87
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
05C8E:  MOVLW  06
05C90:  MOVWF  x88
....................    pseudoHeader.TCPLength          = len; 
05C92:  MOVFF  36A,38A
05C96:  MOVFF  369,389
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
05C9A:  MOVFF  38A,40B
05C9E:  MOVFF  389,40A
05CA2:  MOVLB  0
05CA4:  CALL   1CDA
05CA8:  MOVFF  02,38A
05CAC:  MOVFF  01,389
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
05CB0:  MOVLW  03
05CB2:  MOVLB  3
05CB4:  MOVWF  x92
05CB6:  MOVLW  7F
05CB8:  MOVFF  392,3EE
05CBC:  MOVWF  xED
05CBE:  CLRF   xF0
05CC0:  MOVLW  0C
05CC2:  MOVWF  xEF
05CC4:  MOVLB  0
05CC6:  CALL   1F2E
05CCA:  MOVFF  01,38C
05CCE:  MOVLB  3
05CD0:  COMF   x8C,F
05CD2:  MOVFF  02,38D
05CD6:  COMF   x8D,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
05CD8:  MOVFF  36A,3EC
05CDC:  MOVFF  369,3EB
05CE0:  MOVLB  0
05CE2:  CALL   2460
05CE6:  MOVFF  02,38F
05CEA:  MOVFF  01,38E
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
05CEE:  MOVLB  3
05CF0:  MOVF   x8F,W
05CF2:  SUBWF  x8C,W
05CF4:  BNZ   5CFC
05CF6:  MOVF   x8E,W
05CF8:  SUBWF  x8D,W
05CFA:  BZ    5D0A
....................    { 
....................       MACDiscardRx(); 
05CFC:  MOVLB  0
05CFE:  CALL   1908
....................       return TRUE; 
05D02:  MOVLW  01
05D04:  MOVWF  01
05D06:  BRA    5DDE
05D08:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
05D0A:  CLRF   x93
05D0C:  CLRF   x92
05D0E:  MOVLB  0
05D10:  CALL   4BA0
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
05D14:  MOVLW  03
05D16:  MOVLB  3
05D18:  MOVWF  x92
05D1A:  MOVLW  6B
05D1C:  MOVFF  392,3FA
05D20:  MOVWF  xF9
05D22:  CLRF   xFC
05D24:  MOVLW  14
05D26:  MOVWF  xFB
05D28:  MOVLB  0
05D2A:  CALL   25BE
....................    SwapTCPHeader(&TCPHeader); 
05D2E:  MOVLW  03
05D30:  MOVLB  3
05D32:  MOVWF  xEC
05D34:  MOVLW  6B
05D36:  MOVWF  xEB
05D38:  MOVLB  0
05D3A:  CALL   1D12
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
05D3E:  MOVLB  3
05D40:  SWAPF  x77,W
05D42:  ANDLW  0F
05D44:  MOVWF  00
05D46:  RLCF   00,W
05D48:  MOVWF  x91
05D4A:  RLCF   x91,F
05D4C:  MOVLW  FC
05D4E:  ANDWF  x91,F
05D50:  MOVLW  14
05D52:  SUBWF  x91,W
05D54:  MOVWF  x90
....................    len = len - optionsSize - sizeof(TCPHeader); 
05D56:  MOVF   x90,W
05D58:  SUBWF  x69,W
05D5A:  MOVWF  x91
05D5C:  MOVLW  00
05D5E:  SUBWFB x6A,W
05D60:  MOVWF  x92
05D62:  MOVLW  14
05D64:  SUBWF  x91,W
05D66:  MOVWF  x69
05D68:  MOVLW  00
05D6A:  SUBWFB x92,W
05D6C:  MOVWF  x6A
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
05D6E:  SWAPF  x77,W
05D70:  ANDLW  0F
05D72:  MOVWF  00
05D74:  RLCF   00,W
05D76:  MOVWF  x91
05D78:  RLCF   x91,F
05D7A:  MOVLW  FC
05D7C:  ANDWF  x91,F
05D7E:  CLRF   x93
05D80:  MOVFF  391,392
05D84:  MOVLB  0
05D86:  CALL   4BA0
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
05D8A:  MOVLW  03
05D8C:  MOVLB  3
05D8E:  MOVWF  x92
05D90:  MOVLW  6B
05D92:  MOVWF  x91
05D94:  MOVFF  366,394
05D98:  MOVFF  365,393
05D9C:  MOVLB  0
05D9E:  GOTO   4F6C
05DA2:  MOVFF  01,38B
....................    if(socket != INVALID_SOCKET) 
05DA6:  MOVLB  3
05DA8:  MOVF   x8B,W
05DAA:  SUBLW  FE
05DAC:  BZ    5DD4
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
05DAE:  MOVFF  38B,391
05DB2:  MOVFF  366,393
05DB6:  MOVFF  365,392
05DBA:  MOVLW  03
05DBC:  MOVWF  x95
05DBE:  MOVLW  6B
05DC0:  MOVWF  x94
05DC2:  MOVFF  36A,397
05DC6:  MOVFF  369,396
05DCA:  MOVLB  0
05DCC:  GOTO   5164
....................    } 
....................    else 
05DD0:  BRA    5DDA
05DD2:  MOVLB  3
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
05DD4:  MOVLB  0
05DD6:  CALL   1908
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
05DDA:  MOVLW  01
05DDC:  MOVWF  01
.................... } 
05DDE:  GOTO   897A (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
0285A:  MOVLW  01
0285C:  MOVLB  3
0285E:  MOVWF  xEB
02860:  MOVLB  0
02862:  CALL   1AC0
02866:  MOVF   01,F
02868:  BZ    285A
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
0286A:  MOVLB  3
0286C:  INCFSZ xC2,W
0286E:  BRA    2880
....................       buff = MACGetTxBuffer(TRUE); 
02870:  MOVLW  01
02872:  MOVWF  xEB
02874:  MOVLB  0
02876:  CALL   1AEA
0287A:  MOVFF  01,3C2
0287E:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
02880:  INCFSZ xC2,W
02882:  BRA    2886
....................       return; 
02884:  BRA    2A8E
....................  
....................    IPSetTxBuffer(buff, 0); 
02886:  MOVFF  3C2,404
0288A:  MOVLB  4
0288C:  CLRF   x06
0288E:  MOVLW  14
02890:  MOVWF  x05
02892:  MOVLB  0
02894:  CALL   1B14
....................  
....................    header.SourcePort           = localPort; 
02898:  MOVFF  3B6,3C8
0289C:  MOVFF  3B5,3C7
....................    header.DestPort             = remotePort; 
028A0:  MOVFF  3B8,3CA
028A4:  MOVFF  3B7,3C9
....................    header.SeqNumber            = tseq; 
028A8:  MOVFF  3BC,3CE
028AC:  MOVFF  3BB,3CD
028B0:  MOVFF  3BA,3CC
028B4:  MOVFF  3B9,3CB
....................    header.AckNumber            = tack; 
028B8:  MOVFF  3C0,3D2
028BC:  MOVFF  3BF,3D1
028C0:  MOVFF  3BE,3D0
028C4:  MOVFF  3BD,3CF
....................    header.Flags.bits.Reserved2 = 0; 
028C8:  MOVLW  3F
028CA:  MOVLB  3
028CC:  ANDWF  xD4,W
028CE:  MOVWF  xD4
....................    header.DataOffset.Reserved3 = 0; 
028D0:  MOVLW  F0
028D2:  ANDWF  xD3,W
028D4:  MOVWF  xD3
....................    header.Flags.b              = flags; 
028D6:  MOVFF  3C1,3D4
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
028DA:  MOVLB  0
028DC:  GOTO   1BBE
028E0:  MOVFF  02,3D6
028E4:  MOVFF  01,3D5
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
028E8:  MOVLB  3
028EA:  MOVF   xD6,F
028EC:  BNZ   28F4
028EE:  MOVF   xD5,W
028F0:  SUBLW  28
028F2:  BC    28FE
....................    { 
....................       header.Window -= 40; 
028F4:  MOVLW  28
028F6:  SUBWF  xD5,F
028F8:  MOVLW  00
028FA:  SUBWFB xD6,F
....................    } 
....................    else 
028FC:  BRA    2902
....................       header.Window = 0; 
028FE:  CLRF   xD6
02900:  CLRF   xD5
.................... #endif 
....................  
....................    header.Checksum             = 0; 
02902:  CLRF   xD8
02904:  CLRF   xD7
....................    header.UrgentPointer        = 0; 
02906:  CLRF   xDA
02908:  CLRF   xD9
....................  
....................    SwapTCPHeader(&header); 
0290A:  MOVLW  03
0290C:  MOVWF  xEC
0290E:  MOVLW  C7
02910:  MOVWF  xEB
02912:  MOVLB  0
02914:  CALL   1D12
....................  
....................    len += sizeof(header); 
02918:  MOVLW  14
0291A:  MOVLB  3
0291C:  ADDWF  xC3,F
0291E:  MOVLW  00
02920:  ADDWFC xC4,F
....................  
....................    if ( flags & SYN ) 
02922:  BTFSS  xC1.1
02924:  BRA    2944
....................    { 
....................       len += sizeof(options); 
02926:  MOVLW  04
02928:  ADDWF  xC3,F
0292A:  MOVLW  00
0292C:  ADDWFC xC4,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
0292E:  MOVLW  02
02930:  MOVWF  xDB
....................       options.Length = 0x04; 
02932:  MOVLW  04
02934:  MOVWF  xDC
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
02936:  MOVWF  xDD
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
02938:  CLRF   xDE
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
0293A:  MOVLW  0F
0293C:  ANDWF  xD3,W
0293E:  IORLW  60
02940:  MOVWF  xD3
....................    } 
....................    else 
02942:  BRA    294C
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
02944:  MOVLW  0F
02946:  ANDWF  xD3,W
02948:  IORLW  50
0294A:  MOVWF  xD3
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
0294C:  MOVFF  1B,3E2
02950:  MOVFF  1A,3E1
02954:  MOVFF  19,3E0
02958:  MOVFF  18,3DF
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
0295C:  MOVLW  06
0295E:  ADDWF  xB3,W
02960:  MOVWF  FE9
02962:  MOVLW  00
02964:  ADDWFC xB4,W
02966:  MOVWF  FEA
02968:  MOVFF  FEF,00
0296C:  MOVFF  FEC,01
02970:  MOVFF  FEC,02
02974:  MOVFF  FEC,03
02978:  MOVFF  03,3E6
0297C:  MOVFF  02,3E5
02980:  MOVFF  01,3E4
02984:  MOVFF  00,3E3
....................    pseudoHeader.Zero           = 0x0; 
02988:  CLRF   xE7
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
0298A:  MOVLW  06
0298C:  MOVWF  xE8
....................    pseudoHeader.TCPLength      = len; 
0298E:  MOVFF  3C4,3EA
02992:  MOVFF  3C3,3E9
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
02996:  MOVFF  3EA,40B
0299A:  MOVFF  3E9,40A
0299E:  MOVLB  0
029A0:  CALL   1CDA
029A4:  MOVFF  02,3EA
029A8:  MOVFF  01,3E9
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
029AC:  MOVLW  03
029AE:  MOVLB  3
029B0:  MOVWF  xEC
029B2:  MOVLW  DF
029B4:  MOVFF  3EC,3EE
029B8:  MOVWF  xED
029BA:  CLRF   xF0
029BC:  MOVLW  0C
029BE:  MOVWF  xEF
029C0:  MOVLB  0
029C2:  CALL   1F2E
029C6:  MOVFF  01,3D7
029CA:  MOVLB  3
029CC:  COMF   xD7,F
029CE:  MOVFF  02,3D8
029D2:  COMF   xD8,F
....................    checkSum.Val = header.Checksum; 
029D4:  MOVFF  3D8,3C6
029D8:  MOVFF  3D7,3C5
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
029DC:  MOVFF  3B4,3EC
029E0:  MOVFF  3B3,3EB
029E4:  MOVLW  06
029E6:  MOVWF  xED
029E8:  MOVFF  3C4,3EF
029EC:  MOVFF  3C3,3EE
029F0:  MOVLB  0
029F2:  RCALL  2308
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
029F4:  MOVLW  03
029F6:  MOVLB  3
029F8:  MOVWF  xEC
029FA:  MOVLW  C7
029FC:  MOVFF  3EC,410
02A00:  MOVFF  FE8,40F
02A04:  MOVLB  4
02A06:  CLRF   x12
02A08:  MOVLW  14
02A0A:  MOVWF  x11
02A0C:  MOVLB  0
02A0E:  CALL   2118
....................  
....................    if ( flags & SYN ) 
02A12:  MOVLB  3
02A14:  BTFSS  xC1.1
02A16:  BRA    2A34
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
02A18:  MOVLW  03
02A1A:  MOVWF  xEC
02A1C:  MOVLW  DB
02A1E:  MOVFF  3EC,410
02A22:  MOVFF  FE8,40F
02A26:  MOVLB  4
02A28:  CLRF   x12
02A2A:  MOVLW  04
02A2C:  MOVWF  x11
02A2E:  MOVLB  0
02A30:  CALL   2118
....................  
....................    IPSetTxBuffer(buff, 0); 
02A34:  MOVFF  3C2,404
02A38:  MOVLB  4
02A3A:  CLRF   x06
02A3C:  MOVLW  14
02A3E:  MOVWF  x05
02A40:  MOVLB  0
02A42:  CALL   1B14
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
02A46:  MOVFF  3C4,3EC
02A4A:  MOVFF  3C3,3EB
02A4E:  RCALL  2460
02A50:  MOVFF  02,3C6
02A54:  MOVFF  01,3C5
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
02A58:  MOVFF  3C2,404
02A5C:  MOVLB  4
02A5E:  CLRF   x06
02A60:  MOVLW  24
02A62:  MOVWF  x05
02A64:  MOVLB  0
02A66:  CALL   1B14
....................    MACPut(checkSum.v[1]); 
02A6A:  MOVFF  3C6,40E
02A6E:  CALL   20FE
....................    MACPut(checkSum.v[0]); 
02A72:  MOVFF  3C5,40E
02A76:  CALL   20FE
....................    MACSetTxBuffer(buff, 0); 
02A7A:  MOVFF  3C2,404
02A7E:  MOVLB  4
02A80:  CLRF   x06
02A82:  CLRF   x05
02A84:  MOVLB  0
02A86:  CALL   1B14
....................  
....................    MACFlush(); 
02A8A:  RCALL  2622
02A8C:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
02A8E:  MOVLB  0
02A90:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
04F6C:  MOVLW  FE
04F6E:  MOVLB  3
04F70:  MOVWF  x98
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
04F72:  CLRF   x97
04F74:  MOVF   x97,W
04F76:  SUBLW  04
04F78:  BTFSS  FD8.0
04F7A:  BRA    5070
....................    { 
....................       ps = &TCB[s]; 
04F7C:  MOVF   x97,W
04F7E:  MULLW  24
04F80:  MOVF   FF3,W
04F82:  CLRF   03
04F84:  ADDLW  8E
04F86:  MOVWF  01
04F88:  MOVLW  00
04F8A:  ADDWFC 03,F
04F8C:  MOVFF  01,395
04F90:  MOVFF  03,396
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
04F94:  MOVFF  395,FE9
04F98:  MOVFF  396,FEA
04F9C:  MOVF   FEF,W
04F9E:  SUBLW  0A
04FA0:  BZ    506C
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
04FA2:  MOVLW  0B
04FA4:  ADDWF  x95,W
04FA6:  MOVWF  FE9
04FA8:  MOVLW  00
04FAA:  ADDWFC x96,W
04FAC:  MOVWF  FEA
04FAE:  MOVFF  FEC,39A
04FB2:  MOVF   FED,F
04FB4:  MOVFF  FEF,399
04FB8:  MOVLW  02
04FBA:  ADDWF  x91,W
04FBC:  MOVWF  FE9
04FBE:  MOVLW  00
04FC0:  ADDWFC x92,W
04FC2:  MOVWF  FEA
04FC4:  MOVFF  FEC,03
04FC8:  MOVF   FED,F
04FCA:  MOVF   FEF,W
04FCC:  SUBWF  x99,W
04FCE:  BNZ   506C
04FD0:  MOVF   03,W
04FD2:  SUBWF  x9A,W
04FD4:  BNZ   506C
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
04FD6:  MOVFF  395,FE9
04FDA:  MOVFF  396,FEA
04FDE:  MOVF   FEF,F
04FE0:  BNZ   4FE6
....................                partialMatch = s; 
04FE2:  MOVFF  397,398
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
04FE6:  MOVLW  0D
04FE8:  ADDWF  x95,W
04FEA:  MOVWF  FE9
04FEC:  MOVLW  00
04FEE:  ADDWFC x96,W
04FF0:  MOVWF  FEA
04FF2:  MOVFF  FEC,39A
04FF6:  MOVF   FED,F
04FF8:  MOVFF  FEF,399
04FFC:  MOVFF  391,FE9
05000:  MOVFF  392,FEA
05004:  MOVFF  FEC,03
05008:  MOVF   FED,F
0500A:  MOVF   FEF,W
0500C:  SUBWF  x99,W
0500E:  BNZ   506C
05010:  MOVF   03,W
05012:  SUBWF  x9A,W
05014:  BNZ   506C
05016:  MOVLW  07
05018:  ADDWF  x95,W
0501A:  MOVWF  FE9
0501C:  MOVLW  00
0501E:  ADDWFC x96,W
05020:  MOVWF  FEA
05022:  MOVFF  FEF,399
05026:  MOVFF  FEC,39A
0502A:  MOVFF  FEC,39B
0502E:  MOVFF  FEC,39C
05032:  MOVLW  06
05034:  ADDWF  x93,W
05036:  MOVWF  FE9
05038:  MOVLW  00
0503A:  ADDWFC x94,W
0503C:  MOVWF  FEA
0503E:  MOVFF  FEF,00
05042:  MOVFF  FEC,01
05046:  MOVFF  FEC,02
0504A:  MOVFF  FEC,03
0504E:  MOVF   00,W
05050:  SUBWF  x99,W
05052:  BNZ   506C
05054:  MOVF   01,W
05056:  SUBWF  x9A,W
05058:  BNZ   506C
0505A:  MOVF   02,W
0505C:  SUBWF  x9B,W
0505E:  BNZ   506C
05060:  MOVF   03,W
05062:  SUBWF  x9C,W
05064:  BNZ   506C
....................             { 
....................                return s; 
05066:  MOVFF  397,01
0506A:  BRA    5144
....................             } 
....................          } 
....................       } 
....................    } 
0506C:  INCF   x97,F
0506E:  BRA    4F74
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
05070:  MOVF   x98,W
05072:  SUBLW  FE
05074:  BNZ   507C
....................       return INVALID_SOCKET; 
05076:  MOVLW  FE
05078:  MOVWF  01
0507A:  BRA    5144
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
0507C:  MOVF   x98,W
0507E:  MULLW  24
05080:  MOVF   FF3,W
05082:  CLRF   03
05084:  ADDLW  8E
05086:  MOVWF  01
05088:  MOVLW  00
0508A:  ADDWFC 03,F
0508C:  MOVFF  01,395
05090:  MOVFF  03,396
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
05094:  MOVLW  01
05096:  ADDWF  x95,W
05098:  MOVWF  x99
0509A:  MOVLW  00
0509C:  ADDWFC x96,W
0509E:  MOVWF  x9A
050A0:  MOVWF  FEA
050A2:  MOVFF  399,FE9
050A6:  MOVFF  394,FE2
050AA:  MOVFF  393,FE1
050AE:  MOVLW  0A
050B0:  MOVWF  01
050B2:  MOVFF  FE6,FEE
050B6:  DECFSZ 01,F
050B8:  BRA    50B2
....................    ps->remotePort          = h->SourcePort; 
050BA:  MOVLW  0D
050BC:  ADDWF  x95,W
050BE:  MOVWF  01
050C0:  MOVLW  00
050C2:  ADDWFC x96,W
050C4:  MOVFF  391,FE9
050C8:  MOVFF  392,FEA
050CC:  MOVFF  FEC,03
050D0:  MOVF   FED,F
050D2:  MOVFF  FEF,39B
050D6:  MOVWF  FEA
050D8:  MOVFF  01,FE9
050DC:  MOVFF  03,FEC
050E0:  MOVF   FED,F
050E2:  MOVFF  39B,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
050E6:  MOVLW  23
050E8:  ADDWF  x95,W
050EA:  MOVWF  FE9
050EC:  MOVLW  00
050EE:  ADDWFC x96,W
050F0:  MOVWF  FEA
050F2:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
050F4:  MOVLW  0F
050F6:  ADDWF  x95,W
050F8:  MOVWF  FE9
050FA:  MOVLW  00
050FC:  ADDWFC x96,W
050FE:  MOVWF  FEA
05100:  INCFSZ FEF,W
05102:  BRA    5106
05104:  BRA    5132
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
05106:  MOVLW  0F
05108:  ADDWF  x95,W
0510A:  MOVWF  FE9
0510C:  MOVLW  00
0510E:  ADDWFC x96,W
05110:  MOVWF  FEA
05112:  MOVFF  FEF,399
05116:  MOVFF  399,3B2
0511A:  MOVLB  0
0511C:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
05120:  MOVLW  0F
05122:  MOVLB  3
05124:  ADDWF  x95,W
05126:  MOVWF  FE9
05128:  MOVLW  00
0512A:  ADDWFC x96,W
0512C:  MOVWF  FEA
0512E:  MOVLW  FF
05130:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
05132:  MOVLW  23
05134:  ADDWF  x95,W
05136:  MOVWF  FE9
05138:  MOVLW  00
0513A:  ADDWFC x96,W
0513C:  MOVWF  FEA
0513E:  BSF    FEF.1
....................  
....................    return partialMatch; 
05140:  MOVFF  398,01
.................... } 
05144:  MOVLB  0
05146:  GOTO   5DA2 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
01D12:  MOVLB  3
01D14:  MOVFF  3EB,01
01D18:  MOVFF  3EC,03
01D1C:  MOVFF  3EB,3ED
01D20:  MOVFF  3EC,3EE
01D24:  MOVFF  3EB,FE9
01D28:  MOVFF  3EC,FEA
01D2C:  MOVFF  FEC,3F0
01D30:  MOVF   FED,F
01D32:  MOVFF  FEF,3EF
01D36:  MOVFF  3F0,40B
01D3A:  MOVFF  3EF,40A
01D3E:  MOVLB  0
01D40:  RCALL  1CDA
01D42:  MOVFF  3EE,FEA
01D46:  MOVFF  3ED,FE9
01D4A:  MOVFF  02,FEC
01D4E:  MOVF   FED,F
01D50:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
01D54:  MOVLW  02
01D56:  MOVLB  3
01D58:  ADDWF  xEB,W
01D5A:  MOVWF  01
01D5C:  MOVLW  00
01D5E:  ADDWFC xEC,W
01D60:  MOVWF  03
01D62:  MOVFF  01,3ED
01D66:  MOVWF  xEE
01D68:  MOVLW  02
01D6A:  ADDWF  xEB,W
01D6C:  MOVWF  FE9
01D6E:  MOVLW  00
01D70:  ADDWFC xEC,W
01D72:  MOVWF  FEA
01D74:  MOVFF  FEC,3F0
01D78:  MOVF   FED,F
01D7A:  MOVFF  FEF,3EF
01D7E:  MOVFF  3F0,40B
01D82:  MOVFF  3EF,40A
01D86:  MOVLB  0
01D88:  RCALL  1CDA
01D8A:  MOVFF  3EE,FEA
01D8E:  MOVFF  3ED,FE9
01D92:  MOVFF  02,FEC
01D96:  MOVF   FED,F
01D98:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
01D9C:  MOVLW  04
01D9E:  MOVLB  3
01DA0:  ADDWF  xEB,W
01DA2:  MOVWF  01
01DA4:  MOVLW  00
01DA6:  ADDWFC xEC,W
01DA8:  MOVWF  03
01DAA:  MOVFF  01,3ED
01DAE:  MOVWF  xEE
01DB0:  MOVLW  04
01DB2:  ADDWF  xEB,W
01DB4:  MOVWF  FE9
01DB6:  MOVLW  00
01DB8:  ADDWFC xEC,W
01DBA:  MOVWF  FEA
01DBC:  MOVFF  FEF,3EF
01DC0:  MOVFF  FEC,3F0
01DC4:  MOVFF  FEC,3F1
01DC8:  MOVFF  FEC,3F2
01DCC:  MOVFF  3F2,3F6
01DD0:  MOVFF  3F1,3F5
01DD4:  MOVFF  3F0,3F4
01DD8:  MOVFF  3EF,3F3
01DDC:  MOVLB  0
01DDE:  RCALL  1CF0
01DE0:  MOVFF  3EE,FEA
01DE4:  MOVFF  3ED,FE9
01DE8:  MOVFF  00,FEF
01DEC:  MOVFF  01,FEC
01DF0:  MOVFF  02,FEC
01DF4:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
01DF8:  MOVLW  08
01DFA:  MOVLB  3
01DFC:  ADDWF  xEB,W
01DFE:  MOVWF  01
01E00:  MOVLW  00
01E02:  ADDWFC xEC,W
01E04:  MOVWF  03
01E06:  MOVFF  01,3ED
01E0A:  MOVWF  xEE
01E0C:  MOVLW  08
01E0E:  ADDWF  xEB,W
01E10:  MOVWF  FE9
01E12:  MOVLW  00
01E14:  ADDWFC xEC,W
01E16:  MOVWF  FEA
01E18:  MOVFF  FEF,3EF
01E1C:  MOVFF  FEC,3F0
01E20:  MOVFF  FEC,3F1
01E24:  MOVFF  FEC,3F2
01E28:  MOVFF  3F2,3F6
01E2C:  MOVFF  3F1,3F5
01E30:  MOVFF  3F0,3F4
01E34:  MOVFF  3EF,3F3
01E38:  MOVLB  0
01E3A:  RCALL  1CF0
01E3C:  MOVFF  3EE,FEA
01E40:  MOVFF  3ED,FE9
01E44:  MOVFF  00,FEF
01E48:  MOVFF  01,FEC
01E4C:  MOVFF  02,FEC
01E50:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
01E54:  MOVLW  0E
01E56:  MOVLB  3
01E58:  ADDWF  xEB,W
01E5A:  MOVWF  01
01E5C:  MOVLW  00
01E5E:  ADDWFC xEC,W
01E60:  MOVWF  03
01E62:  MOVFF  01,3ED
01E66:  MOVWF  xEE
01E68:  MOVLW  0E
01E6A:  ADDWF  xEB,W
01E6C:  MOVWF  FE9
01E6E:  MOVLW  00
01E70:  ADDWFC xEC,W
01E72:  MOVWF  FEA
01E74:  MOVFF  FEC,3F0
01E78:  MOVF   FED,F
01E7A:  MOVFF  FEF,3EF
01E7E:  MOVFF  3F0,40B
01E82:  MOVFF  3EF,40A
01E86:  MOVLB  0
01E88:  RCALL  1CDA
01E8A:  MOVFF  3EE,FEA
01E8E:  MOVFF  3ED,FE9
01E92:  MOVFF  02,FEC
01E96:  MOVF   FED,F
01E98:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
01E9C:  MOVLW  10
01E9E:  MOVLB  3
01EA0:  ADDWF  xEB,W
01EA2:  MOVWF  01
01EA4:  MOVLW  00
01EA6:  ADDWFC xEC,W
01EA8:  MOVWF  03
01EAA:  MOVFF  01,3ED
01EAE:  MOVWF  xEE
01EB0:  MOVLW  10
01EB2:  ADDWF  xEB,W
01EB4:  MOVWF  FE9
01EB6:  MOVLW  00
01EB8:  ADDWFC xEC,W
01EBA:  MOVWF  FEA
01EBC:  MOVFF  FEC,3F0
01EC0:  MOVF   FED,F
01EC2:  MOVFF  FEF,3EF
01EC6:  MOVFF  3F0,40B
01ECA:  MOVFF  3EF,40A
01ECE:  MOVLB  0
01ED0:  RCALL  1CDA
01ED2:  MOVFF  3EE,FEA
01ED6:  MOVFF  3ED,FE9
01EDA:  MOVFF  02,FEC
01EDE:  MOVF   FED,F
01EE0:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
01EE4:  MOVLW  12
01EE6:  MOVLB  3
01EE8:  ADDWF  xEB,W
01EEA:  MOVWF  01
01EEC:  MOVLW  00
01EEE:  ADDWFC xEC,W
01EF0:  MOVWF  03
01EF2:  MOVFF  01,3ED
01EF6:  MOVWF  xEE
01EF8:  MOVLW  12
01EFA:  ADDWF  xEB,W
01EFC:  MOVWF  FE9
01EFE:  MOVLW  00
01F00:  ADDWFC xEC,W
01F02:  MOVWF  FEA
01F04:  MOVFF  FEC,3F0
01F08:  MOVF   FED,F
01F0A:  MOVFF  FEF,3EF
01F0E:  MOVFF  3F0,40B
01F12:  MOVFF  3EF,40A
01F16:  MOVLB  0
01F18:  RCALL  1CDA
01F1A:  MOVFF  3EE,FEA
01F1E:  MOVFF  3ED,FE9
01F22:  MOVFF  02,FEC
01F26:  MOVF   FED,F
01F28:  MOVFF  01,FEF
.................... } 
01F2C:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
01972:  MOVLW  0F
01974:  MOVLB  3
01976:  ADDWF  xAF,W
01978:  MOVWF  FE9
0197A:  MOVLW  00
0197C:  ADDWFC xB0,W
0197E:  MOVWF  FEA
01980:  INCFSZ FEF,W
01982:  BRA    1986
01984:  BRA    19C0
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
01986:  MOVLW  0F
01988:  ADDWF  xAF,W
0198A:  MOVWF  FE9
0198C:  MOVLW  00
0198E:  ADDWFC xB0,W
01990:  MOVWF  FEA
01992:  MOVFF  FEF,3B1
01996:  MOVFF  3B1,3B2
0199A:  MOVLB  0
0199C:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
019A0:  MOVLW  0F
019A2:  MOVLB  3
019A4:  ADDWF  xAF,W
019A6:  MOVWF  FE9
019A8:  MOVLW  00
019AA:  ADDWFC xB0,W
019AC:  MOVWF  FEA
019AE:  MOVLW  FF
019B0:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
019B2:  MOVLW  23
019B4:  ADDWF  xAF,W
019B6:  MOVWF  FE9
019B8:  MOVLW  00
019BA:  ADDWFC xB0,W
019BC:  MOVWF  FEA
019BE:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
019C0:  MOVLW  07
019C2:  ADDWF  xAF,W
019C4:  MOVWF  FE9
019C6:  MOVLW  00
019C8:  ADDWFC xB0,W
019CA:  MOVWF  FEA
019CC:  MOVF   FEE,F
019CE:  MOVF   FEE,F
019D0:  CLRF   FEC
019D2:  MOVF   FED,F
019D4:  CLRF   FEF
019D6:  MOVF   FED,F
019D8:  CLRF   FEF
019DA:  MOVF   FED,F
019DC:  CLRF   FEF
....................     ps->remotePort = 0x00; 
019DE:  MOVLW  0D
019E0:  ADDWF  xAF,W
019E2:  MOVWF  FE9
019E4:  MOVLW  00
019E6:  ADDWFC xB0,W
019E8:  MOVWF  FEA
019EA:  CLRF   FEC
019EC:  MOVF   FED,F
019EE:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
019F0:  MOVLW  23
019F2:  ADDWF  xAF,W
019F4:  MOVWF  FE9
019F6:  MOVLW  00
019F8:  ADDWFC xB0,W
019FA:  MOVWF  FEA
019FC:  BTFSS  FEF.3
019FE:  BRA    1A06
....................     { 
....................         MACDiscardRx(); 
01A00:  MOVLB  0
01A02:  RCALL  1908
01A04:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
01A06:  MOVLW  23
01A08:  ADDWF  xAF,W
01A0A:  MOVWF  FE9
01A0C:  MOVLW  00
01A0E:  ADDWFC xB0,W
01A10:  MOVWF  FEA
01A12:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
01A14:  MOVLW  21
01A16:  ADDWF  xAF,W
01A18:  MOVWF  FE9
01A1A:  MOVLW  00
01A1C:  ADDWFC xB0,W
01A1E:  MOVWF  FEA
01A20:  CLRF   FEC
01A22:  MOVF   FED,F
01A24:  MOVLW  1E
01A26:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
01A28:  MOVLW  23
01A2A:  ADDWF  xAF,W
01A2C:  MOVWF  FE9
01A2E:  MOVLW  00
01A30:  ADDWFC xB0,W
01A32:  MOVWF  FEA
01A34:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
01A36:  MOVLW  23
01A38:  ADDWF  xAF,W
01A3A:  MOVWF  FE9
01A3C:  MOVLW  00
01A3E:  ADDWFC xB0,W
01A40:  MOVWF  FEA
01A42:  BTFSS  FEF.0
01A44:  BRA    1A52
....................     { 
....................         ps->smState = TCP_LISTEN; 
01A46:  MOVFF  3AF,FE9
01A4A:  MOVFF  3B0,FEA
01A4E:  CLRF   FEF
....................     } 
....................     else 
01A50:  BRA    1A5E
....................     { 
....................         ps->smState = TCP_CLOSED; 
01A52:  MOVFF  3AF,FE9
01A56:  MOVFF  3B0,FEA
01A5A:  MOVLW  0A
01A5C:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
01A5E:  MOVLW  10
01A60:  ADDWF  xAF,W
01A62:  MOVWF  FE9
01A64:  MOVLW  00
01A66:  ADDWFC xB0,W
01A68:  MOVWF  FEA
01A6A:  CLRF   FEC
01A6C:  MOVF   FED,F
01A6E:  CLRF   FEF
....................  
....................     return; 
.................... } 
01A70:  MOVLB  0
01A72:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
05164:  MOVLB  3
05166:  MOVF   x91,W
05168:  MULLW  24
0516A:  MOVF   FF3,W
0516C:  CLRF   03
0516E:  ADDLW  8E
05170:  MOVWF  01
05172:  MOVLW  00
05174:  ADDWFC 03,F
05176:  MOVFF  01,3A8
0517A:  MOVFF  03,3A9
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
0517E:  CLRF   xAA
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
05180:  MOVLW  1E
05182:  ADDWF  xA8,W
05184:  MOVWF  FE9
05186:  MOVLW  00
05188:  ADDWFC xA9,W
0518A:  MOVWF  FEA
0518C:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
0518E:  MOVLW  1F
05190:  ADDWF  xA8,W
05192:  MOVWF  01
05194:  MOVLW  00
05196:  ADDWFC xA9,W
05198:  MOVWF  03
0519A:  MOVFF  01,3AF
0519E:  MOVWF  xB0
051A0:  MOVLB  0
051A2:  RCALL  514A
051A4:  MOVFF  3B0,FEA
051A8:  MOVFF  3AF,FE9
051AC:  MOVFF  02,FEC
051B0:  MOVF   FED,F
051B2:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
051B6:  MOVLW  21
051B8:  MOVLB  3
051BA:  ADDWF  xA8,W
051BC:  MOVWF  FE9
051BE:  MOVLW  00
051C0:  ADDWFC xA9,W
051C2:  MOVWF  FEA
051C4:  CLRF   FEC
051C6:  MOVF   FED,F
051C8:  MOVLW  1E
051CA:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
051CC:  MOVLW  0D
051CE:  ADDWF  x94,W
051D0:  MOVWF  FE9
051D2:  MOVLW  00
051D4:  ADDWFC x95,W
051D6:  MOVWF  FEA
051D8:  BTFSS  FEF.2
051DA:  BRA    5218
....................    { 
....................       MACDiscardRx(); 
051DC:  MOVLB  0
051DE:  CALL   1908
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
051E2:  MOVLB  3
051E4:  MOVFF  3A8,01
051E8:  MOVFF  3A9,03
051EC:  MOVFF  3A8,3AF
051F0:  MOVFF  3A9,3B0
051F4:  MOVLW  23
051F6:  ADDWF  xA8,W
051F8:  MOVWF  FE9
051FA:  MOVLW  00
051FC:  ADDWFC xA9,W
051FE:  MOVWF  FEA
05200:  BTFSS  FEF.0
05202:  BRA    5208
05204:  MOVLW  00
05206:  BRA    520A
05208:  MOVLW  01
0520A:  MOVFF  3B0,FEA
0520E:  MOVFF  3AF,FE9
05212:  MOVWF  FEF
....................       return; 
05214:  GOTO   5C30
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
05218:  MOVLW  16
0521A:  ADDWF  xA8,W
0521C:  MOVWF  FE9
0521E:  MOVLW  00
05220:  ADDWFC xA9,W
05222:  MOVWF  FEA
05224:  MOVFF  FEF,00
05228:  MOVFF  FEC,01
0522C:  MOVFF  FEC,02
05230:  MOVFF  FEC,03
05234:  MOVFF  03,39F
05238:  MOVFF  02,39E
0523C:  MOVFF  01,39D
05240:  MOVFF  00,39C
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
05244:  MOVLW  0E
05246:  ADDWF  x94,W
05248:  MOVWF  FE9
0524A:  MOVLW  00
0524C:  ADDWFC x95,W
0524E:  MOVWF  FEA
05250:  MOVFF  FEC,03
05254:  MOVF   FED,F
05256:  MOVFF  FEF,3AF
0525A:  MOVFF  03,3B0
0525E:  CLRF   xB1
05260:  CLRF   xB2
05262:  MOVLW  08
05264:  ADDWF  x94,W
05266:  MOVWF  FE9
05268:  MOVLW  00
0526A:  ADDWFC x95,W
0526C:  MOVWF  FEA
0526E:  MOVFF  FEF,00
05272:  MOVFF  FEC,01
05276:  MOVFF  FEC,02
0527A:  MOVFF  FEC,03
0527E:  MOVF   00,W
05280:  SUBWF  x9C,W
05282:  MOVWF  00
05284:  MOVF   01,W
05286:  SUBWFB x9D,W
05288:  MOVWF  01
0528A:  MOVF   02,W
0528C:  SUBWFB x9E,W
0528E:  MOVWF  02
05290:  MOVF   03,W
05292:  SUBWFB x9F,W
05294:  MOVWF  03
05296:  MOVF   00,W
05298:  SUBWF  xAF,F
0529A:  MOVF   01,W
0529C:  SUBWFB xB0,F
0529E:  MOVF   02,W
052A0:  SUBWFB xB1,F
052A2:  MOVF   03,W
052A4:  SUBWFB xB2,F
052A6:  MOVLW  10
052A8:  ADDWF  xA8,W
052AA:  MOVWF  FE9
052AC:  MOVLW  00
052AE:  ADDWFC xA9,W
052B0:  MOVWF  FEA
052B2:  MOVFF  FEC,03
052B6:  MOVF   FED,F
052B8:  MOVFF  FEF,00
052BC:  MOVFF  03,01
052C0:  CLRF   02
052C2:  CLRF   03
052C4:  MOVF   00,W
052C6:  SUBWF  xAF,W
052C8:  MOVWF  xAB
052CA:  MOVF   01,W
052CC:  SUBWFB xB0,W
052CE:  MOVWF  xAC
052D0:  MOVF   02,W
052D2:  SUBWFB xB1,W
052D4:  MOVWF  xAD
052D6:  MOVF   03,W
052D8:  SUBWFB xB2,W
052DA:  MOVWF  xAE
....................    if(temp < 0) 
052DC:  BTFSC  xAE.7
052DE:  BRA    52E2
052E0:  BRA    52F6
....................    { 
....................       ps->RemoteWindow = 0; 
052E2:  MOVLW  14
052E4:  ADDWF  xA8,W
052E6:  MOVWF  FE9
052E8:  MOVLW  00
052EA:  ADDWFC xA9,W
052EC:  MOVWF  FEA
052EE:  CLRF   FEC
052F0:  MOVF   FED,F
052F2:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
052F4:  BRA    530A
....................    { 
....................       ps->RemoteWindow = ack; 
052F6:  MOVLW  14
052F8:  ADDWF  xA8,W
052FA:  MOVWF  FE9
052FC:  MOVLW  00
052FE:  ADDWFC xA9,W
05300:  MOVWF  FEA
05302:  MOVFF  398,FEF
05306:  MOVFF  399,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
0530A:  MOVFF  3A8,FE9
0530E:  MOVFF  3A9,FEA
05312:  DECFSZ FEF,W
05314:  BRA    5492
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
05316:  MOVLW  0D
05318:  ADDWF  x94,W
0531A:  MOVWF  FE9
0531C:  MOVLW  00
0531E:  ADDWFC x95,W
05320:  MOVWF  FEA
05322:  BTFSC  FEF.1
05324:  BRA    534A
....................       { 
....................          MACDiscardRx(); 
05326:  MOVLB  0
05328:  CALL   1908
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
0532C:  MOVLW  0D
0532E:  MOVLB  3
05330:  ADDWF  x94,W
05332:  MOVWF  FE9
05334:  MOVLW  00
05336:  ADDWFC x95,W
05338:  MOVWF  FEA
0533A:  BTFSS  FEF.4
0533C:  BRA    5346
....................           { 
....................             flags = RST; 
0533E:  MOVLW  04
05340:  MOVWF  xAA
....................             goto SendTCPControlPacket; 
05342:  GOTO   5BB8
....................            } 
....................  
....................          return; 
05346:  GOTO   5C30
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
0534A:  MOVLW  1A
0534C:  ADDWF  xA8,W
0534E:  MOVWF  01
05350:  MOVLW  00
05352:  ADDWFC xA9,W
05354:  MOVFF  01,3AF
05358:  MOVWF  xB0
0535A:  MOVLW  04
0535C:  ADDWF  x94,W
0535E:  MOVWF  FE9
05360:  MOVLW  00
05362:  ADDWFC x95,W
05364:  MOVWF  FEA
05366:  MOVFF  FEF,3B1
0536A:  MOVFF  FEC,3B2
0536E:  MOVFF  FEC,3B3
05372:  MOVFF  FEC,3B4
05376:  MOVF   x96,W
05378:  ADDWF  xB1,F
0537A:  MOVF   x97,W
0537C:  ADDWFC xB2,F
0537E:  MOVLW  00
05380:  ADDWFC xB3,F
05382:  ADDWFC xB4,F
05384:  MOVLW  01
05386:  ADDWF  xB1,W
05388:  MOVWF  00
0538A:  MOVLW  00
0538C:  ADDWFC xB2,W
0538E:  MOVWF  01
05390:  MOVLW  00
05392:  ADDWFC xB3,W
05394:  MOVWF  02
05396:  MOVLW  00
05398:  ADDWFC xB4,W
0539A:  MOVFF  3B0,FEA
0539E:  MOVFF  3AF,FE9
053A2:  MOVFF  00,FEF
053A6:  MOVFF  01,FEC
053AA:  MOVFF  02,FEC
053AE:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
053B0:  MOVLW  1A
053B2:  ADDWF  xA8,W
053B4:  MOVWF  FE9
053B6:  MOVLW  00
053B8:  ADDWFC xA9,W
053BA:  MOVWF  FEA
053BC:  MOVFF  FEF,00
053C0:  MOVFF  FEC,01
053C4:  MOVFF  FEC,02
053C8:  MOVFF  FEC,03
053CC:  MOVFF  03,39B
053D0:  MOVFF  02,39A
053D4:  MOVFF  01,399
053D8:  MOVFF  00,398
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
053DC:  MOVLW  0D
053DE:  ADDWF  x94,W
053E0:  MOVWF  FE9
053E2:  MOVLW  00
053E4:  ADDWFC x95,W
053E6:  MOVWF  FEA
053E8:  BTFSC  FEF.4
053EA:  BRA    5408
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
053EC:  MOVFF  3A8,FE9
053F0:  MOVFF  3A9,FEA
053F4:  MOVLW  02
053F6:  MOVWF  FEF
....................          MACDiscardRx(); 
053F8:  MOVLB  0
053FA:  CALL   1908
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
053FE:  MOVLW  12
05400:  MOVLB  3
05402:  MOVWF  xAA
....................          goto SendTCPControlPacket; 
05404:  GOTO   5BB8
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
05408:  MOVFF  3A8,FE9
0540C:  MOVFF  3A9,FEA
05410:  MOVLW  03
05412:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
05414:  MOVLW  10
05416:  MOVWF  xAA
....................  
....................       ps->RemoteWindow = h->Window; 
05418:  MOVLW  14
0541A:  ADDWF  xA8,W
0541C:  MOVWF  01
0541E:  MOVLW  00
05420:  ADDWFC xA9,W
05422:  MOVWF  03
05424:  MOVWF  xB0
05426:  MOVLW  0E
05428:  ADDWF  x94,W
0542A:  MOVWF  FE9
0542C:  MOVLW  00
0542E:  ADDWFC x95,W
05430:  MOVWF  FEA
05432:  MOVFF  FEC,03
05436:  MOVF   FED,F
05438:  MOVFF  FEF,3B1
0543C:  MOVFF  3B0,FEA
05440:  MOVFF  01,FE9
05444:  MOVFF  03,FEC
05448:  MOVF   FED,F
0544A:  MOVFF  3B1,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
0544E:  MOVF   x96,W
05450:  IORWF  x97,W
05452:  BZ    5488
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
05454:  MOVLW  23
05456:  ADDWF  xA8,W
05458:  MOVWF  FE9
0545A:  MOVLW  00
0545C:  ADDWFC xA9,W
0545E:  MOVWF  FEA
05460:  BSF    FEF.3
....................          ps->RxCount             = len; 
05462:  MOVLW  12
05464:  ADDWF  xA8,W
05466:  MOVWF  FE9
05468:  MOVLW  00
0546A:  ADDWFC xA9,W
0546C:  MOVWF  FEA
0546E:  MOVFF  397,FEC
05472:  MOVF   FED,F
05474:  MOVFF  396,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
05478:  MOVLW  23
0547A:  ADDWF  xA8,W
0547C:  MOVWF  FE9
0547E:  MOVLW  00
05480:  ADDWFC xA9,W
05482:  MOVWF  FEA
05484:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
05486:  BRA    5490
....................       { 
....................          MACDiscardRx(); 
05488:  MOVLB  0
0548A:  CALL   1908
0548E:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
05490:  BRA    5BB8
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
05492:  MOVFF  3A8,FE9
05496:  MOVFF  3A9,FEA
0549A:  MOVF   FEF,F
0549C:  BTFSS  FD8.2
0549E:  BRA    5628
....................    { 
....................       MACDiscardRx(); 
054A0:  MOVLB  0
054A2:  CALL   1908
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
054A6:  MOVLW  0D
054A8:  MOVLB  3
054AA:  ADDWF  x94,W
054AC:  MOVWF  FE9
054AE:  MOVLW  00
054B0:  ADDWFC x95,W
054B2:  MOVWF  FEA
054B4:  BTFSC  FEF.1
054B6:  BRA    54BE
....................       { 
....................          flags = RST; 
054B8:  MOVLW  04
054BA:  MOVWF  xAA
....................          goto SendTCPControlPacket; 
054BC:  BRA    5BB8
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
054BE:  MOVLW  1A
054C0:  ADDWF  xA8,W
054C2:  MOVWF  01
054C4:  MOVLW  00
054C6:  ADDWFC xA9,W
054C8:  MOVFF  01,3AF
054CC:  MOVWF  xB0
054CE:  MOVLW  04
054D0:  ADDWF  x94,W
054D2:  MOVWF  FE9
054D4:  MOVLW  00
054D6:  ADDWFC x95,W
054D8:  MOVWF  FEA
054DA:  MOVFF  FEF,3B1
054DE:  MOVFF  FEC,3B2
054E2:  MOVFF  FEC,3B3
054E6:  MOVFF  FEC,3B4
054EA:  MOVF   x96,W
054EC:  ADDWF  xB1,F
054EE:  MOVF   x97,W
054F0:  ADDWFC xB2,F
054F2:  MOVLW  00
054F4:  ADDWFC xB3,F
054F6:  ADDWFC xB4,F
054F8:  MOVLW  01
054FA:  ADDWF  xB1,W
054FC:  MOVWF  00
054FE:  MOVLW  00
05500:  ADDWFC xB2,W
05502:  MOVWF  01
05504:  MOVLW  00
05506:  ADDWFC xB3,W
05508:  MOVWF  02
0550A:  MOVLW  00
0550C:  ADDWFC xB4,W
0550E:  MOVFF  3B0,FEA
05512:  MOVFF  3AF,FE9
05516:  MOVFF  00,FEF
0551A:  MOVFF  01,FEC
0551E:  MOVFF  02,FEC
05522:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
05524:  MOVLW  14
05526:  ADDWF  xA8,W
05528:  MOVWF  01
0552A:  MOVLW  00
0552C:  ADDWFC xA9,W
0552E:  MOVWF  03
05530:  MOVWF  xB0
05532:  MOVLW  0E
05534:  ADDWF  x94,W
05536:  MOVWF  FE9
05538:  MOVLW  00
0553A:  ADDWFC x95,W
0553C:  MOVWF  FEA
0553E:  MOVFF  FEC,03
05542:  MOVF   FED,F
05544:  MOVFF  FEF,3B1
05548:  MOVFF  3B0,FEA
0554C:  MOVFF  01,FE9
05550:  MOVFF  03,FEC
05554:  MOVF   FED,F
05556:  MOVFF  3B1,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
0555A:  MOVLW  01
0555C:  ADDWF  xA8,W
0555E:  MOVWF  xAF
05560:  MOVLW  00
05562:  ADDWFC xA9,W
05564:  MOVWF  xB0
05566:  MOVWF  FEA
05568:  MOVFF  3AF,FE9
0556C:  MOVFF  393,FE2
05570:  MOVFF  392,FE1
05574:  MOVLW  0A
05576:  MOVWF  01
05578:  MOVFF  FE6,FEE
0557C:  DECFSZ 01,F
0557E:  BRA    5578
....................       ps->remotePort = h->SourcePort; 
05580:  MOVLW  0D
05582:  ADDWF  xA8,W
05584:  MOVWF  01
05586:  MOVLW  00
05588:  ADDWFC xA9,W
0558A:  MOVFF  394,FE9
0558E:  MOVFF  395,FEA
05592:  MOVFF  FEC,03
05596:  MOVF   FED,F
05598:  MOVFF  FEF,3B1
0559C:  MOVWF  FEA
0559E:  MOVFF  01,FE9
055A2:  MOVFF  03,FEC
055A6:  MOVF   FED,F
055A8:  MOVFF  3B1,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
055AC:  MOVFF  3A8,FE9
055B0:  MOVFF  3A9,FEA
055B4:  MOVLW  02
055B6:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
055B8:  MOVLW  16
055BA:  ADDWF  xA8,W
055BC:  MOVWF  FE9
055BE:  MOVLW  00
055C0:  ADDWFC xA9,W
055C2:  MOVWF  FEA
055C4:  MOVF   FEE,F
055C6:  MOVF   FEE,F
055C8:  MOVF   FEE,F
055CA:  MOVFF  FED,03
055CE:  MOVFF  FED,02
055D2:  MOVFF  FED,01
055D6:  MOVFF  FEF,00
055DA:  MOVLW  01
055DC:  ADDWF  FEE,F
055DE:  MOVLW  00
055E0:  ADDWFC FEE,F
055E2:  ADDWFC FEE,F
055E4:  ADDWFC FED,F
055E6:  MOVFF  03,39F
055EA:  MOVFF  02,39E
055EE:  MOVFF  01,39D
055F2:  MOVFF  00,39C
....................       ack =  ps->SND_ACK; 
055F6:  MOVLW  1A
055F8:  ADDWF  xA8,W
055FA:  MOVWF  FE9
055FC:  MOVLW  00
055FE:  ADDWFC xA9,W
05600:  MOVWF  FEA
05602:  MOVFF  FEF,00
05606:  MOVFF  FEC,01
0560A:  MOVFF  FEC,02
0560E:  MOVFF  FEC,03
05612:  MOVFF  03,39B
05616:  MOVFF  02,39A
0561A:  MOVFF  01,399
0561E:  MOVFF  00,398
....................       flags = SYN | ACK; 
05622:  MOVLW  12
05624:  MOVWF  xAA
....................       goto SendTCPControlPacket; 
05626:  BRA    5BB8
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
05628:  MOVLW  1A
0562A:  ADDWF  xA8,W
0562C:  MOVWF  FE9
0562E:  MOVLW  00
05630:  ADDWFC xA9,W
05632:  MOVWF  FEA
05634:  MOVFF  FEF,00
05638:  MOVFF  FEC,01
0563C:  MOVFF  FEC,02
05640:  MOVFF  FEC,03
05644:  MOVFF  03,3A3
05648:  MOVFF  02,3A2
0564C:  MOVFF  01,3A1
05650:  MOVFF  00,3A0
....................    prevSeq = ps->SND_SEQ; 
05654:  MOVLW  16
05656:  ADDWF  xA8,W
05658:  MOVWF  FE9
0565A:  MOVLW  00
0565C:  ADDWFC xA9,W
0565E:  MOVWF  FEA
05660:  MOVFF  FEF,00
05664:  MOVFF  FEC,01
05668:  MOVFF  FEC,02
0566C:  MOVFF  FEC,03
05670:  MOVFF  03,3A7
05674:  MOVFF  02,3A6
05678:  MOVFF  01,3A5
0567C:  MOVFF  00,3A4
....................  
....................    ack = h->SeqNumber; 
05680:  MOVLW  04
05682:  ADDWF  x94,W
05684:  MOVWF  FE9
05686:  MOVLW  00
05688:  ADDWFC x95,W
0568A:  MOVWF  FEA
0568C:  MOVFF  FEF,00
05690:  MOVFF  FEC,01
05694:  MOVFF  FEC,02
05698:  MOVFF  FEC,03
0569C:  MOVFF  03,39B
056A0:  MOVFF  02,39A
056A4:  MOVFF  01,399
056A8:  MOVFF  00,398
....................    ack += (DWORD)len; 
056AC:  CLRF   02
056AE:  CLRF   03
056B0:  MOVF   x96,W
056B2:  ADDWF  x98,F
056B4:  MOVF   x97,W
056B6:  ADDWFC x99,F
056B8:  MOVF   02,W
056BA:  ADDWFC x9A,F
056BC:  MOVF   03,W
056BE:  ADDWFC x9B,F
....................    seq = ps->SND_SEQ; 
056C0:  MOVLW  16
056C2:  ADDWF  xA8,W
056C4:  MOVWF  FE9
056C6:  MOVLW  00
056C8:  ADDWFC xA9,W
056CA:  MOVWF  FEA
056CC:  MOVFF  FEF,00
056D0:  MOVFF  FEC,01
056D4:  MOVFF  FEC,02
056D8:  MOVFF  FEC,03
056DC:  MOVFF  03,39F
056E0:  MOVFF  02,39E
056E4:  MOVFF  01,39D
056E8:  MOVFF  00,39C
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
056EC:  MOVLW  04
056EE:  ADDWF  x94,W
056F0:  MOVWF  FE9
056F2:  MOVLW  00
056F4:  ADDWFC x95,W
056F6:  MOVWF  FEA
056F8:  MOVFF  FEF,3AF
056FC:  MOVFF  FEC,3B0
05700:  MOVFF  FEC,3B1
05704:  MOVFF  FEC,3B2
05708:  MOVF   xA0,W
0570A:  SUBWF  xAF,W
0570C:  BTFSS  FD8.2
0570E:  BRA    5B9C
05710:  MOVF   xA1,W
05712:  SUBWF  xB0,W
05714:  BTFSS  FD8.2
05716:  BRA    5B9C
05718:  MOVF   xA2,W
0571A:  SUBWF  xB1,W
0571C:  BTFSS  FD8.2
0571E:  BRA    5B9C
05720:  MOVF   xA3,W
05722:  SUBWF  xB2,W
05724:  BTFSS  FD8.2
05726:  BRA    5B9C
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
05728:  MOVFF  3A8,FE9
0572C:  MOVFF  3A9,FEA
05730:  MOVF   FEF,W
05732:  SUBLW  02
05734:  BNZ   57BC
....................          { 
....................             if(h->Flags.bits.flagACK) 
05736:  MOVLW  0D
05738:  ADDWF  x94,W
0573A:  MOVWF  FE9
0573C:  MOVLW  00
0573E:  ADDWFC x95,W
05740:  MOVWF  FEA
05742:  BTFSS  FEF.4
05744:  BRA    57B2
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
05746:  MOVLW  1A
05748:  ADDWF  xA8,W
0574A:  MOVWF  FE9
0574C:  MOVLW  00
0574E:  ADDWFC xA9,W
05750:  MOVWF  FEA
05752:  MOVFF  398,FEF
05756:  MOVFF  399,FEC
0575A:  MOVFF  39A,FEC
0575E:  MOVFF  39B,FEC
....................                ps->smState = TCP_ESTABLISHED; 
05762:  MOVFF  3A8,FE9
05766:  MOVFF  3A9,FEA
0576A:  MOVLW  03
0576C:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
0576E:  MOVF   x96,W
05770:  IORWF  x97,W
05772:  BZ    57A8
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
05774:  MOVLW  23
05776:  ADDWF  xA8,W
05778:  MOVWF  FE9
0577A:  MOVLW  00
0577C:  ADDWFC xA9,W
0577E:  MOVWF  FEA
05780:  BSF    FEF.3
....................                   ps->RxCount             = len; 
05782:  MOVLW  12
05784:  ADDWF  xA8,W
05786:  MOVWF  FE9
05788:  MOVLW  00
0578A:  ADDWFC xA9,W
0578C:  MOVWF  FEA
0578E:  MOVFF  397,FEC
05792:  MOVF   FED,F
05794:  MOVFF  396,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
05798:  MOVLW  23
0579A:  ADDWF  xA8,W
0579C:  MOVWF  FE9
0579E:  MOVLW  00
057A0:  ADDWFC xA9,W
057A2:  MOVWF  FEA
057A4:  BSF    FEF.2
....................                } 
....................                else 
057A6:  BRA    57B0
....................                   MACDiscardRx(); 
057A8:  MOVLB  0
057AA:  CALL   1908
057AE:  MOVLB  3
....................             } 
....................             else   // No ACK to our SYN 
057B0:  BRA    57BA
....................             { 
....................                MACDiscardRx(); 
057B2:  MOVLB  0
057B4:  CALL   1908
057B8:  MOVLB  3
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
057BA:  BRA    5B9A
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
057BC:  MOVLW  1A
057BE:  ADDWF  xA8,W
057C0:  MOVWF  FE9
057C2:  MOVLW  00
057C4:  ADDWFC xA9,W
057C6:  MOVWF  FEA
057C8:  MOVFF  398,FEF
057CC:  MOVFF  399,FEC
057D0:  MOVFF  39A,FEC
057D4:  MOVFF  39B,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
057D8:  MOVFF  3A8,FE9
057DC:  MOVFF  3A9,FEA
057E0:  MOVF   FEF,W
057E2:  SUBLW  03
057E4:  BTFSS  FD8.2
057E6:  BRA    59AC
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
057E8:  MOVLW  0D
057EA:  ADDWF  x94,W
057EC:  MOVWF  FE9
057EE:  MOVLW  00
057F0:  ADDWFC x95,W
057F2:  MOVWF  FEA
057F4:  BTFSS  FEF.4
057F6:  BRA    5854
057F8:  MOVLW  23
057FA:  ADDWF  xA8,W
057FC:  MOVWF  FE9
057FE:  MOVLW  00
05800:  ADDWFC xA9,W
05802:  MOVWF  FEA
05804:  BTFSC  FEF.1
05806:  BRA    5854
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
05808:  MOVLW  0F
0580A:  ADDWF  xA8,W
0580C:  MOVWF  FE9
0580E:  MOVLW  00
05810:  ADDWFC xA9,W
05812:  MOVWF  FEA
05814:  INCFSZ FEF,W
05816:  BRA    581A
05818:  BRA    5854
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
0581A:  MOVLW  0F
0581C:  ADDWF  xA8,W
0581E:  MOVWF  FE9
05820:  MOVLW  00
05822:  ADDWFC xA9,W
05824:  MOVWF  FEA
05826:  MOVFF  FEF,3AF
0582A:  MOVFF  3AF,3B2
0582E:  MOVLB  0
05830:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
05834:  MOVLW  0F
05836:  MOVLB  3
05838:  ADDWF  xA8,W
0583A:  MOVWF  FE9
0583C:  MOVLW  00
0583E:  ADDWFC xA9,W
05840:  MOVWF  FEA
05842:  MOVLW  FF
05844:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
05846:  MOVLW  23
05848:  ADDWF  xA8,W
0584A:  MOVWF  FE9
0584C:  MOVLW  00
0584E:  ADDWFC xA9,W
05850:  MOVWF  FEA
05852:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
05854:  MOVLW  0D
05856:  ADDWF  x94,W
05858:  MOVWF  FE9
0585A:  MOVLW  00
0585C:  ADDWFC x95,W
0585E:  MOVWF  FEA
05860:  BTFSS  FEF.0
05862:  BRA    5914
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
05864:  MOVLW  11
05866:  MOVWF  xAA
....................                   seq = ps->SND_SEQ++; 
05868:  MOVLW  16
0586A:  ADDWF  xA8,W
0586C:  MOVWF  FE9
0586E:  MOVLW  00
05870:  ADDWFC xA9,W
05872:  MOVWF  FEA
05874:  MOVF   FEE,F
05876:  MOVF   FEE,F
05878:  MOVF   FEE,F
0587A:  MOVFF  FED,03
0587E:  MOVFF  FED,02
05882:  MOVFF  FED,01
05886:  MOVFF  FEF,00
0588A:  MOVLW  01
0588C:  ADDWF  FEE,F
0588E:  MOVLW  00
05890:  ADDWFC FEE,F
05892:  ADDWFC FEE,F
05894:  ADDWFC FED,F
05896:  MOVFF  03,39F
0589A:  MOVFF  02,39E
0589E:  MOVFF  01,39D
058A2:  MOVFF  00,39C
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
058A6:  MOVLW  1A
058A8:  ADDWF  xA8,W
058AA:  MOVWF  FE9
058AC:  MOVLW  00
058AE:  ADDWFC xA9,W
058B0:  MOVWF  FEA
058B2:  MOVLW  01
058B4:  ADDWF  FEF,W
058B6:  MOVWF  00
058B8:  MOVLW  00
058BA:  ADDWFC FEC,W
058BC:  MOVWF  01
058BE:  MOVLW  00
058C0:  ADDWFC FEC,W
058C2:  MOVWF  02
058C4:  MOVLW  00
058C6:  ADDWFC FEC,W
058C8:  MOVF   FED,F
058CA:  MOVF   FED,F
058CC:  MOVF   FED,F
058CE:  MOVFF  00,FEF
058D2:  MOVFF  01,FEC
058D6:  MOVFF  02,FEC
058DA:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
058DC:  MOVLW  1A
058DE:  ADDWF  xA8,W
058E0:  MOVWF  FE9
058E2:  MOVLW  00
058E4:  ADDWFC xA9,W
058E6:  MOVWF  FEA
058E8:  MOVFF  FEF,00
058EC:  MOVFF  FEC,01
058F0:  MOVFF  FEC,02
058F4:  MOVFF  FEC,03
058F8:  MOVFF  03,39B
058FC:  MOVFF  02,39A
05900:  MOVFF  01,399
05904:  MOVFF  00,398
....................                   ps->smState = TCP_LAST_ACK; 
05908:  MOVFF  3A8,FE9
0590C:  MOVFF  3A9,FEA
05910:  MOVLW  09
05912:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
05914:  MOVF   x96,W
05916:  IORWF  x97,W
05918:  BZ    59A2
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
0591A:  MOVLW  23
0591C:  ADDWF  xA8,W
0591E:  MOVWF  FE9
05920:  MOVLW  00
05922:  ADDWFC xA9,W
05924:  MOVWF  FEA
05926:  BTFSC  FEF.3
05928:  BRA    5960
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
0592A:  MOVLW  23
0592C:  ADDWF  xA8,W
0592E:  MOVWF  FE9
05930:  MOVLW  00
05932:  ADDWFC xA9,W
05934:  MOVWF  FEA
05936:  BSF    FEF.3
....................                      ps->RxCount             = len; 
05938:  MOVLW  12
0593A:  ADDWF  xA8,W
0593C:  MOVWF  FE9
0593E:  MOVLW  00
05940:  ADDWFC xA9,W
05942:  MOVWF  FEA
05944:  MOVFF  397,FEC
05948:  MOVF   FED,F
0594A:  MOVFF  396,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
0594E:  MOVLW  23
05950:  ADDWF  xA8,W
05952:  MOVWF  FE9
05954:  MOVLW  00
05956:  ADDWFC xA9,W
05958:  MOVWF  FEA
0595A:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
0595C:  BSF    xAA.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
0595E:  BRA    59A0
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
05960:  MOVLW  16
05962:  ADDWF  xA8,W
05964:  MOVWF  FE9
05966:  MOVLW  00
05968:  ADDWFC xA9,W
0596A:  MOVWF  FEA
0596C:  MOVFF  3A4,FEF
05970:  MOVFF  3A5,FEC
05974:  MOVFF  3A6,FEC
05978:  MOVFF  3A7,FEC
....................                      ps->SND_ACK = prevAck; 
0597C:  MOVLW  1A
0597E:  ADDWF  xA8,W
05980:  MOVWF  FE9
05982:  MOVLW  00
05984:  ADDWFC xA9,W
05986:  MOVWF  FEA
05988:  MOVFF  3A0,FEF
0598C:  MOVFF  3A1,FEC
05990:  MOVFF  3A2,FEC
05994:  MOVFF  3A3,FEC
....................  
....................                      MACDiscardRx(); 
05998:  MOVLB  0
0599A:  CALL   1908
0599E:  MOVLB  3
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
059A0:  BRA    59AA
....................                { 
....................                   MACDiscardRx(); 
059A2:  MOVLB  0
059A4:  CALL   1908
059A8:  MOVLB  3
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
059AA:  BRA    5B9A
059AC:  MOVFF  3A8,FE9
059B0:  MOVFF  3A9,FEA
059B4:  MOVF   FEF,W
059B6:  SUBLW  09
059B8:  BNZ   59E4
....................             { 
....................                MACDiscardRx(); 
059BA:  MOVLB  0
059BC:  CALL   1908
....................  
....................                if(h->Flags.bits.flagACK) 
059C0:  MOVLW  0D
059C2:  MOVLB  3
059C4:  ADDWF  x94,W
059C6:  MOVWF  FE9
059C8:  MOVLW  00
059CA:  ADDWFC x95,W
059CC:  MOVWF  FEA
059CE:  BTFSS  FEF.4
059D0:  BRA    59E2
....................                { 
....................                   CloseSocket(ps); 
059D2:  MOVFF  3A9,3B0
059D6:  MOVFF  3A8,3AF
059DA:  MOVLB  0
059DC:  CALL   1972
059E0:  MOVLB  3
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
059E2:  BRA    5B9A
059E4:  MOVFF  3A8,FE9
059E8:  MOVFF  3A9,FEA
059EC:  MOVF   FEF,W
059EE:  SUBLW  04
059F0:  BNZ   5AC6
....................             { 
....................                MACDiscardRx(); 
059F2:  MOVLB  0
059F4:  CALL   1908
....................  
....................                if(h->Flags.bits.flagFIN) 
059F8:  MOVLW  0D
059FA:  MOVLB  3
059FC:  ADDWF  x94,W
059FE:  MOVWF  FE9
05A00:  MOVLW  00
05A02:  ADDWFC x95,W
05A04:  MOVWF  FEA
05A06:  BTFSS  FEF.0
05A08:  BRA    5AA4
....................                { 
....................                   flags = ACK; 
05A0A:  MOVLW  10
05A0C:  MOVWF  xAA
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
05A0E:  MOVLW  1A
05A10:  ADDWF  xA8,W
05A12:  MOVWF  FE9
05A14:  MOVLW  00
05A16:  ADDWFC xA9,W
05A18:  MOVWF  FEA
05A1A:  MOVLW  01
05A1C:  ADDWF  FEF,W
05A1E:  MOVWF  00
05A20:  MOVLW  00
05A22:  ADDWFC FEC,W
05A24:  MOVWF  01
05A26:  MOVLW  00
05A28:  ADDWFC FEC,W
05A2A:  MOVWF  02
05A2C:  MOVLW  00
05A2E:  ADDWFC FEC,W
05A30:  MOVF   FED,F
05A32:  MOVF   FED,F
05A34:  MOVF   FED,F
05A36:  MOVFF  00,FEF
05A3A:  MOVFF  01,FEC
05A3E:  MOVFF  02,FEC
05A42:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
05A44:  MOVLW  1A
05A46:  ADDWF  xA8,W
05A48:  MOVWF  FE9
05A4A:  MOVLW  00
05A4C:  ADDWFC xA9,W
05A4E:  MOVWF  FEA
05A50:  MOVFF  FEF,00
05A54:  MOVFF  FEC,01
05A58:  MOVFF  FEC,02
05A5C:  MOVFF  FEC,03
05A60:  MOVFF  03,39B
05A64:  MOVFF  02,39A
05A68:  MOVFF  01,399
05A6C:  MOVFF  00,398
....................                   if(h->Flags.bits.flagACK) 
05A70:  MOVLW  0D
05A72:  ADDWF  x94,W
05A74:  MOVWF  FE9
05A76:  MOVLW  00
05A78:  ADDWFC x95,W
05A7A:  MOVWF  FEA
05A7C:  BTFSS  FEF.4
05A7E:  BRA    5A92
....................                   { 
....................                      CloseSocket(ps); 
05A80:  MOVFF  3A9,3B0
05A84:  MOVFF  3A8,3AF
05A88:  MOVLB  0
05A8A:  CALL   1972
....................                   } 
....................                   else 
05A8E:  BRA    5AA0
05A90:  MOVLB  3
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
05A92:  MOVFF  3A8,FE9
05A96:  MOVFF  3A9,FEA
05A9A:  MOVLW  06
05A9C:  MOVWF  FEF
05A9E:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
05AA0:  BRA    5AC2
05AA2:  MOVLB  3
05AA4:  MOVLW  0D
05AA6:  ADDWF  x94,W
05AA8:  MOVWF  FE9
05AAA:  MOVLW  00
05AAC:  ADDWFC x95,W
05AAE:  MOVWF  FEA
05AB0:  BTFSS  FEF.4
05AB2:  BRA    5AC0
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
05AB4:  MOVFF  3A8,FE9
05AB8:  MOVFF  3A9,FEA
05ABC:  MOVLW  05
05ABE:  MOVWF  FEF
05AC0:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
05AC2:  BRA    5B98
05AC4:  MOVLB  3
05AC6:  MOVFF  3A8,FE9
05ACA:  MOVFF  3A9,FEA
05ACE:  MOVF   FEF,W
05AD0:  SUBLW  05
05AD2:  BNZ   5B64
....................             { 
....................                MACDiscardRx(); 
05AD4:  MOVLB  0
05AD6:  CALL   1908
....................  
....................                if(h->Flags.bits.flagFIN) 
05ADA:  MOVLW  0D
05ADC:  MOVLB  3
05ADE:  ADDWF  x94,W
05AE0:  MOVWF  FE9
05AE2:  MOVLW  00
05AE4:  ADDWFC x95,W
05AE6:  MOVWF  FEA
05AE8:  BTFSS  FEF.0
05AEA:  BRA    5B62
....................                { 
....................                   flags = ACK; 
05AEC:  MOVLW  10
05AEE:  MOVWF  xAA
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
05AF0:  MOVLW  1A
05AF2:  ADDWF  xA8,W
05AF4:  MOVWF  FE9
05AF6:  MOVLW  00
05AF8:  ADDWFC xA9,W
05AFA:  MOVWF  FEA
05AFC:  MOVLW  01
05AFE:  ADDWF  FEF,W
05B00:  MOVWF  00
05B02:  MOVLW  00
05B04:  ADDWFC FEC,W
05B06:  MOVWF  01
05B08:  MOVLW  00
05B0A:  ADDWFC FEC,W
05B0C:  MOVWF  02
05B0E:  MOVLW  00
05B10:  ADDWFC FEC,W
05B12:  MOVF   FED,F
05B14:  MOVF   FED,F
05B16:  MOVF   FED,F
05B18:  MOVFF  00,FEF
05B1C:  MOVFF  01,FEC
05B20:  MOVFF  02,FEC
05B24:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
05B26:  MOVLW  1A
05B28:  ADDWF  xA8,W
05B2A:  MOVWF  FE9
05B2C:  MOVLW  00
05B2E:  ADDWFC xA9,W
05B30:  MOVWF  FEA
05B32:  MOVFF  FEF,00
05B36:  MOVFF  FEC,01
05B3A:  MOVFF  FEC,02
05B3E:  MOVFF  FEC,03
05B42:  MOVFF  03,39B
05B46:  MOVFF  02,39A
05B4A:  MOVFF  01,399
05B4E:  MOVFF  00,398
....................                   CloseSocket(ps); 
05B52:  MOVFF  3A9,3B0
05B56:  MOVFF  3A8,3AF
05B5A:  MOVLB  0
05B5C:  CALL   1972
05B60:  MOVLB  3
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
05B62:  BRA    5B9A
05B64:  MOVFF  3A8,FE9
05B68:  MOVFF  3A9,FEA
05B6C:  MOVF   FEF,W
05B6E:  SUBLW  06
05B70:  BNZ   5B9A
....................             { 
....................                MACDiscardRx(); 
05B72:  MOVLB  0
05B74:  CALL   1908
....................  
....................                if ( h->Flags.bits.flagACK ) 
05B78:  MOVLW  0D
05B7A:  MOVLB  3
05B7C:  ADDWF  x94,W
05B7E:  MOVWF  FE9
05B80:  MOVLW  00
05B82:  ADDWFC x95,W
05B84:  MOVWF  FEA
05B86:  BTFSS  FEF.4
05B88:  BRA    5B9A
....................                { 
....................                   CloseSocket(ps); 
05B8A:  MOVFF  3A9,3B0
05B8E:  MOVFF  3A8,3AF
05B92:  MOVLB  0
05B94:  CALL   1972
05B98:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
05B9A:  BRA    5BB8
....................       { 
....................          MACDiscardRx(); 
05B9C:  MOVLB  0
05B9E:  CALL   1908
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
05BA2:  MOVLW  10
05BA4:  MOVLB  3
05BA6:  MOVWF  xAA
....................          ack = prevAck; 
05BA8:  MOVFF  3A3,39B
05BAC:  MOVFF  3A2,39A
05BB0:  MOVFF  3A1,399
05BB4:  MOVFF  3A0,398
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
05BB8:  MOVF   xAA,F
05BBA:  BZ    5C30
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
05BBC:  MOVLW  02
05BBE:  ADDWF  x94,W
05BC0:  MOVWF  FE9
05BC2:  MOVLW  00
05BC4:  ADDWFC x95,W
05BC6:  MOVWF  FEA
05BC8:  MOVFF  FEC,3B0
05BCC:  MOVF   FED,F
05BCE:  MOVFF  FEF,3AF
05BD2:  MOVFF  394,FE9
05BD6:  MOVFF  395,FEA
05BDA:  MOVFF  FEC,3B2
05BDE:  MOVF   FED,F
05BE0:  MOVFF  FEF,3B1
05BE4:  MOVFF  393,3B4
05BE8:  MOVFF  392,3B3
05BEC:  MOVFF  3B0,3B6
05BF0:  MOVFF  3AF,3B5
05BF4:  MOVFF  3B2,3B8
05BF8:  MOVFF  3B1,3B7
05BFC:  MOVFF  39F,3BC
05C00:  MOVFF  39E,3BB
05C04:  MOVFF  39D,3BA
05C08:  MOVFF  39C,3B9
05C0C:  MOVFF  39B,3C0
05C10:  MOVFF  39A,3BF
05C14:  MOVFF  399,3BE
05C18:  MOVFF  398,3BD
05C1C:  MOVFF  3AA,3C1
05C20:  MOVLW  FF
05C22:  MOVWF  xC2
05C24:  CLRF   xC4
05C26:  CLRF   xC3
05C28:  MOVLB  0
05C2A:  CALL   285A
05C2E:  MOVLB  3
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
05C30:  MOVLB  0
05C32:  GOTO   5DD0 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     //debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
05EC2:  MOVLW  03
05EC4:  MOVLB  3
05EC6:  MOVWF  xBE
05EC8:  MOVLW  71
05ECA:  MOVFF  3BE,3FA
05ECE:  MOVWF  xF9
05ED0:  CLRF   xFC
05ED2:  MOVLW  08
05ED4:  MOVWF  xFB
05ED6:  MOVLB  0
05ED8:  CALL   25BE
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
05EDC:  MOVLB  3
05EDE:  CLRF   xBC
05EE0:  CLRF   xBB
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
05EE2:  MOVFF  36C,03
05EE6:  MOVFF  36B,FE9
05EEA:  MOVFF  36C,FEA
05EEE:  MOVFF  FEF,3BD
05EF2:  CLRF   xBF
05EF4:  MOVLW  14
05EF6:  MOVWF  xBE
05EF8:  CLRF   xC1
05EFA:  MOVFF  3BD,3C0
05EFE:  MOVLB  0
05F00:  CALL   4928
05F04:  MOVFF  02,3BA
05F08:  MOVFF  01,3B9
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
05F0C:  MOVLB  3
05F0E:  MOVFF  36B,FE9
05F12:  MOVFF  36C,FEA
05F16:  MOVLW  08
05F18:  SUBWF  FEF,W
05F1A:  MOVWF  FEF
....................     MACGetArray(data, *len); 
05F1C:  MOVFF  36C,03
05F20:  MOVFF  36B,FE9
05F24:  MOVFF  36C,FEA
05F28:  MOVFF  FEF,3BD
05F2C:  MOVFF  36A,3FA
05F30:  MOVFF  369,3F9
05F34:  CLRF   xFC
05F36:  MOVFF  3BD,3FB
05F3A:  MOVLB  0
05F3C:  CALL   25BE
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
05F40:  MOVLW  03
05F42:  MOVLB  3
05F44:  MOVWF  xBE
05F46:  MOVLW  71
05F48:  MOVWF  xBD
05F4A:  MOVLB  0
05F4C:  RCALL  5DE2
....................  
....................     *code = packet.Type; 
05F4E:  MOVLB  3
05F50:  MOVFF  367,FE9
05F54:  MOVFF  368,FEA
05F58:  MOVFF  371,FEF
....................     *id = packet.Identifier; 
05F5C:  MOVFF  36D,FE9
05F60:  MOVFF  36E,FEA
05F64:  MOVFF  376,FEC
05F68:  MOVF   FED,F
05F6A:  MOVFF  375,FEF
....................     *seq = packet.SequenceNumber; 
05F6E:  MOVFF  36F,FE9
05F72:  MOVFF  370,FEA
05F76:  MOVFF  378,FEC
05F7A:  MOVF   FED,F
05F7C:  MOVFF  377,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
05F80:  MOVF   xBB,W
05F82:  SUBWF  xB9,W
05F84:  BNZ   5F8C
05F86:  MOVF   xBC,W
05F88:  SUBWF  xBA,W
05F8A:  BZ    5F90
05F8C:  MOVLW  00
05F8E:  BRA    5F92
05F90:  MOVLW  01
05F92:  MOVWF  01
.................... } 
05F94:  MOVLB  0
05F96:  GOTO   89CC (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
05F9A:  MOVLW  01
05F9C:  MOVLB  3
05F9E:  MOVWF  xEB
05FA0:  MOVLB  0
05FA2:  CALL   1AEA
05FA6:  MOVFF  01,3B9
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
05FAA:  MOVLB  3
05FAC:  INCFSZ xB9,W
05FAE:  BRA    5FB2
....................       return; 
05FB0:  BRA    60AE
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
05FB2:  MOVFF  3B9,404
05FB6:  MOVLB  4
05FB8:  CLRF   x06
05FBA:  MOVLW  14
05FBC:  MOVWF  x05
05FBE:  MOVLB  0
05FC0:  CALL   1B14
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
05FC4:  CLRF   03
05FC6:  MOVLB  3
05FC8:  MOVF   x6A,W
05FCA:  ADDLW  08
05FCC:  MOVWF  xB7
05FCE:  MOVLW  00
05FD0:  ADDWFC 03,W
05FD2:  MOVWF  xB8
....................  
....................     packet.Code             = 0; 
05FD4:  CLRF   x70
....................     packet.Type             = code; 
05FD6:  MOVFF  367,36F
....................     packet.Checksum         = 0; 
05FDA:  CLRF   x72
05FDC:  CLRF   x71
....................     packet.Identifier       = id; 
05FDE:  MOVFF  36C,374
05FE2:  MOVFF  36B,373
....................     packet.SequenceNumber   = seq; 
05FE6:  MOVFF  36E,376
05FEA:  MOVFF  36D,375
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
05FEE:  MOVLW  03
05FF0:  MOVWF  FEA
05FF2:  MOVLW  77
05FF4:  MOVWF  FE9
05FF6:  MOVFF  369,FE2
05FFA:  MOVFF  368,FE1
05FFE:  MOVF   x6A,W
06000:  MOVWF  01
06002:  BZ    600C
06004:  MOVFF  FE6,FEE
06008:  DECFSZ 01,F
0600A:  BRA    6004
....................  
....................     SwapICMPPacket(&packet); 
0600C:  MOVLW  03
0600E:  MOVWF  xBE
06010:  MOVLW  6F
06012:  MOVWF  xBD
06014:  MOVLB  0
06016:  RCALL  5DE2
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
06018:  MOVLW  08
0601A:  MOVLB  3
0601C:  ADDWF  x6A,W
0601E:  CLRF   xBB
06020:  MOVWF  xBA
06022:  MOVFF  366,3EC
06026:  MOVFF  365,3EB
0602A:  MOVLW  01
0602C:  MOVWF  xED
0602E:  MOVFF  3BB,3EF
06032:  MOVFF  3BA,3EE
06036:  MOVLB  0
06038:  CALL   2308
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
0603C:  MOVLW  03
0603E:  MOVLB  3
06040:  MOVWF  xBB
06042:  MOVLW  6F
06044:  MOVFF  3BB,410
06048:  MOVFF  FE8,40F
0604C:  MOVFF  3B8,412
06050:  MOVFF  3B7,411
06054:  MOVLB  0
06056:  CALL   2118
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
0605A:  MOVLB  4
0605C:  CLRF   x05
0605E:  MOVLW  14
06060:  MOVWF  x04
06062:  MOVFF  3B8,407
06066:  MOVFF  3B7,406
0606A:  MOVLB  0
0606C:  CALL   2230
06070:  MOVFF  02,372
06074:  MOVFF  01,371
....................    IPSetTxBuffer(MyTxBuffer, 2); 
06078:  MOVFF  3B9,404
0607C:  MOVLB  4
0607E:  CLRF   x06
06080:  MOVLW  16
06082:  MOVWF  x05
06084:  MOVLB  0
06086:  CALL   1B14
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
0608A:  MOVLW  03
0608C:  MOVLB  3
0608E:  MOVWF  xBB
06090:  MOVLW  71
06092:  MOVFF  3BB,410
06096:  MOVFF  FE8,40F
0609A:  MOVLB  4
0609C:  CLRF   x12
0609E:  MOVLW  02
060A0:  MOVWF  x11
060A2:  MOVLB  0
060A4:  CALL   2118
.................... #endif 
....................  
....................  
....................     MACFlush(); 
060A8:  CALL   2622
060AC:  MOVLB  3
.................... } 
060AE:  MOVLB  0
060B0:  GOTO   8A2A (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
05DE2:  MOVLW  04
05DE4:  MOVLB  3
05DE6:  ADDWF  xBD,W
05DE8:  MOVWF  01
05DEA:  MOVLW  00
05DEC:  ADDWFC xBE,W
05DEE:  MOVWF  03
05DF0:  MOVFF  01,3BF
05DF4:  MOVWF  xC0
05DF6:  MOVLW  04
05DF8:  ADDWF  xBD,W
05DFA:  MOVWF  FE9
05DFC:  MOVLW  00
05DFE:  ADDWFC xBE,W
05E00:  MOVWF  FEA
05E02:  MOVFF  FEC,3C2
05E06:  MOVF   FED,F
05E08:  MOVFF  FEF,3C1
05E0C:  MOVFF  3C2,40B
05E10:  MOVFF  3C1,40A
05E14:  MOVLB  0
05E16:  CALL   1CDA
05E1A:  MOVFF  3C0,FEA
05E1E:  MOVFF  3BF,FE9
05E22:  MOVFF  02,FEC
05E26:  MOVF   FED,F
05E28:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
05E2C:  MOVLW  06
05E2E:  MOVLB  3
05E30:  ADDWF  xBD,W
05E32:  MOVWF  01
05E34:  MOVLW  00
05E36:  ADDWFC xBE,W
05E38:  MOVWF  03
05E3A:  MOVFF  01,3BF
05E3E:  MOVWF  xC0
05E40:  MOVLW  06
05E42:  ADDWF  xBD,W
05E44:  MOVWF  FE9
05E46:  MOVLW  00
05E48:  ADDWFC xBE,W
05E4A:  MOVWF  FEA
05E4C:  MOVFF  FEC,3C2
05E50:  MOVF   FED,F
05E52:  MOVFF  FEF,3C1
05E56:  MOVFF  3C2,40B
05E5A:  MOVFF  3C1,40A
05E5E:  MOVLB  0
05E60:  CALL   1CDA
05E64:  MOVFF  3C0,FEA
05E68:  MOVFF  3BF,FE9
05E6C:  MOVFF  02,FEC
05E70:  MOVF   FED,F
05E72:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
05E76:  MOVLW  02
05E78:  MOVLB  3
05E7A:  ADDWF  xBD,W
05E7C:  MOVWF  01
05E7E:  MOVLW  00
05E80:  ADDWFC xBE,W
05E82:  MOVWF  03
05E84:  MOVFF  01,3BF
05E88:  MOVWF  xC0
05E8A:  MOVLW  02
05E8C:  ADDWF  xBD,W
05E8E:  MOVWF  FE9
05E90:  MOVLW  00
05E92:  ADDWFC xBE,W
05E94:  MOVWF  FEA
05E96:  MOVFF  FEC,3C2
05E9A:  MOVF   FED,F
05E9C:  MOVFF  FEF,3C1
05EA0:  MOVFF  3C2,40B
05EA4:  MOVFF  3C1,40A
05EA8:  MOVLB  0
05EAA:  CALL   1CDA
05EAE:  MOVFF  3C0,FEA
05EB2:  MOVFF  3BF,FE9
05EB6:  MOVFF  02,FEC
05EBA:  MOVF   FED,F
05EBC:  MOVFF  01,FEF
.................... } 
05EC0:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Darren Rook (CCS)     06/28/04 CCS Port now incorporates 2.20 fixes (above) 
....................  * Darren Rook (CCS)     06/29/04 UDPSocketInfo[] and FindMatching_UDP_Socket() 
....................  *                                no longer static. 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug 
....................  *                         when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets 
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would 
....................  *                         unintentionally keep the remote MAC 
....................  *                         address cached, even after calling 
....................  *                         UDPInit(), UDPClose(), or reseting 
....................  *                         the part without clearing all the 
....................  *                         PICmicro memory. 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
....................  
.................... #if !(STACK_USE_UDP) 
....................  #error do not include UDP.C/UDP.H if STACK_USE_UDP is set to FALSE 
.................... #endif 
....................  
.................... #define debug_udp 
.................... //#define debug_udp debug_printf 
....................  
.................... UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, NODE_INFO *remoteNode, IP_ADDR *localIP); 
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
0164A:  MOVLB  3
0164C:  CLRF   x5F
0164E:  MOVF   x5F,W
01650:  SUBLW  01
01652:  BNC   1662
....................     { 
....................       UDPClose(s); 
01654:  MOVFF  35F,37E
01658:  MOVLB  0
0165A:  RCALL  15CC
....................     } 
0165C:  MOVLB  3
0165E:  INCF   x5F,F
01660:  BRA    164E
.................... } 
01662:  MOVLB  0
01664:  GOTO   2C00 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, broadcast node address is set. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A valid port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            This call must always have valid localPort 
....................  *                  value. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................  
....................     p = &UDPSocketInfo[0]; 
*
07782:  MOVLB  3
07784:  CLRF   x86
07786:  MOVLW  5B
07788:  MOVWF  x85
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
0778A:  CLRF   x84
0778C:  MOVF   x84,W
0778E:  SUBLW  01
07790:  BNC   7840
....................     { 
....................         if ( p->localPort == INVALID_UDP_PORT ) 
07792:  MOVLW  0C
07794:  ADDWF  x85,W
07796:  MOVWF  FE9
07798:  MOVLW  00
0779A:  ADDWFC x86,W
0779C:  MOVWF  FEA
0779E:  MOVFF  FEC,388
077A2:  MOVF   FED,F
077A4:  MOVFF  FEF,387
077A8:  MOVF   x87,F
077AA:  BNZ   7834
077AC:  MOVF   x88,F
077AE:  BNZ   7834
....................         { 
....................             p->localPort    = localPort; 
077B0:  MOVLW  0C
077B2:  ADDWF  x85,W
077B4:  MOVWF  FE9
077B6:  MOVLW  00
077B8:  ADDWFC x86,W
077BA:  MOVWF  FEA
077BC:  MOVFF  37F,FEC
077C0:  MOVF   FED,F
077C2:  MOVFF  37E,FEF
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if ( remoteNode ) 
077C6:  MOVF   x80,W
077C8:  IORWF  x81,W
077CA:  BZ    77F0
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
077CC:  MOVFF  385,387
077D0:  MOVFF  386,388
077D4:  MOVFF  386,FEA
077D8:  MOVFF  385,FE9
077DC:  MOVFF  381,FE2
077E0:  MOVFF  380,FE1
077E4:  MOVLW  0A
077E6:  MOVWF  01
077E8:  MOVFF  FE6,FEE
077EC:  DECFSZ 01,F
077EE:  BRA    77E8
....................             } 
....................             // else Set broadcast address - TO BE DONE */ 
....................  
....................  
....................             p->remotePort   = remotePort; 
077F0:  MOVLW  0A
077F2:  ADDWF  x85,W
077F4:  MOVWF  FE9
077F6:  MOVLW  00
077F8:  ADDWFC x86,W
077FA:  MOVWF  FEA
077FC:  MOVFF  383,FEC
07800:  MOVF   FED,F
07802:  MOVFF  382,FEF
....................             p->TxCount      = 0; 
07806:  MOVLW  0E
07808:  ADDWF  x85,W
0780A:  MOVWF  FE9
0780C:  MOVLW  00
0780E:  ADDWFC x86,W
07810:  MOVWF  FEA
07812:  CLRF   FEC
07814:  MOVF   FED,F
07816:  CLRF   FEF
....................             p->RxCount      = 0; 
07818:  MOVLW  10
0781A:  ADDWF  x85,W
0781C:  MOVWF  FE9
0781E:  MOVLW  00
07820:  ADDWFC x86,W
07822:  MOVWF  FEA
07824:  CLRF   FEC
07826:  MOVF   FED,F
07828:  CLRF   FEF
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
0782A:  MOVFF  384,5A
....................             return s; 
0782E:  MOVFF  384,01
07832:  BRA    7844
....................         } 
....................         p++; 
07834:  MOVLW  16
07836:  ADDWF  x85,F
07838:  BTFSC  FD8.0
0783A:  INCF   x86,F
....................     } 
0783C:  INCF   x84,F
0783E:  BRA    778C
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
07840:  MOVLW  FF
07842:  MOVWF  01
.................... } 
07844:  MOVLB  0
07846:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................     UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
*
015CC:  MOVLB  3
015CE:  MOVF   x7E,W
015D0:  MULLW  16
015D2:  MOVF   FF3,W
015D4:  CLRF   x80
015D6:  MOVWF  x7F
015D8:  MOVLW  0C
015DA:  ADDWF  x7F,W
015DC:  MOVWF  01
015DE:  MOVLW  00
015E0:  ADDWFC x80,W
015E2:  MOVWF  03
015E4:  MOVF   01,W
015E6:  ADDLW  5B
015E8:  MOVWF  FE9
015EA:  MOVLW  00
015EC:  ADDWFC 03,W
015EE:  MOVWF  FEA
015F0:  CLRF   FEC
015F2:  MOVF   FED,F
015F4:  CLRF   FEF
....................    UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000; 
015F6:  MOVF   x7E,W
015F8:  MULLW  16
015FA:  MOVF   FF3,W
015FC:  CLRF   x80
015FE:  MOVWF  x7F
01600:  MOVLW  06
01602:  ADDWF  x7F,F
01604:  MOVLW  00
01606:  ADDWFC x80,F
01608:  MOVLW  5B
0160A:  ADDWF  x7F,W
0160C:  MOVWF  FE9
0160E:  MOVLW  00
01610:  ADDWFC x80,W
01612:  MOVWF  FEA
01614:  MOVF   FEE,F
01616:  MOVF   FEE,F
01618:  CLRF   FEC
0161A:  MOVF   FED,F
0161C:  CLRF   FEF
0161E:  MOVF   FED,F
01620:  CLRF   FEF
01622:  MOVF   FED,F
01624:  CLRF   FEF
....................     UDPSocketInfo[s].Flags.bFirstRead = FALSE; 
01626:  MOVF   x7E,W
01628:  MULLW  16
0162A:  MOVF   FF3,W
0162C:  CLRF   x80
0162E:  MOVWF  x7F
01630:  MOVLW  15
01632:  ADDWF  x7F,F
01634:  MOVLW  00
01636:  ADDWFC x80,F
01638:  MOVLW  5B
0163A:  ADDWF  x7F,W
0163C:  MOVWF  FE9
0163E:  MOVLW  00
01640:  ADDWFC x80,W
01642:  MOVWF  FEA
01644:  BCF    FEF.0
.................... } 
01646:  MOVLB  0
01648:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................     UDP_SOCKET_INFO *p; 
....................     WORD temp; 
....................     WORD tempOffset; 
....................     WORD tempCount; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
079B4:  MOVF   5A,W
079B6:  MULLW  16
079B8:  MOVF   FF3,W
079BA:  CLRF   03
079BC:  ADDLW  5B
079BE:  MOVWF  01
079C0:  MOVLW  00
079C2:  ADDWFC 03,F
079C4:  MOVFF  01,386
079C8:  MOVLB  3
079CA:  MOVFF  03,387
....................  
....................     tempCount=p->TxCount; 
079CE:  MOVLW  0E
079D0:  ADDWF  x86,W
079D2:  MOVWF  FE9
079D4:  MOVLW  00
079D6:  ADDWFC x87,W
079D8:  MOVWF  FEA
079DA:  MOVFF  FEC,03
079DE:  MOVF   FED,F
079E0:  MOVFF  FEF,38C
079E4:  MOVFF  03,38D
....................  
....................     if ( tempCount == 0 ) 
079E8:  MOVF   x8C,F
079EA:  BNZ   7A66
079EC:  MOVF   x8D,F
079EE:  BNZ   7A66
....................     { 
....................         // This is the very first byte that is loaded in UDP buffer. 
....................         // Remember what transmit buffer we are loading, and 
....................         // start loading this and next bytes in data area of UDP packet. 
....................         p->TxBuffer = MACGetTxBuffer(TRUE); 
079F0:  MOVLW  12
079F2:  ADDWF  x86,W
079F4:  MOVWF  01
079F6:  MOVLW  00
079F8:  ADDWFC x87,W
079FA:  MOVWF  03
079FC:  MOVFF  01,38E
07A00:  MOVWF  x8F
07A02:  MOVLW  01
07A04:  MOVWF  xEB
07A06:  MOVLB  0
07A08:  CALL   1AEA
07A0C:  MOVFF  38F,FEA
07A10:  MOVFF  38E,FE9
07A14:  MOVFF  01,FEF
....................  
....................       // Make sure that we received a TX buffer 
....................       if(p->TxBuffer == INVALID_BUFFER) 
07A18:  MOVLW  12
07A1A:  MOVLB  3
07A1C:  ADDWF  x86,W
07A1E:  MOVWF  FE9
07A20:  MOVLW  00
07A22:  ADDWFC x87,W
07A24:  MOVWF  FEA
07A26:  INCFSZ FEF,W
07A28:  BRA    7A30
....................          return FALSE; 
07A2A:  MOVLW  00
07A2C:  MOVWF  01
07A2E:  BRA    7AEC
....................  
....................         IPSetTxBuffer(p->TxBuffer, sizeof(UDP_HEADER)); 
07A30:  MOVLW  12
07A32:  ADDWF  x86,W
07A34:  MOVWF  FE9
07A36:  MOVLW  00
07A38:  ADDWFC x87,W
07A3A:  MOVWF  FEA
07A3C:  MOVFF  FEF,38E
07A40:  MOVFF  38E,404
07A44:  MOVLB  4
07A46:  CLRF   x06
07A48:  MOVLW  1C
07A4A:  MOVWF  x05
07A4C:  MOVLB  0
07A4E:  CALL   1B14
....................  
....................         p->TxOffset = 0; 
07A52:  MOVLW  13
07A54:  MOVLB  3
07A56:  ADDWF  x86,W
07A58:  MOVWF  FE9
07A5A:  MOVLW  00
07A5C:  ADDWFC x87,W
07A5E:  MOVWF  FEA
07A60:  CLRF   FEC
07A62:  MOVF   FED,F
07A64:  CLRF   FEF
....................     } 
....................  
....................     tempOffset=p->TxOffset; 
07A66:  MOVLW  13
07A68:  ADDWF  x86,W
07A6A:  MOVWF  FE9
07A6C:  MOVLW  00
07A6E:  ADDWFC x87,W
07A70:  MOVWF  FEA
07A72:  MOVFF  FEC,03
07A76:  MOVF   FED,F
07A78:  MOVFF  FEF,38A
07A7C:  MOVFF  03,38B
....................  
....................    /*if (v>=0x20) 
....................       debug_udp("-%c", v); 
....................    else 
....................       debug_udp("-0x%X", v);*/ 
....................        
....................     // Load it. 
....................     MACPut(v); 
07A80:  MOVFF  385,40E
07A84:  MOVLB  0
07A86:  CALL   20FE
....................  
....................     // Keep track of number of bytes loaded. 
....................     // If total bytes fill up buffer, transmit it. 
....................     if (tempOffset >= tempCount) 
07A8A:  MOVLB  3
07A8C:  MOVF   x8D,W
07A8E:  SUBWF  x8B,W
07A90:  BNC   7AA0
07A92:  BNZ   7A9A
07A94:  MOVF   x8C,W
07A96:  SUBWF  x8A,W
07A98:  BNC   7AA0
....................     { 
....................       tempCount++; 
07A9A:  INCF   x8C,F
07A9C:  BTFSC  FD8.2
07A9E:  INCF   x8D,F
....................     } 
....................     tempOffset++; 
07AA0:  INCF   x8A,F
07AA2:  BTFSC  FD8.2
07AA4:  INCF   x8B,F
....................  
....................     /* //broken in ccs? 
....................     if ( p->TxOffset++ >= p->TxCount ) 
....................     { 
....................         p->TxCount++; 
....................         debug_udp("!"); 
....................     } 
....................     */ 
....................  
....................  
....................  
.................... #define SIZEOF_MAC_HEADER       (14) 
....................  
....................     // Depending on what communication media is used, allowable UDP 
....................     // data length will vary. 
.................... #if STACK_USE_SLIP 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - SIZEOF_MAC_HEADER - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) 
.................... #else 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) ) 
.................... #endif 
....................  
....................    p->TxOffset = tempOffset; 
07AA6:  MOVLW  13
07AA8:  ADDWF  x86,W
07AAA:  MOVWF  FE9
07AAC:  MOVLW  00
07AAE:  ADDWFC x87,W
07AB0:  MOVWF  FEA
07AB2:  MOVFF  38B,FEC
07AB6:  MOVF   FED,F
07AB8:  MOVFF  38A,FEF
....................  
....................     //temp = p->TxCount; 
....................     //if ( temp >= MAX_UDP_DATA ) 
....................     p->TxCount = tempCount; 
07ABC:  MOVLW  0E
07ABE:  ADDWF  x86,W
07AC0:  MOVWF  FE9
07AC2:  MOVLW  00
07AC4:  ADDWFC x87,W
07AC6:  MOVWF  FEA
07AC8:  MOVFF  38D,FEC
07ACC:  MOVF   FED,F
07ACE:  MOVFF  38C,FEF
....................     if (tempCount >= MAX_UDP_DATA) 
07AD2:  MOVF   x8D,W
07AD4:  SUBLW  02
07AD6:  BC    7AE8
07AD8:  XORLW  FF
07ADA:  BNZ   7AE2
07ADC:  MOVF   x8C,W
07ADE:  SUBLW  E3
07AE0:  BC    7AE8
....................     { 
....................         UDPFlush(); 
07AE2:  MOVLB  0
07AE4:  RCALL  785C
07AE6:  MOVLB  3
....................     } 
.................... #undef MAX_UDP_DATA 
....................  
....................  
....................     return TRUE; 
07AE8:  MOVLW  01
07AEA:  MOVWF  01
.................... } 
07AEC:  MOVLB  0
07AEE:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     // Wait for TX hardware to become available (finish transmitting 
....................     // any previous packet) 
....................     while( !IPIsTxReady(TRUE) ); 
*
0785C:  MOVLW  01
0785E:  MOVLB  3
07860:  MOVWF  xEB
07862:  MOVLB  0
07864:  CALL   1AC0
07868:  MOVF   01,F
0786A:  BZ    785C
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
0786C:  MOVF   5A,W
0786E:  MULLW  16
07870:  MOVF   FF3,W
07872:  CLRF   03
07874:  ADDLW  5B
07876:  MOVWF  01
07878:  MOVLW  00
0787A:  ADDWFC 03,F
0787C:  MOVFF  01,396
07880:  MOVLB  3
07882:  MOVFF  03,397
....................  
....................     debug_udp("\r\nUDP FLUSH - Sok:%U TxC:%LU SP:%LU DP:%LU ", 
....................          activeUDPSocket, 
....................          p->TxCount, 
....................          p->localPort, 
....................          p->remotePort 
....................       ); 
....................     debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          p->remoteNode.MACAddr.v[0], 
....................          p->remoteNode.MACAddr.v[1], 
....................          p->remoteNode.MACAddr.v[2], 
....................          p->remoteNode.MACAddr.v[3], 
....................          p->remoteNode.MACAddr.v[4], 
....................          p->remoteNode.MACAddr.v[5] 
....................       ); 
....................  
....................  
....................     h.SourcePort        = swaps(p->localPort); 
07886:  MOVLW  0C
07888:  ADDWF  x96,W
0788A:  MOVWF  FE9
0788C:  MOVLW  00
0788E:  ADDWFC x97,W
07890:  MOVWF  FEA
07892:  MOVFF  FEC,399
07896:  MOVF   FED,F
07898:  MOVFF  FEF,398
0789C:  MOVFF  399,40B
078A0:  MOVFF  398,40A
078A4:  MOVLB  0
078A6:  CALL   1CDA
078AA:  MOVFF  02,38F
078AE:  MOVFF  01,38E
....................     h.DestinationPort   = swaps(p->remotePort); 
078B2:  MOVLW  0A
078B4:  MOVLB  3
078B6:  ADDWF  x96,W
078B8:  MOVWF  FE9
078BA:  MOVLW  00
078BC:  ADDWFC x97,W
078BE:  MOVWF  FEA
078C0:  MOVFF  FEC,399
078C4:  MOVF   FED,F
078C6:  MOVFF  FEF,398
078CA:  MOVFF  399,40B
078CE:  MOVFF  398,40A
078D2:  MOVLB  0
078D4:  CALL   1CDA
078D8:  MOVFF  02,391
078DC:  MOVFF  01,390
....................     h.Length            = (WORD)((WORD)p->TxCount + (WORD)sizeof(UDP_HEADER)); 
078E0:  MOVLW  0E
078E2:  MOVLB  3
078E4:  ADDWF  x96,W
078E6:  MOVWF  FE9
078E8:  MOVLW  00
078EA:  ADDWFC x97,W
078EC:  MOVWF  FEA
078EE:  MOVFF  FEC,399
078F2:  MOVF   FED,F
078F4:  MOVFF  FEF,398
078F8:  MOVLW  08
078FA:  ADDWF  x98,W
078FC:  MOVWF  x92
078FE:  MOVLW  00
07900:  ADDWFC x99,W
07902:  MOVWF  x93
....................     // Do not swap h.Length yet.  It is needed in IPPutHeader. 
....................     h.Checksum          = 0x0000; 
07904:  CLRF   x95
07906:  CLRF   x94
....................  
....................     IPSetTxBuffer(p->TxBuffer, 0); 
07908:  MOVLW  12
0790A:  ADDWF  x96,W
0790C:  MOVWF  FE9
0790E:  MOVLW  00
07910:  ADDWFC x97,W
07912:  MOVWF  FEA
07914:  MOVFF  FEF,398
07918:  MOVFF  398,404
0791C:  MOVLB  4
0791E:  CLRF   x06
07920:  MOVLW  14
07922:  MOVWF  x05
07924:  MOVLB  0
07926:  CALL   1B14
....................  
....................     /* 
....................      * Load IP header. 
....................      */ 
....................  
....................     IPPutHeader( &p->remoteNode, 
....................                  IP_PROT_UDP, 
....................                  h.Length ); 
0792A:  MOVLB  3
0792C:  MOVFF  396,01
07930:  MOVFF  397,03
07934:  MOVFF  396,398
07938:  MOVFF  397,399
0793C:  MOVFF  397,3EC
07940:  MOVFF  396,3EB
07944:  MOVLW  11
07946:  MOVWF  xED
07948:  MOVFF  393,3EF
0794C:  MOVFF  392,3EE
07950:  MOVLB  0
07952:  CALL   2308
....................  
....................  
....................     // Now swap h.Length. 
....................     h.Length            = swaps(h.Length); 
07956:  MOVFF  393,40B
0795A:  MOVFF  392,40A
0795E:  CALL   1CDA
07962:  MOVFF  02,393
07966:  MOVFF  01,392
....................  
....................     // Now load UDP header. 
....................     IPPutArray((BYTE*)&h, sizeof(h)); 
0796A:  MOVLW  03
0796C:  MOVLB  3
0796E:  MOVWF  x99
07970:  MOVLW  8E
07972:  MOVFF  399,410
07976:  MOVFF  FE8,40F
0797A:  MOVLB  4
0797C:  CLRF   x12
0797E:  MOVLW  08
07980:  MOVWF  x11
07982:  MOVLB  0
07984:  CALL   2118
....................  
....................      // Update checksum. 
....................      // TO BE IMPLEMENTED 
....................  
....................     MACFlush(); 
07988:  CALL   2622
....................  
....................     // The buffer was reserved with AutoFree, so we can immediately 
....................    // discard it.  The MAC layer will free it after transmission. 
....................     p->TxBuffer         = INVALID_BUFFER; 
0798C:  MOVLW  12
0798E:  MOVLB  3
07990:  ADDWF  x96,W
07992:  MOVWF  FE9
07994:  MOVLW  00
07996:  ADDWFC x97,W
07998:  MOVWF  FEA
0799A:  MOVLW  FF
0799C:  MOVWF  FEF
....................     p->TxCount          = 0; 
0799E:  MOVLW  0E
079A0:  ADDWF  x96,W
079A2:  MOVWF  FE9
079A4:  MOVLW  00
079A6:  ADDWFC x97,W
079A8:  MOVWF  FEA
079AA:  CLRF   FEC
079AC:  MOVF   FED,F
079AE:  CLRF   FEF
....................  
.................... } 
079B0:  MOVLB  0
079B2:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
07CE4:  MOVFF  37E,5A
....................     return ( UDPSocketInfo[activeUDPSocket].RxCount > 0); 
07CE8:  MOVF   5A,W
07CEA:  MULLW  16
07CEC:  MOVF   FF3,W
07CEE:  MOVLB  3
07CF0:  CLRF   x80
07CF2:  MOVWF  x7F
07CF4:  MOVLW  10
07CF6:  ADDWF  x7F,W
07CF8:  MOVWF  01
07CFA:  MOVLW  00
07CFC:  ADDWFC x80,W
07CFE:  MOVWF  03
07D00:  MOVF   01,W
07D02:  ADDLW  5B
07D04:  MOVWF  FE9
07D06:  MOVLW  00
07D08:  ADDWFC 03,W
07D0A:  MOVWF  FEA
07D0C:  MOVFF  FEC,380
07D10:  MOVF   FED,F
07D12:  MOVFF  FEF,37F
07D16:  MOVF   x7F,F
07D18:  BNZ   7D22
07D1A:  MOVF   x80,F
07D1C:  BNZ   7D22
07D1E:  MOVLW  00
07D20:  BRA    7D24
07D22:  MOVLW  01
07D24:  MOVWF  01
.................... } 
07D26:  MOVLB  0
07D28:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................     // CALLER MUST MAKE SURE THAT THERE IS ENOUGH DATA BYTE IN BUFFER 
....................     // BEFORE CALLING THIS FUNCTION. 
....................     // USE UDPIsGetReady() TO CONFIRM. 
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
07D2A:  MOVF   5A,W
07D2C:  MULLW  16
07D2E:  MOVF   FF3,W
07D30:  MOVLB  3
07D32:  CLRF   x85
07D34:  MOVWF  x84
07D36:  MOVLW  10
07D38:  ADDWF  x84,W
07D3A:  MOVWF  01
07D3C:  MOVLW  00
07D3E:  ADDWFC x85,W
07D40:  MOVWF  03
07D42:  MOVF   01,W
07D44:  ADDLW  5B
07D46:  MOVWF  FE9
07D48:  MOVLW  00
07D4A:  ADDWFC 03,W
07D4C:  MOVWF  FEA
07D4E:  MOVFF  FEC,385
07D52:  MOVF   FED,F
07D54:  MOVFF  FEF,384
07D58:  MOVF   x84,F
07D5A:  BNZ   7D66
07D5C:  MOVF   x85,F
07D5E:  BNZ   7D66
....................         return FALSE; 
07D60:  MOVLW  00
07D62:  MOVWF  01
07D64:  BRA    7E40
....................  
....................     // If if this very first read to packet, set MAC Rx Pointer to 
....................     // beginig of UDP data area. 
....................     if ( UDPSocketInfo[activeUDPSocket].Flags.bFirstRead ) 
07D66:  MOVF   5A,W
07D68:  MULLW  16
07D6A:  MOVF   FF3,W
07D6C:  CLRF   x85
07D6E:  MOVWF  x84
07D70:  MOVLW  15
07D72:  ADDWF  x84,F
07D74:  MOVLW  00
07D76:  ADDWFC x85,F
07D78:  MOVLW  5B
07D7A:  ADDWF  x84,W
07D7C:  MOVWF  FE9
07D7E:  MOVLW  00
07D80:  ADDWFC x85,W
07D82:  MOVWF  FEA
07D84:  BTFSS  FEF.0
07D86:  BRA    7DB4
....................     { 
....................         UDPSocketInfo[activeUDPSocket].Flags.bFirstRead = FALSE; 
07D88:  MOVF   5A,W
07D8A:  MULLW  16
07D8C:  MOVF   FF3,W
07D8E:  CLRF   x85
07D90:  MOVWF  x84
07D92:  MOVLW  15
07D94:  ADDWF  x84,F
07D96:  MOVLW  00
07D98:  ADDWFC x85,F
07D9A:  MOVLW  5B
07D9C:  ADDWF  x84,W
07D9E:  MOVWF  FE9
07DA0:  MOVLW  00
07DA2:  ADDWFC x85,W
07DA4:  MOVWF  FEA
07DA6:  BCF    FEF.0
....................         UDPSetRxBuffer(0); 
07DA8:  CLRF   x93
07DAA:  MOVLW  08
07DAC:  MOVWF  x92
07DAE:  MOVLB  0
07DB0:  CALL   4BA0
....................     } 
....................  
....................     *v = MACGet(); 
07DB4:  MOVFF  383,03
07DB8:  MOVFF  382,384
07DBC:  MOVFF  383,385
07DC0:  MOVLB  0
07DC2:  CALL   2438
07DC6:  MOVFF  385,FEA
07DCA:  MOVFF  384,FE9
07DCE:  MOVFF  01,FEF
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount--; 
07DD2:  MOVF   5A,W
07DD4:  MULLW  16
07DD6:  MOVF   FF3,W
07DD8:  MOVLB  3
07DDA:  CLRF   x85
07DDC:  MOVWF  x84
07DDE:  MOVLW  10
07DE0:  ADDWF  x84,W
07DE2:  MOVWF  01
07DE4:  MOVLW  00
07DE6:  ADDWFC x85,W
07DE8:  MOVWF  03
07DEA:  MOVF   01,W
07DEC:  ADDLW  5B
07DEE:  MOVWF  FE9
07DF0:  MOVLW  00
07DF2:  ADDWFC 03,W
07DF4:  MOVWF  FEA
07DF6:  MOVLW  FF
07DF8:  ADDWF  FEF,F
07DFA:  BC    7E00
07DFC:  MOVF   FEE,F
07DFE:  DECF   FED,F
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
07E00:  MOVF   5A,W
07E02:  MULLW  16
07E04:  MOVF   FF3,W
07E06:  CLRF   x85
07E08:  MOVWF  x84
07E0A:  MOVLW  10
07E0C:  ADDWF  x84,W
07E0E:  MOVWF  01
07E10:  MOVLW  00
07E12:  ADDWFC x85,W
07E14:  MOVWF  03
07E16:  MOVF   01,W
07E18:  ADDLW  5B
07E1A:  MOVWF  FE9
07E1C:  MOVLW  00
07E1E:  ADDWFC 03,W
07E20:  MOVWF  FEA
07E22:  MOVFF  FEC,385
07E26:  MOVF   FED,F
07E28:  MOVFF  FEF,384
07E2C:  MOVF   x84,F
07E2E:  BNZ   7E3C
07E30:  MOVF   x85,F
07E32:  BNZ   7E3C
....................     { 
....................         MACDiscardRx(); 
07E34:  MOVLB  0
07E36:  CALL   1908
07E3A:  MOVLB  3
....................     } 
....................  
....................     return TRUE; 
07E3C:  MOVLW  01
07E3E:  MOVWF  01
.................... } 
07E40:  MOVLB  0
07E42:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount ) 
07E44:  MOVF   5A,W
07E46:  MULLW  16
07E48:  MOVF   FF3,W
07E4A:  MOVLB  3
07E4C:  CLRF   x7F
07E4E:  MOVWF  x7E
07E50:  MOVLW  10
07E52:  ADDWF  x7E,W
07E54:  MOVWF  01
07E56:  MOVLW  00
07E58:  ADDWFC x7F,W
07E5A:  MOVWF  03
07E5C:  MOVF   01,W
07E5E:  ADDLW  5B
07E60:  MOVWF  FE9
07E62:  MOVLW  00
07E64:  ADDWFC 03,W
07E66:  MOVWF  FEA
07E68:  MOVF   FEF,F
07E6A:  BNZ   7E70
07E6C:  MOVF   FEC,F
07E6E:  BZ    7E78
....................         MACDiscardRx(); 
07E70:  MOVLB  0
07E72:  CALL   1908
07E76:  MOVLB  3
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount = 0; 
07E78:  MOVF   5A,W
07E7A:  MULLW  16
07E7C:  MOVF   FF3,W
07E7E:  CLRF   x7F
07E80:  MOVWF  x7E
07E82:  MOVLW  10
07E84:  ADDWF  x7E,W
07E86:  MOVWF  01
07E88:  MOVLW  00
07E8A:  ADDWFC x7F,W
07E8C:  MOVWF  03
07E8E:  MOVF   01,W
07E90:  ADDLW  5B
07E92:  MOVWF  FE9
07E94:  MOVLW  00
07E96:  ADDWFC 03,W
07E98:  MOVWF  FEA
07E9A:  CLRF   FEC
07E9C:  MOVF   FED,F
07E9E:  CLRF   FEF
.................... } 
07EA0:  MOVLB  0
07EA2:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... /* 
....................  * Pseudo header as defined by rfc 793. 
....................  */ 
.................... typedef struct _UDP_PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } UDP_PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER h; 
....................     UDP_SOCKET s; 
....................     UDP_PSEUDO_HEADER pseudoHeader; 
....................     WORD_VAL   checksum; 
....................  
....................     /* 
....................      * Retrieve UDP header. 
....................      */ 
....................     //MACGetArray((BYTE*)&h, sizeof(h)); 
....................     MACGetArray(&h, sizeof(UDP_HEADER)); 
*
04D5E:  MOVLW  03
04D60:  MOVLB  3
04D62:  MOVWF  xFA
04D64:  MOVLW  6B
04D66:  MOVWF  xF9
04D68:  CLRF   xFC
04D6A:  MOVLW  08
04D6C:  MOVWF  xFB
04D6E:  MOVLB  0
04D70:  CALL   25BE
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
04D74:  MOVFF  36C,40B
04D78:  MOVFF  36B,40A
04D7C:  CALL   1CDA
04D80:  MOVFF  02,36C
04D84:  MOVFF  01,36B
....................     h.DestinationPort   = swaps(h.DestinationPort); 
04D88:  MOVFF  36E,40B
04D8C:  MOVFF  36D,40A
04D90:  CALL   1CDA
04D94:  MOVFF  02,36E
04D98:  MOVFF  01,36D
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
04D9C:  MOVFF  370,40B
04DA0:  MOVFF  36F,40A
04DA4:  CALL   1CDA
04DA8:  MOVLW  08
04DAA:  MOVLB  3
04DAC:  SUBWF  01,W
04DAE:  MOVWF  x6F
04DB0:  MOVLW  00
04DB2:  SUBWFB 02,W
04DB4:  MOVWF  x70
....................  
....................       debug_udp("\r\nUDP PROCESS SP=%LX DP=%LX PAYLOAD=%LX ", 
....................             h.SourcePort, 
....................             h.DestinationPort, 
....................             h.Length 
....................          ); 
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
04DB6:  MOVF   x71,W
04DB8:  IORWF  x72,W
04DBA:  BTFSC  FD8.2
04DBC:  BRA    4EE6
....................    { 
....................        h.Checksum          = swaps(h.Checksum); 
04DBE:  MOVFF  372,40B
04DC2:  MOVFF  371,40A
04DC6:  MOVLB  0
04DC8:  CALL   1CDA
04DCC:  MOVFF  02,372
04DD0:  MOVFF  01,371
....................  
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
04DD4:  MOVLW  06
04DD6:  MOVLB  3
04DD8:  ADDWF  x65,W
04DDA:  MOVWF  FE9
04DDC:  MOVLW  00
04DDE:  ADDWFC x66,W
04DE0:  MOVWF  FEA
04DE2:  MOVFF  FEF,00
04DE6:  MOVFF  FEC,01
04DEA:  MOVFF  FEC,02
04DEE:  MOVFF  FEC,03
04DF2:  MOVFF  03,377
04DF6:  MOVFF  02,376
04DFA:  MOVFF  01,375
04DFE:  MOVFF  00,374
....................        pseudoHeader.DestAddress.v[0]   = localIP->v[0]; 
04E02:  MOVFF  367,FE9
04E06:  MOVFF  368,FEA
04E0A:  MOVFF  FEF,378
....................        pseudoHeader.DestAddress.v[1]   = localIP->v[1]; 
04E0E:  MOVLW  01
04E10:  ADDWF  x67,W
04E12:  MOVWF  FE9
04E14:  MOVLW  00
04E16:  ADDWFC x68,W
04E18:  MOVWF  FEA
04E1A:  MOVFF  FEF,379
....................        pseudoHeader.DestAddress.v[2]   = localIP->v[2]; 
04E1E:  MOVLW  02
04E20:  ADDWF  x67,W
04E22:  MOVWF  FE9
04E24:  MOVLW  00
04E26:  ADDWFC x68,W
04E28:  MOVWF  FEA
04E2A:  MOVFF  FEF,37A
....................        pseudoHeader.DestAddress.v[3]   = localIP->v[3]; 
04E2E:  MOVLW  03
04E30:  ADDWF  x67,W
04E32:  MOVWF  FE9
04E34:  MOVLW  00
04E36:  ADDWFC x68,W
04E38:  MOVWF  FEA
04E3A:  MOVFF  FEF,37B
....................        pseudoHeader.Zero               = 0x0; 
04E3E:  CLRF   x7C
....................        pseudoHeader.Protocol           = IP_PROT_UDP; 
04E40:  MOVLW  11
04E42:  MOVWF  x7D
....................        pseudoHeader.Length             = len; 
04E44:  MOVFF  36A,37F
04E48:  MOVFF  369,37E
....................  
....................        SwapPseudoHeader(pseudoHeader); 
04E4C:  MOVFF  37F,40B
04E50:  MOVFF  37E,40A
04E54:  MOVLB  0
04E56:  CALL   1CDA
04E5A:  MOVFF  02,37F
04E5E:  MOVFF  01,37E
....................  
....................        checksum.Val = ~CalcIPChecksum(&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
04E62:  MOVLW  03
04E64:  MOVLB  3
04E66:  MOVWF  xEE
04E68:  MOVLW  74
04E6A:  MOVWF  xED
04E6C:  CLRF   xF0
04E6E:  MOVLW  0C
04E70:  MOVWF  xEF
04E72:  MOVLB  0
04E74:  CALL   1F2E
04E78:  MOVFF  01,380
04E7C:  MOVLB  3
04E7E:  COMF   x80,F
04E80:  MOVFF  02,381
04E84:  COMF   x81,F
....................  
....................  
....................        // Set UDP packet checksum = pseudo header checksum in MAC RAM. 
....................        IPSetRxBuffer(6); 
04E86:  CLRF   x93
04E88:  MOVLW  06
04E8A:  MOVWF  x92
04E8C:  MOVLB  0
04E8E:  RCALL  4BA0
....................        MACPut(checksum.v[0]); 
04E90:  MOVFF  380,40E
04E94:  CALL   20FE
....................       // In case if the end of the RX buffer is reached and a wraparound is needed, set the next address to prevent writing to the wrong address. 
....................        IPSetRxBuffer(7); 
04E98:  MOVLB  3
04E9A:  CLRF   x93
04E9C:  MOVLW  07
04E9E:  MOVWF  x92
04EA0:  MOVLB  0
04EA2:  RCALL  4BA0
....................        MACPut(checksum.v[1]); 
04EA4:  MOVFF  381,40E
04EA8:  CALL   20FE
....................        IPSetRxBuffer(0); 
04EAC:  MOVLB  3
04EAE:  CLRF   x93
04EB0:  CLRF   x92
04EB2:  MOVLB  0
04EB4:  RCALL  4BA0
....................  
....................        // Now calculate UDP packet checksum in NIC RAM - including 
....................        // pesudo header. 
....................        checksum.Val = CalcIPBufferChecksum(len); 
04EB6:  MOVFF  36A,3EC
04EBA:  MOVFF  369,3EB
04EBE:  CALL   2460
04EC2:  MOVFF  02,381
04EC6:  MOVFF  01,380
....................  
....................        if ( checksum.Val != h.Checksum ) 
04ECA:  MOVLB  3
04ECC:  MOVF   x71,W
04ECE:  SUBWF  x80,W
04ED0:  BNZ   4ED8
04ED2:  MOVF   x72,W
04ED4:  SUBWF  x81,W
04ED6:  BZ    4EE6
....................        { 
....................            debug_udp("INVALID-CS "); 
....................            MACDiscardRx(); 
04ED8:  MOVLB  0
04EDA:  CALL   1908
....................            return TRUE; 
04EDE:  MOVLW  01
04EE0:  MOVWF  01
04EE2:  BRA    4F68
04EE4:  MOVLB  3
....................        } 
....................    } 
....................  
....................     s = FindMatching_UDP_Socket(&h, remoteNode, localIP); 
04EE6:  MOVLW  03
04EE8:  MOVWF  x83
04EEA:  MOVLW  6B
04EEC:  MOVWF  x82
04EEE:  MOVFF  366,385
04EF2:  MOVFF  365,384
04EF6:  MOVFF  368,387
04EFA:  MOVFF  367,386
04EFE:  MOVLB  0
04F00:  BRA    4BBA
04F02:  MOVFF  01,373
....................     if ( s == INVALID_UDP_SOCKET ) 
04F06:  MOVLB  3
04F08:  INCFSZ x73,W
04F0A:  BRA    4F16
....................     { 
....................         /* 
....................          * If there is no matching socket, There is no one to handle 
....................          * this data.  Discard it. 
....................          */ 
....................         debug_udp("INVALID-SOCKET "); 
....................         MACDiscardRx(); 
04F0C:  MOVLB  0
04F0E:  CALL   1908
....................     } 
....................     else { 
04F12:  BRA    4F64
04F14:  MOVLB  3
....................         UDPSocketInfo[s].RxCount = h.Length; 
04F16:  MOVF   x73,W
04F18:  MULLW  16
04F1A:  MOVF   FF3,W
04F1C:  CLRF   x83
04F1E:  MOVWF  x82
04F20:  MOVLW  10
04F22:  ADDWF  x82,W
04F24:  MOVWF  01
04F26:  MOVLW  00
04F28:  ADDWFC x83,W
04F2A:  MOVWF  03
04F2C:  MOVF   01,W
04F2E:  ADDLW  5B
04F30:  MOVWF  FE9
04F32:  MOVLW  00
04F34:  ADDWFC 03,W
04F36:  MOVWF  FEA
04F38:  MOVFF  370,FEC
04F3C:  MOVF   FED,F
04F3E:  MOVFF  36F,FEF
....................         UDPSocketInfo[s].Flags.bFirstRead = TRUE; 
04F42:  MOVF   x73,W
04F44:  MULLW  16
04F46:  MOVF   FF3,W
04F48:  CLRF   x83
04F4A:  MOVWF  x82
04F4C:  MOVLW  15
04F4E:  ADDWF  x82,F
04F50:  MOVLW  00
04F52:  ADDWFC x83,F
04F54:  MOVLW  5B
04F56:  ADDWF  x82,W
04F58:  MOVWF  FE9
04F5A:  MOVLW  00
04F5C:  ADDWFC x83,W
04F5E:  MOVWF  FEA
04F60:  BSF    FEF.0
04F62:  MOVLB  0
....................  
....................     debug_udp("MATCH AS:%U ", s); 
....................     /*debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          remoteNode->MACAddr.v[0], 
....................          remoteNode->MACAddr.v[1], 
....................          remoteNode->MACAddr.v[2], 
....................          remoteNode->MACAddr.v[3], 
....................          remoteNode->MACAddr.v[4], 
....................          remoteNode->MACAddr.v[5] 
....................       );*/ 
....................     } 
....................  
....................     return TRUE; 
04F64:  MOVLW  01
04F66:  MOVWF  01
.................... } 
04F68:  GOTO   894E (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, 
....................  *                                NODE_INFO *remoteNode, 
....................  *                                IP_ADDR *localIP) 
....................  * 
....................  * PreCondition:    UDP Segment header has been retrieved from buffer 
....................  *                  The IP header has also been retrieved 
....................  * 
....................  * Input:           remoteNode      - Remote node info from IP header 
....................  *                  h               - header of UDP semgent. 
....................  * 
....................  * Output:          matching UDP socket or INVALID_UDP_SOCKET 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define BROADCAST_ADDRESS   (0xffffffffL) 
.................... static UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET partialMatch; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     partialMatch = INVALID_UDP_SOCKET; 
*
04BBA:  MOVLW  FF
04BBC:  MOVLB  3
04BBE:  MOVWF  x89
....................  
....................     p = UDPSocketInfo; 
04BC0:  CLRF   x8B
04BC2:  MOVLW  5B
04BC4:  MOVWF  x8A
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
04BC6:  CLRF   x88
04BC8:  MOVF   x88,W
04BCA:  SUBLW  01
04BCC:  BTFSS  FD8.0
04BCE:  BRA    4CE2
....................     { 
....................         /* 
....................          * This packet is said to be matching with current socket 
....................          * 1. If its destination port matches with our local port. 
....................          * 2. This socket does not have any data pending. 
....................          * 3. Packet source IP address matches with socket remote IP address. 
....................          *    OR this socket had transmitted packet with destination address 
....................          *       as broadcast. 
....................          */ 
....................         if ( p->localPort == h->DestinationPort ) 
04BD0:  MOVLW  0C
04BD2:  ADDWF  x8A,W
04BD4:  MOVWF  FE9
04BD6:  MOVLW  00
04BD8:  ADDWFC x8B,W
04BDA:  MOVWF  FEA
04BDC:  MOVFF  FEC,38D
04BE0:  MOVF   FED,F
04BE2:  MOVFF  FEF,38C
04BE6:  MOVLW  02
04BE8:  ADDWF  x82,W
04BEA:  MOVWF  FE9
04BEC:  MOVLW  00
04BEE:  ADDWFC x83,W
04BF0:  MOVWF  FEA
04BF2:  MOVFF  FEC,03
04BF6:  MOVF   FED,F
04BF8:  MOVF   FEF,W
04BFA:  SUBWF  x8C,W
04BFC:  BTFSS  FD8.2
04BFE:  BRA    4CD6
04C00:  MOVF   03,W
04C02:  SUBWF  x8D,W
04C04:  BNZ   4CD6
....................         { 
....................             if ( (p->remotePort == h->SourcePort) && (p->RxCount == 0L) ) 
04C06:  MOVLW  0A
04C08:  ADDWF  x8A,W
04C0A:  MOVWF  FE9
04C0C:  MOVLW  00
04C0E:  ADDWFC x8B,W
04C10:  MOVWF  FEA
04C12:  MOVFF  FEC,38D
04C16:  MOVF   FED,F
04C18:  MOVFF  FEF,38C
04C1C:  MOVFF  382,FE9
04C20:  MOVFF  383,FEA
04C24:  MOVFF  FEC,03
04C28:  MOVF   FED,F
04C2A:  MOVF   FEF,W
04C2C:  SUBWF  x8C,W
04C2E:  BNZ   4CD2
04C30:  MOVF   03,W
04C32:  SUBWF  x8D,W
04C34:  BNZ   4CD2
04C36:  MOVLW  10
04C38:  ADDWF  x8A,W
04C3A:  MOVWF  FE9
04C3C:  MOVLW  00
04C3E:  ADDWFC x8B,W
04C40:  MOVWF  FEA
04C42:  MOVFF  FEC,38D
04C46:  MOVF   FED,F
04C48:  MOVFF  FEF,38C
04C4C:  MOVF   x8C,F
04C4E:  BNZ   4CD2
04C50:  MOVF   x8D,F
04C52:  BNZ   4CD2
....................             { 
....................                 if ( (p->remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) || 
....................                      (localIP->Val == BROADCAST_ADDRESS) ) 
04C54:  MOVLW  06
04C56:  ADDWF  x8A,W
04C58:  MOVWF  FE9
04C5A:  MOVLW  00
04C5C:  ADDWFC x8B,W
04C5E:  MOVWF  FEA
04C60:  MOVFF  FEF,38C
04C64:  MOVFF  FEC,38D
04C68:  MOVFF  FEC,38E
04C6C:  MOVFF  FEC,38F
04C70:  MOVLW  06
04C72:  ADDWF  x84,W
04C74:  MOVWF  FE9
04C76:  MOVLW  00
04C78:  ADDWFC x85,W
04C7A:  MOVWF  FEA
04C7C:  MOVFF  FEF,00
04C80:  MOVFF  FEC,01
04C84:  MOVFF  FEC,02
04C88:  MOVFF  FEC,03
04C8C:  MOVF   00,W
04C8E:  SUBWF  x8C,W
04C90:  BNZ   4CA4
04C92:  MOVF   01,W
04C94:  SUBWF  x8D,W
04C96:  BNZ   4CA4
04C98:  MOVF   02,W
04C9A:  SUBWF  x8E,W
04C9C:  BNZ   4CA4
04C9E:  MOVF   03,W
04CA0:  SUBWF  x8F,W
04CA2:  BZ    4CCC
04CA4:  MOVFF  386,FE9
04CA8:  MOVFF  387,FEA
04CAC:  MOVFF  FEF,38C
04CB0:  MOVFF  FEC,38D
04CB4:  MOVFF  FEC,38E
04CB8:  MOVFF  FEC,38F
04CBC:  INCFSZ x8C,W
04CBE:  BRA    4CD2
04CC0:  INCFSZ x8D,W
04CC2:  BRA    4CD2
04CC4:  INCFSZ x8E,W
04CC6:  BRA    4CD2
04CC8:  INCFSZ x8F,W
04CCA:  BRA    4CD2
....................                 { 
....................                     return s; 
04CCC:  MOVFF  388,01
04CD0:  BRA    4D58
....................                 } 
....................             } 
....................  
....................             partialMatch = s; 
04CD2:  MOVFF  388,389
....................         } 
....................         p++; 
04CD6:  MOVLW  16
04CD8:  ADDWF  x8A,F
04CDA:  BTFSC  FD8.0
04CDC:  INCF   x8B,F
....................     } 
04CDE:  INCF   x88,F
04CE0:  BRA    4BC8
....................  
....................     if ( partialMatch != INVALID_UDP_SOCKET ) 
04CE2:  INCFSZ x89,W
04CE4:  BRA    4CE8
04CE6:  BRA    4D54
....................     { 
....................         p = &UDPSocketInfo[partialMatch]; 
04CE8:  MOVF   x89,W
04CEA:  MULLW  16
04CEC:  MOVF   FF3,W
04CEE:  CLRF   03
04CF0:  ADDLW  5B
04CF2:  MOVWF  01
04CF4:  MOVLW  00
04CF6:  ADDWFC 03,F
04CF8:  MOVFF  01,38A
04CFC:  MOVFF  03,38B
....................  
....................         memcpy(&p->remoteNode, 
....................                 remoteNode, sizeof(NODE_INFO) ); 
04D00:  MOVFF  38B,03
04D04:  MOVFF  38A,38C
04D08:  MOVFF  38B,38D
04D0C:  MOVFF  38B,FEA
04D10:  MOVFF  38A,FE9
04D14:  MOVFF  385,FE2
04D18:  MOVFF  384,FE1
04D1C:  MOVLW  0A
04D1E:  MOVWF  01
04D20:  MOVFF  FE6,FEE
04D24:  DECFSZ 01,F
04D26:  BRA    4D20
....................  
....................         p->remotePort = h->SourcePort; 
04D28:  MOVLW  0A
04D2A:  ADDWF  x8A,W
04D2C:  MOVWF  01
04D2E:  MOVLW  00
04D30:  ADDWFC x8B,W
04D32:  MOVFF  382,FE9
04D36:  MOVFF  383,FEA
04D3A:  MOVFF  FEC,03
04D3E:  MOVF   FED,F
04D40:  MOVFF  FEF,38E
04D44:  MOVWF  FEA
04D46:  MOVFF  01,FE9
04D4A:  MOVFF  03,FEC
04D4E:  MOVF   FED,F
04D50:  MOVFF  38E,FEF
....................     } 
....................     return partialMatch; 
04D54:  MOVFF  389,01
.................... } 
04D58:  MOVLB  0
04D5A:  GOTO   4F02 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
....................  *                                               (Rev 2.11) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/14/04 DHCP will force set IP Address to 0.0.0.0 during init. 
....................  * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
....................  * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
....................  *                              where UDPPut was called before setting 
....................  *                              active socket. 
....................  * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
....................  *                              NAK and renew existing IP address. 
....................  * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
....................  *                              chaddr field before accpting the packet. 
....................  *                              Fixed DHCPTask() where it would not 
....................  *                              reply to first OFFER. 
....................  * Darren Rook (CCS)    6/28/04 CCS Port now uses 2.20 (see above) 
....................  * Darren Rook (CCS)    6/29/04 DHCPServerID, DHCPLeaseTime, tempIPAddress, 
....................  *                              tempGateway, tempMask, _DHCPReceive() 
....................  *                              and _DHCPSend() no longer static. 
....................  * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
....................  *                              state to adjust for irregular TICK_SECOND 
....................  *                              Without this logic, actual lease time count 
....................  *                              down may be incorrect. 
....................  * Darren Rook (CCS)    7/13/06 Implemented Nilesh's 03/1/04 fix 
....................  * Howard Schlunder      5/11/06   Fixed tickDiff usage, reducing 
....................  *                        accumulated timing error.  Fixed DHCP 
....................  *                        state machine requesting IP 0.0.0.0 
....................  *                        after lease expiration. 
....................  * Howard Schlunder      6/01/06   Added DHCPState.bits.bOfferReceived flag to 
....................  *                        allow operation on networks with multiple 
....................  *                        DHCP servers offering multiple addresses 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack 
....................  * Howard Schlunder      8/01/06 Added DNS server option to DHCP request,  
....................  *                        untested Host Name option to DHCP request 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_SIIP) 
....................     #error DHCP module is not available when SLIP is used. 
.................... #endif 
....................  
.................... #define debug_dhcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_dhcp debug_printf 
....................  
.................... #define DHCP_TIMEOUT                    (2 * TICKS_PER_SECOND) 
....................  
....................  
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u) 
.................... #define BOOT_REPLY                      (2u) 
.................... #define HW_TYPE                         (1u) 
.................... #define LEN_OF_HW_TYPE                  (6u) 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u) 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u) 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u) 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u) 
.................... #define DHCP_OFFER_MESSAGE              (2u) 
.................... #define DHCP_REQUEST_MESSAGE            (3u) 
.................... #define DHCP_DECLINE_MESSAGE            (4u) 
.................... #define DHCP_ACK_MESSAGE                (5u) 
.................... #define DHCP_NAK_MESSAGE                (6u) 
.................... #define DHCP_RELEASE_MESSAGE            (7u) 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u) 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u) 
....................  
.................... #define DHCP_PARAM_REQUEST_LIST         (55u) 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u) 
.................... #define DHCP_SUBNET_MASK                (1u) 
.................... #define DHCP_ROUTER                     (3u) 
.................... #define DHCP_DNS                  (6u) 
.................... #define DHCP_HOST_NAME               (12u) 
.................... #define DHCP_IP_LEASE_TIME              (51u) 
.................... #define DHCP_END_OPTION                 (255u) 
....................  
.................... #define HALF_HOUR                       (WORD)((WORD)60 * (WORD)30) 
....................  
.................... static UDP_SOCKET DHCPSocket = INVALID_UDP_SOCKET; 
....................  
.................... static DWORD_VAL DHCPServerID; 
.................... static DWORD_VAL DHCPLeaseTime; 
....................  
.................... static IP_ADDR tempIPAddress; 
.................... static IP_ADDR tempGateway; 
.................... static IP_ADDR tempMask; 
.................... #if STACK_USE_DNS 
.................... static IP_ADDR tempDNS; 
.................... #endif 
.................... //static BYTE tempHostName[16]; 
....................  
.................... static union 
.................... { 
....................    struct 
....................    { 
....................       char IPAddress:1; 
....................       char Gateway:1; 
....................       char Mask:1; 
....................       char DNS:1; 
....................       char HostName:1; 
....................    } bits; 
....................    BYTE Val; 
.................... } ValidValues; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType); 
....................  
.................... BYTE DHCPBindCount = 0; 
....................  
....................  
....................  
.................... #define USARTPut(a) 
....................  
.................... void DHCPReset(void) 
.................... { 
....................     // Do not reset DHCP if it was previously disabled. 
....................     if ( smDHCPState == SM_DHCP_DISABLED ) 
*
018DC:  MOVF   x87,W
018DE:  SUBLW  08
018E0:  BNZ   18E4
....................         return; 
018E2:  BRA    1906
....................  
....................     if ( DHCPSocket != INVALID_UDP_SOCKET ) 
018E4:  MOVLB  1
018E6:  INCFSZ x44,W
018E8:  BRA    18EC
018EA:  BRA    18F6
....................         UDPClose(DHCPSocket); 
018EC:  MOVFF  144,37E
018F0:  MOVLB  0
018F2:  RCALL  15CC
018F4:  MOVLB  1
....................  
....................     DHCPSocket = INVALID_UDP_SOCKET; 
018F6:  MOVLW  FF
018F8:  MOVWF  x44
....................  
....................     smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
018FA:  MOVLB  0
018FC:  CLRF   x87
....................     DHCPBindCount = 0; 
018FE:  MOVLB  1
01900:  CLRF   x5E
....................     DHCPState.bits.bIsBound = FALSE; 
01902:  MOVLB  0
01904:  BCF    x88.0
.................... } 
01906:  RETLW  00
....................  
.................... void DebugDHCPDisplayState(int8 st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case SM_DHCP_INIT_FIRST_TIME:   debug_dhcp("INIT_FIRST_TIME");   break; 
....................       case SM_DHCP_INIT:              debug_dhcp("INIT");   break; 
....................       case SM_DHCP_RESET_WAIT:        debug_dhcp("RESET_WAIT");   break; 
....................       case SM_DHCP_BROADCAST:         debug_dhcp("BROADCAST");   break; 
....................       case SM_DHCP_DISCOVER:          debug_dhcp("DISCOVER");   break; 
....................       case SM_DHCP_REQUEST:           debug_dhcp("REQUEST");   break; 
....................       case SM_DHCP_BIND:              debug_dhcp("BIND");   break; 
....................       case SM_DHCP_BOUND:             debug_dhcp("BOUND");   break; 
....................       case SM_DHCP_DISABLED:          debug_dhcp("DISABLED");   break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
....................    NODE_INFO DHCPServerNode; 
....................    static TICKTYPE lastTryTick; 
....................    BYTE DHCPRecvReturnValue; 
....................    TICKTYPE tickDiff; 
....................    //static int8 debugLastState; 
....................  
....................    //debugLastState = smDHCPState; 
....................  
....................     switch(smDHCPState) 
....................     { 
*
08384:  MOVF   x87,W
08386:  ADDLW  F8
08388:  BTFSC  FD8.0
0838A:  BRA    87EC
0838C:  ADDLW  08
0838E:  GOTO   87F2
....................    case SM_DHCP_INIT_FIRST_TIME: 
....................         tempIPAddress.Val = 0x0; 
08392:  MOVLB  1
08394:  CLRF   x50
08396:  CLRF   x4F
08398:  CLRF   x4E
0839A:  CLRF   x4D
0839C:  MOVLB  0
.................... //        smDHCPState = SM_DHCP_INIT;         // State automatically changes 
....................         /* No break */ 
....................  
....................     case SM_DHCP_INIT: 
....................         //debug(debug_putc,"\r\n\r\nDHCP: INIT"); 
....................  
....................         //dsr add 061404 
....................         //MY_IP=0; 
....................  
....................         DHCPServerNode.MACAddr.v[0] = 0xff; 
0839E:  MOVLW  FF
083A0:  MOVLB  3
083A2:  MOVWF  x65
....................         DHCPServerNode.MACAddr.v[1] = 0xff; 
083A4:  MOVWF  x66
....................         DHCPServerNode.MACAddr.v[2] = 0xff; 
083A6:  MOVWF  x67
....................         DHCPServerNode.MACAddr.v[3] = 0xff; 
083A8:  MOVWF  x68
....................         DHCPServerNode.MACAddr.v[4] = 0xff; 
083AA:  MOVWF  x69
....................         DHCPServerNode.MACAddr.v[5] = 0xff; 
083AC:  MOVWF  x6A
....................         DHCPServerNode.IPAddr.Val = 0xffffffff; 
083AE:  MOVWF  x6E
083B0:  MOVWF  x6D
083B2:  MOVWF  x6C
083B4:  MOVWF  x6B
....................         DHCPSocket = UDPOpen(DHCP_CLIENT_PORT, 
....................                              &DHCPServerNode, 
....................                              DHCP_SERVER_PORT); 
083B6:  CLRF   x7F
083B8:  MOVLW  44
083BA:  MOVWF  x7E
083BC:  MOVLW  03
083BE:  MOVWF  x81
083C0:  MOVLW  65
083C2:  MOVWF  x80
083C4:  CLRF   x83
083C6:  MOVLW  43
083C8:  MOVWF  x82
083CA:  MOVLB  0
083CC:  CALL   7782
083D0:  MOVFF  01,144
....................         lastTryTick = TickGet(); 
083D4:  CALL   514A
083D8:  MOVFF  02,160
083DC:  MOVFF  01,15F
....................         smDHCPState = SM_DHCP_RESET_WAIT; 
083E0:  MOVLW  02
083E2:  MOVWF  x87
....................         /* No break */ 
....................  
....................     case SM_DHCP_RESET_WAIT: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= (TICKS_PER_SECOND/5) ) 
083E4:  CALL   514A
083E8:  MOVFF  02,373
083EC:  MOVFF  01,372
083F0:  MOVLB  3
083F2:  MOVF   02,W
083F4:  MOVLB  1
083F6:  SUBWF  x60,W
083F8:  BNC   840C
083FA:  BNZ   8410
083FC:  MOVF   x5F,W
083FE:  MOVLB  3
08400:  SUBWF  x72,W
08402:  BTFSC  FD8.0
08404:  BRA    840A
08406:  MOVLB  1
08408:  BRA    8410
0840A:  MOVLB  1
0840C:  MOVLW  00
0840E:  BRA    8412
08410:  MOVLW  01
08412:  CLRF   03
08414:  IORWF  03,W
08416:  BZ    844C
08418:  MOVLW  FF
0841A:  BSF    FD8.0
0841C:  SUBFWB x5F,W
0841E:  MOVLB  3
08420:  MOVWF  x72
08422:  MOVLW  FF
08424:  MOVLB  1
08426:  SUBFWB x60,W
08428:  MOVLB  3
0842A:  MOVWF  x73
0842C:  MOVLB  0
0842E:  CALL   514A
08432:  MOVF   01,W
08434:  MOVLB  3
08436:  ADDWF  x72,F
08438:  MOVF   02,W
0843A:  ADDWFC x73,F
0843C:  MOVLW  01
0843E:  ADDWF  x72,W
08440:  MOVWF  01
08442:  MOVLW  00
08444:  ADDWFC x73,W
08446:  MOVWF  03
08448:  MOVF   01,W
0844A:  BRA    8470
0844C:  MOVLB  0
0844E:  CALL   514A
08452:  MOVFF  02,373
08456:  MOVFF  01,372
0845A:  MOVLB  1
0845C:  MOVF   x5F,W
0845E:  MOVLB  3
08460:  SUBWF  01,W
08462:  MOVWF  00
08464:  MOVLB  1
08466:  MOVF   x60,W
08468:  MOVLB  3
0846A:  SUBWFB 02,W
0846C:  MOVWF  03
0846E:  MOVF   00,W
08470:  SUBLW  01
08472:  BC    847A
....................             //debug(debug_putc,"\r\n\r\nDHCP: RESET_WAIT"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
08474:  MOVLW  03
08476:  MOVLB  0
08478:  MOVWF  x87
....................         break; 
0847A:  MOVLB  0
0847C:  BRA    87EC
....................  
....................     case SM_DHCP_BROADCAST: 
....................        // Assume default IP Lease time of 60 seconds. 
....................        // This should be minimum possible to make sure that if 
....................        // server did not specify lease time, we try again after this minimum time. 
....................        DHCPLeaseTime.Val = 60; 
0847E:  MOVLB  1
08480:  CLRF   x4C
08482:  CLRF   x4B
08484:  CLRF   x4A
08486:  MOVLW  3C
08488:  MOVWF  x49
....................  
....................         // If we have already obtained some IP address, renew it. 
....................         if(DHCPState.bits.bIsBound) 
0848A:  MOVLB  0
0848C:  BTFSS  x88.0
0848E:  BRA    8496
....................         { 
....................             smDHCPState = SM_DHCP_REQUEST; 
08490:  MOVLW  05
08492:  MOVWF  x87
....................         } 
....................         else if ( UDPIsPutReady(DHCPSocket) ) 
08494:  BRA    84C4
08496:  MOVFF  144,37E
0849A:  CALL   7848
0849E:  MOVF   01,F
084A0:  BZ    84C4
....................         { 
....................             // To minimize code requirement, user must make sure that 
....................             // above call will be successful by making at least one 
....................             // UDP socket available. 
....................             // Usually this will be the case, given that DHCP will be 
....................             // the first one to use UDP socket. 
....................             // Also, we will not check for transmitter readiness, 
....................             // we assume it to be ready. 
....................             _DHCPSend(DHCP_DISCOVER_MESSAGE); 
084A2:  MOVLW  01
084A4:  MOVLB  3
084A6:  MOVWF  x72
084A8:  MOVLB  0
084AA:  CALL   7AF0
....................          ValidValues.Val = 0x00; 
084AE:  MOVLB  1
084B0:  CLRF   x5D
....................  
....................             lastTryTick = TickGet(); 
084B2:  MOVLB  0
084B4:  CALL   514A
084B8:  MOVFF  02,160
084BC:  MOVFF  01,15F
....................             smDHCPState = SM_DHCP_DISCOVER; 
084C0:  MOVLW  04
084C2:  MOVWF  x87
....................         } 
....................  
....................         break; 
084C4:  BRA    87EC
....................  
....................  
....................     case SM_DHCP_DISCOVER: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
084C6:  CALL   514A
084CA:  MOVFF  02,373
084CE:  MOVFF  01,372
084D2:  MOVLB  3
084D4:  MOVF   02,W
084D6:  MOVLB  1
084D8:  SUBWF  x60,W
084DA:  BNC   84EE
084DC:  BNZ   84F2
084DE:  MOVF   x5F,W
084E0:  MOVLB  3
084E2:  SUBWF  x72,W
084E4:  BTFSC  FD8.0
084E6:  BRA    84EC
084E8:  MOVLB  1
084EA:  BRA    84F2
084EC:  MOVLB  1
084EE:  MOVLW  00
084F0:  BRA    84F4
084F2:  MOVLW  01
084F4:  CLRF   03
084F6:  IORWF  03,W
084F8:  BZ    852E
084FA:  MOVLW  FF
084FC:  BSF    FD8.0
084FE:  SUBFWB x5F,W
08500:  MOVLB  3
08502:  MOVWF  x72
08504:  MOVLW  FF
08506:  MOVLB  1
08508:  SUBFWB x60,W
0850A:  MOVLB  3
0850C:  MOVWF  x73
0850E:  MOVLB  0
08510:  CALL   514A
08514:  MOVF   01,W
08516:  MOVLB  3
08518:  ADDWF  x72,F
0851A:  MOVF   02,W
0851C:  ADDWFC x73,F
0851E:  MOVLW  01
08520:  ADDWF  x72,W
08522:  MOVWF  01
08524:  MOVLW  00
08526:  ADDWFC x73,W
08528:  MOVWF  03
0852A:  MOVF   01,W
0852C:  BRA    8552
0852E:  MOVLB  0
08530:  CALL   514A
08534:  MOVFF  02,373
08538:  MOVFF  01,372
0853C:  MOVLB  1
0853E:  MOVF   x5F,W
08540:  MOVLB  3
08542:  SUBWF  01,W
08544:  MOVWF  00
08546:  MOVLB  1
08548:  MOVF   x60,W
0854A:  MOVLB  3
0854C:  SUBWFB 02,W
0854E:  MOVWF  03
08550:  MOVF   00,W
08552:  SUBLW  13
08554:  BC    855C
....................       { 
....................             //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER TO BROADCAST"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
08556:  MOVLW  03
08558:  MOVLB  0
0855A:  MOVWF  x87
....................             //return; 
....................         } 
....................  
....................         if ( UDPIsGetReady(DHCPSocket) ) 
0855C:  MOVFF  144,37E
08560:  MOVLB  0
08562:  CALL   7CE4
08566:  MOVF   01,F
08568:  BZ    857C
....................         { 
....................  
....................             if ( _DHCPReceive() == DHCP_OFFER_MESSAGE ) 
0856A:  RCALL  7EA4
0856C:  MOVF   01,W
0856E:  SUBLW  02
08570:  BNZ   8578
....................             { 
....................                 //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER BACK TO REQUEST"); 
....................                 smDHCPState = SM_DHCP_REQUEST; 
08572:  MOVLW  05
08574:  MOVWF  x87
....................             } 
....................             else 
08576:  BRA    857A
....................                break; 
08578:  BRA    87EC
....................         } 
....................         else 
0857A:  BRA    857E
....................            break; 
0857C:  BRA    87EC
....................  
....................  
....................     case SM_DHCP_REQUEST: 
....................         if ( UDPIsPutReady(DHCPSocket) ) 
0857E:  MOVFF  144,37E
08582:  CALL   7848
08586:  MOVF   01,F
08588:  BZ    85A6
....................         { 
....................             _DHCPSend(DHCP_REQUEST_MESSAGE); 
0858A:  MOVLW  03
0858C:  MOVLB  3
0858E:  MOVWF  x72
08590:  MOVLB  0
08592:  CALL   7AF0
....................             lastTryTick = TickGet(); 
08596:  CALL   514A
0859A:  MOVFF  02,160
0859E:  MOVFF  01,15F
....................             smDHCPState = SM_DHCP_BIND; 
085A2:  MOVLW  06
085A4:  MOVWF  x87
....................             //debug(debug_putc,"\r\n\r\nDHCP: REQUEST TO BIND"); 
....................         } 
....................         break; 
085A6:  BRA    87EC
....................  
....................     case SM_DHCP_BIND: 
....................         if ( UDPIsGetReady(DHCPSocket) ) 
085A8:  MOVFF  144,37E
085AC:  CALL   7CE4
085B0:  MOVF   01,F
085B2:  BZ    865A
....................         { 
....................             DHCPRecvReturnValue = _DHCPReceive(); 
085B4:  RCALL  7EA4
085B6:  MOVFF  01,36F
....................             if ( DHCPRecvReturnValue == DHCP_NAK_MESSAGE ) 
085BA:  MOVLB  3
085BC:  MOVF   x6F,W
085BE:  SUBLW  06
085C0:  BNZ   85CE
....................             { 
....................                // (RSS) NAK recieved.  DHCP server didn't like our DHCP Request format 
....................             DHCPReset();                  // Start all over again 
085C2:  MOVLB  0
085C4:  CALL   18DC
....................             return; 
085C8:  BRA    87EC
....................             } 
....................             else if ( DHCPRecvReturnValue == DHCP_ACK_MESSAGE ) 
085CA:  BRA    8654
085CC:  MOVLB  3
085CE:  MOVF   x6F,W
085D0:  SUBLW  05
085D2:  BNZ   8656
....................             { 
....................                 // Once DCHP is successful, release the UDP socket 
....................                 // This will ensure that UDP layer discards any further DHCP related packets. 
....................                 UDPClose(DHCPSocket); 
085D4:  MOVFF  144,37E
085D8:  MOVLB  0
085DA:  CALL   15CC
....................                 DHCPSocket = INVALID_UDP_SOCKET; 
085DE:  MOVLW  FF
085E0:  MOVLB  1
085E2:  MOVWF  x44
....................  
....................                 lastTryTick = TickGet(); 
085E4:  MOVLB  0
085E6:  CALL   514A
085EA:  MOVFF  02,160
085EE:  MOVFF  01,15F
....................                 smDHCPState = SM_DHCP_BOUND; 
085F2:  MOVLW  07
085F4:  MOVWF  x87
....................  
....................             if(ValidValues.bits.IPAddress) 
085F6:  MOVLB  1
085F8:  BTFSS  x5D.0
085FA:  BRA    860C
....................                    AppConfig.MyIPAddr = tempIPAddress; 
085FC:  MOVFF  150,1B
08600:  MOVFF  14F,1A
08604:  MOVFF  14E,19
08608:  MOVFF  14D,18
....................             if(ValidValues.bits.Mask) 
0860C:  BTFSS  x5D.2
0860E:  BRA    8620
....................                AppConfig.MyMask = tempMask; 
08610:  MOVFF  158,25
08614:  MOVFF  157,24
08618:  MOVFF  156,23
0861C:  MOVFF  155,22
....................             if(ValidValues.bits.Gateway) 
08620:  BTFSS  x5D.1
08622:  BRA    8634
....................                AppConfig.MyGateway = tempGateway; 
08624:  MOVFF  154,29
08628:  MOVFF  153,28
0862C:  MOVFF  152,27
08630:  MOVFF  151,26
....................          #if STACK_USE_DNS 
....................             if(ValidValues.bits.DNS) 
08634:  BTFSS  x5D.3
08636:  BRA    8648
....................                AppConfig.PrimaryDNSServer = tempDNS; 
08638:  MOVFF  15C,2D
0863C:  MOVFF  15B,2C
08640:  MOVFF  15A,2B
08644:  MOVFF  159,2A
....................          #endif 
.................... //            if(ValidValues.bits.HostName) 
.................... //               memcpy(AppConfig.NetBIOSName, (void*)tempHostName, sizeof(AppConfig.NetBIOSName)); 
....................  
....................                 DHCPState.bits.bIsBound = TRUE; 
08648:  MOVLB  0
0864A:  BSF    x88.0
....................  
....................                 DHCPBindCount++; 
0864C:  MOVLB  1
0864E:  INCF   x5E,F
....................  
....................                 return; 
08650:  MOVLB  0
08652:  BRA    87EC
08654:  MOVLB  3
....................             } 
....................         } 
....................         else if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
08656:  BRA    86F0
08658:  MOVLB  0
0865A:  CALL   514A
0865E:  MOVFF  02,373
08662:  MOVFF  01,372
08666:  MOVLB  3
08668:  MOVF   02,W
0866A:  MOVLB  1
0866C:  SUBWF  x60,W
0866E:  BNC   8682
08670:  BNZ   8686
08672:  MOVF   x5F,W
08674:  MOVLB  3
08676:  SUBWF  x72,W
08678:  BTFSC  FD8.0
0867A:  BRA    8680
0867C:  MOVLB  1
0867E:  BRA    8686
08680:  MOVLB  1
08682:  MOVLW  00
08684:  BRA    8688
08686:  MOVLW  01
08688:  CLRF   03
0868A:  IORWF  03,W
0868C:  BZ    86C2
0868E:  MOVLW  FF
08690:  BSF    FD8.0
08692:  SUBFWB x5F,W
08694:  MOVLB  3
08696:  MOVWF  x72
08698:  MOVLW  FF
0869A:  MOVLB  1
0869C:  SUBFWB x60,W
0869E:  MOVLB  3
086A0:  MOVWF  x73
086A2:  MOVLB  0
086A4:  CALL   514A
086A8:  MOVF   01,W
086AA:  MOVLB  3
086AC:  ADDWF  x72,F
086AE:  MOVF   02,W
086B0:  ADDWFC x73,F
086B2:  MOVLW  01
086B4:  ADDWF  x72,W
086B6:  MOVWF  01
086B8:  MOVLW  00
086BA:  ADDWFC x73,W
086BC:  MOVWF  03
086BE:  MOVF   01,W
086C0:  BRA    86E6
086C2:  MOVLB  0
086C4:  CALL   514A
086C8:  MOVFF  02,373
086CC:  MOVFF  01,372
086D0:  MOVLB  1
086D2:  MOVF   x5F,W
086D4:  MOVLB  3
086D6:  SUBWF  01,W
086D8:  MOVWF  00
086DA:  MOVLB  1
086DC:  MOVF   x60,W
086DE:  MOVLB  3
086E0:  SUBWFB 02,W
086E2:  MOVWF  03
086E4:  MOVF   00,W
086E6:  SUBLW  13
086E8:  BC    86F0
....................             smDHCPState = SM_DHCP_BROADCAST; 
086EA:  MOVLW  03
086EC:  MOVLB  0
086EE:  MOVWF  x87
....................         break; 
086F0:  MOVLB  0
086F2:  BRA    87EC
....................  
....................     case SM_DHCP_BOUND: 
....................         // Keep track of how long we use this IP configuration. 
....................         // When lease period expires, renew the configuration. 
....................         tickDiff = TickGetDiff(TickGet(), lastTryTick); 
086F4:  CALL   514A
086F8:  MOVFF  02,373
086FC:  MOVFF  01,372
08700:  MOVLB  3
08702:  MOVF   02,W
08704:  MOVLB  1
08706:  SUBWF  x60,W
08708:  BNC   871C
0870A:  BNZ   8720
0870C:  MOVF   x5F,W
0870E:  MOVLB  3
08710:  SUBWF  x72,W
08712:  BTFSC  FD8.0
08714:  BRA    871A
08716:  MOVLB  1
08718:  BRA    8720
0871A:  MOVLB  1
0871C:  MOVLW  00
0871E:  BRA    8722
08720:  MOVLW  01
08722:  CLRF   03
08724:  IORWF  03,W
08726:  BZ    875C
08728:  MOVLW  FF
0872A:  BSF    FD8.0
0872C:  SUBFWB x5F,W
0872E:  MOVLB  3
08730:  MOVWF  x72
08732:  MOVLW  FF
08734:  MOVLB  1
08736:  SUBFWB x60,W
08738:  MOVLB  3
0873A:  MOVWF  x73
0873C:  MOVLB  0
0873E:  CALL   514A
08742:  MOVF   01,W
08744:  MOVLB  3
08746:  ADDWF  x72,F
08748:  MOVF   02,W
0874A:  ADDWFC x73,F
0874C:  MOVLW  01
0874E:  ADDWF  x72,W
08750:  MOVWF  01
08752:  MOVLW  00
08754:  ADDWFC x73,W
08756:  MOVWF  03
08758:  MOVF   01,W
0875A:  BRA    8780
0875C:  MOVLB  0
0875E:  CALL   514A
08762:  MOVFF  02,373
08766:  MOVFF  01,372
0876A:  MOVLB  1
0876C:  MOVF   x5F,W
0876E:  MOVLB  3
08770:  SUBWF  01,W
08772:  MOVWF  00
08774:  MOVLB  1
08776:  MOVF   x60,W
08778:  MOVLB  3
0877A:  SUBWFB 02,W
0877C:  MOVWF  03
0877E:  MOVF   00,W
08780:  MOVWF  x70
08782:  MOVFF  03,371
....................  
....................         if(tickDiff >= TICKS_PER_SECOND) 
08786:  MOVF   x71,F
08788:  BNZ   8790
0878A:  MOVF   x70,W
0878C:  SUBLW  09
0878E:  BC    87EC
....................         { 
....................          do 
....................          { 
....................                DHCPLeaseTime.Val--; 
08790:  MOVLW  FF
08792:  MOVLB  1
08794:  ADDWF  x49,F
08796:  BTFSS  FD8.0
08798:  ADDWF  x4A,F
0879A:  BTFSS  FD8.0
0879C:  ADDWF  x4B,F
0879E:  BTFSS  FD8.0
087A0:  ADDWF  x4C,F
....................             tickDiff -= TICKS_PER_SECOND; 
087A2:  MOVLW  0A
087A4:  MOVLB  3
087A6:  SUBWF  x70,F
087A8:  MOVLW  00
087AA:  SUBWFB x71,F
....................                if(DHCPLeaseTime.Val == 0u) 
087AC:  MOVLB  1
087AE:  MOVF   x49,F
087B0:  BNZ   87C4
087B2:  MOVF   x4A,F
087B4:  BNZ   87C4
087B6:  MOVF   x4B,F
087B8:  BNZ   87C4
087BA:  MOVF   x4C,F
087BC:  BNZ   87C4
....................                   smDHCPState = SM_DHCP_INIT; 
087BE:  MOVLW  01
087C0:  MOVLB  0
087C2:  MOVWF  x87
....................          } while(tickDiff >= TICKS_PER_SECOND); 
087C4:  MOVLB  3
087C6:  MOVF   x71,F
087C8:  BNZ   8790
087CA:  MOVF   x70,W
087CC:  SUBLW  09
087CE:  BNC   8790
....................             lastTryTick = TickGet() - tickDiff; 
087D0:  MOVLB  0
087D2:  CALL   514A
087D6:  MOVLB  3
087D8:  MOVF   x70,W
087DA:  SUBWF  01,W
087DC:  MOVLB  1
087DE:  MOVWF  x5F
087E0:  MOVLB  3
087E2:  MOVF   x71,W
087E4:  SUBWFB 02,W
087E6:  MOVLB  1
087E8:  MOVWF  x60
087EA:  MOVLB  3
087EC:  MOVLB  0
....................         } 
....................     } 
....................  
....................    /*if (debugLastState != smDHCPState) 
....................    { 
....................       debug_dhcp("\r\nDHCP TASK - ", ); 
....................       DebugDHCPDisplayState(debugLastState); 
....................       debug_dhcp(" -> "); 
....................       DebugDHCPDisplayState(smDHCPState); 
....................    }*/ 
.................... } 
087EE:  GOTO   8A44 (RETURN)
....................  
.................... /********************************************************************* 
....................         DHCP PACKET FORMAT AS PER RFC 1541 
....................  
....................    0                   1                   2                   3 
....................    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
....................    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
....................    |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
....................    +---------------+---------------+---------------+---------------+ 
....................    |                            xid (4)                            | 
....................    +-------------------------------+-------------------------------+ 
....................    |           secs (2)            |           flags (2)           | 
....................    +-------------------------------+-------------------------------+ 
....................    |                          ciaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          yiaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          siaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          giaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          chaddr  (16)                         | 
....................    |                                                               | 
....................    |                                                               | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          sname   (64)                         | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          file    (128)                        | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          options (312)                        | 
....................    +---------------------------------------------------------------+ 
....................  
....................  ********************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
....................     BYTE v; 
....................     BYTE i, j; 
....................     BYTE type; 
....................     BOOL lbDone; 
....................     DWORD_VAL tempServerID; 
....................  
....................  
....................     // Assume unknown message until proven otherwise. 
....................     type = DHCP_UNKNOWN_MESSAGE; 
*
07EA4:  MOVLB  3
07EA6:  CLRF   x75
....................  
....................     UDPGet(&v);                             // op 
07EA8:  MOVLW  03
07EAA:  MOVWF  x83
07EAC:  MOVLW  72
07EAE:  MOVWF  x82
07EB0:  MOVLB  0
07EB2:  RCALL  7D2A
....................  
....................     //Make sure this is BOOT_REPLY. 
....................     if ( v == BOOT_REPLY ) 
07EB4:  MOVLB  3
07EB6:  MOVF   x72,W
07EB8:  SUBLW  02
07EBA:  BTFSS  FD8.2
07EBC:  BRA    8320
....................     { 
....................         //Discard htype, hlen, hops, xid, secs, flags, ciaddr. 
....................         for ( i = 0; i < 15u; i++ ) 
07EBE:  CLRF   x73
07EC0:  MOVF   x73,W
07EC2:  SUBLW  0E
07EC4:  BNC   7ED8
....................             UDPGet(&v); 
07EC6:  MOVLW  03
07EC8:  MOVWF  x83
07ECA:  MOVLW  72
07ECC:  MOVWF  x82
07ECE:  MOVLB  0
07ED0:  RCALL  7D2A
07ED2:  MOVLB  3
07ED4:  INCF   x73,F
07ED6:  BRA    7EC0
....................  
....................       // Check to see if this is the first offer 
....................       if(DHCPState.bits.bOfferReceived) 
07ED8:  MOVLB  0
07EDA:  BTFSS  x88.1
07EDC:  BRA    7EFE
....................       { 
....................            // Discard offered IP address, we already have an offer 
....................            for ( i = 0; i < 4u; i++ ) 
07EDE:  MOVLB  3
07EE0:  CLRF   x73
07EE2:  MOVF   x73,W
07EE4:  SUBLW  03
07EE6:  BNC   7EFA
....................                UDPGet(&v); 
07EE8:  MOVLW  03
07EEA:  MOVWF  x83
07EEC:  MOVLW  72
07EEE:  MOVWF  x82
07EF0:  MOVLB  0
07EF2:  RCALL  7D2A
07EF4:  MOVLB  3
07EF6:  INCF   x73,F
07EF8:  BRA    7EE2
....................       } 
....................       else 
07EFA:  BRA    7F3C
07EFC:  MOVLB  0
....................       { 
....................            // Save offered IP address until we know for sure that we have it. 
....................            UDPGet(&tempIPAddress.v[0]); 
07EFE:  MOVLW  01
07F00:  MOVLB  3
07F02:  MOVWF  x83
07F04:  MOVLW  4D
07F06:  MOVWF  x82
07F08:  MOVLB  0
07F0A:  RCALL  7D2A
....................            UDPGet(&tempIPAddress.v[1]); 
07F0C:  MOVLW  01
07F0E:  MOVLB  3
07F10:  MOVWF  x83
07F12:  MOVLW  4E
07F14:  MOVWF  x82
07F16:  MOVLB  0
07F18:  RCALL  7D2A
....................            UDPGet(&tempIPAddress.v[2]); 
07F1A:  MOVLW  01
07F1C:  MOVLB  3
07F1E:  MOVWF  x83
07F20:  MOVLW  4F
07F22:  MOVWF  x82
07F24:  MOVLB  0
07F26:  RCALL  7D2A
....................            UDPGet(&tempIPAddress.v[3]); 
07F28:  MOVLW  01
07F2A:  MOVLB  3
07F2C:  MOVWF  x83
07F2E:  MOVLW  50
07F30:  MOVWF  x82
07F32:  MOVLB  0
07F34:  RCALL  7D2A
....................          ValidValues.bits.IPAddress = 1; 
07F36:  MOVLB  1
07F38:  BSF    x5D.0
07F3A:  MOVLB  3
....................       } 
....................  
....................         //Ignore siaddr, giaddr 
....................         for ( i = 0; i < 8u; i++ ) 
07F3C:  CLRF   x73
07F3E:  MOVF   x73,W
07F40:  SUBLW  07
07F42:  BNC   7F56
....................             UDPGet(&v); 
07F44:  MOVLW  03
07F46:  MOVWF  x83
07F48:  MOVLW  72
07F4A:  MOVWF  x82
07F4C:  MOVLB  0
07F4E:  RCALL  7D2A
07F50:  MOVLB  3
07F52:  INCF   x73,F
07F54:  BRA    7F3E
....................  
....................         //Check to see if chaddr (Client Hardware Address) belongs to us. 
....................         for ( i = 0; i < 6u; i++ ) 
07F56:  CLRF   x73
07F58:  MOVF   x73,W
07F5A:  SUBLW  05
07F5C:  BNC   7F90
....................         { 
....................             UDPGet(&v); 
07F5E:  MOVLW  03
07F60:  MOVWF  x83
07F62:  MOVLW  72
07F64:  MOVWF  x82
07F66:  MOVLB  0
07F68:  RCALL  7D2A
....................             if ( v != AppConfig.MyMACAddr.v[i]) 
07F6A:  CLRF   03
07F6C:  MOVLB  3
07F6E:  MOVF   x73,W
07F70:  ADDLW  04
07F72:  MOVWF  01
07F74:  MOVLW  00
07F76:  ADDWFC 03,F
07F78:  MOVF   01,W
07F7A:  ADDLW  18
07F7C:  MOVWF  FE9
07F7E:  MOVLW  00
07F80:  ADDWFC 03,W
07F82:  MOVWF  FEA
07F84:  MOVF   FEF,W
07F86:  SUBWF  x72,W
07F88:  BZ    7F8C
....................                 goto UDPInvalid; 
07F8A:  BRA    8376
....................         } 
07F8C:  INCF   x73,F
07F8E:  BRA    7F58
....................  
....................         //Ignore part of chaddr, sname, file, magic cookie. 
....................         for ( i = 0; i < 206u; i++ ) 
07F90:  CLRF   x73
07F92:  MOVF   x73,W
07F94:  SUBLW  CD
07F96:  BNC   7FAA
....................             UDPGet(&v); 
07F98:  MOVLW  03
07F9A:  MOVWF  x83
07F9C:  MOVLW  72
07F9E:  MOVWF  x82
07FA0:  MOVLB  0
07FA2:  RCALL  7D2A
07FA4:  MOVLB  3
07FA6:  INCF   x73,F
07FA8:  BRA    7F92
....................  
....................         lbDone = FALSE; 
07FAA:  BCF    x76.0
....................         do 
....................         { 
....................          // Get the Option number 
....................          // Break out eventually in case if this is a malformed 
....................          // DHCP message, ie: missing DHCP_END_OPTION marker 
....................          if(!UDPGet(&v)) 
07FAC:  MOVLW  03
07FAE:  MOVWF  x83
07FB0:  MOVLW  72
07FB2:  MOVWF  x82
07FB4:  MOVLB  0
07FB6:  RCALL  7D2A
07FB8:  MOVF   01,F
07FBA:  BNZ   7FC4
....................          { 
....................             lbDone = TRUE; 
07FBC:  MOVLB  3
07FBE:  BSF    x76.0
....................             break; 
07FC0:  BRA    8320
07FC2:  MOVLB  0
....................          } 
....................  
....................             switch(v) 
....................             { 
07FC4:  MOVLB  3
07FC6:  MOVF   x72,W
07FC8:  XORLW  35
07FCA:  MOVLB  0
07FCC:  BZ    7FF2
07FCE:  XORLW  34
07FD0:  BZ    8032
07FD2:  XORLW  02
07FD4:  BTFSC  FD8.2
07FD6:  BRA    80B4
07FD8:  XORLW  05
07FDA:  BTFSC  FD8.2
07FDC:  BRA    8152
07FDE:  XORLW  30
07FE0:  BTFSC  FD8.2
07FE2:  BRA    81F0
07FE4:  XORLW  C9
07FE6:  BTFSC  FD8.2
07FE8:  BRA    8246
07FEA:  XORLW  CC
07FEC:  BTFSC  FD8.2
07FEE:  BRA    824E
07FF0:  BRA    82F4
....................             case DHCP_MESSAGE_TYPE: 
....................                 UDPGet(&v);                         // Skip len 
07FF2:  MOVLW  03
07FF4:  MOVLB  3
07FF6:  MOVWF  x83
07FF8:  MOVLW  72
07FFA:  MOVWF  x82
07FFC:  MOVLB  0
07FFE:  RCALL  7D2A
....................                 // Len must be 1. 
....................                 if ( v == 1u ) 
08000:  MOVLB  3
08002:  DECFSZ x72,W
08004:  BRA    802C
....................                 { 
....................                     UDPGet(&type);                  // Get type 
08006:  MOVLW  03
08008:  MOVWF  x83
0800A:  MOVLW  75
0800C:  MOVWF  x82
0800E:  MOVLB  0
08010:  RCALL  7D2A
....................  
....................                // Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
....................                if(DHCPState.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
08012:  BTFSS  x88.1
08014:  BRA    8028
08016:  MOVLB  3
08018:  MOVF   x75,W
0801A:  SUBLW  02
0801C:  BTFSC  FD8.2
0801E:  BRA    8024
08020:  MOVLB  0
08022:  BRA    8028
....................                { 
....................                   goto UDPInvalid; 
08024:  BRA    8376
08026:  MOVLB  0
....................                } 
....................             } 
....................                 else 
08028:  BRA    8030
0802A:  MOVLB  3
....................                     goto UDPInvalid; 
0802C:  BRA    8376
0802E:  MOVLB  0
....................                 break; 
08030:  BRA    831A
....................  
....................             case DHCP_SUBNET_MASK: 
....................                 UDPGet(&v);                     // Skip len 
08032:  MOVLW  03
08034:  MOVLB  3
08036:  MOVWF  x83
08038:  MOVLW  72
0803A:  MOVWF  x82
0803C:  MOVLB  0
0803E:  RCALL  7D2A
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
08040:  MOVLB  3
08042:  MOVF   x72,W
08044:  SUBLW  04
08046:  BNZ   80AE
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
08048:  MOVLB  0
0804A:  BTFSS  x88.1
0804C:  BRA    806E
....................                { 
....................                     // Discard offered IP mask, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
0804E:  MOVLB  3
08050:  CLRF   x73
08052:  MOVF   x73,W
08054:  SUBLW  03
08056:  BNC   806A
....................                         UDPGet(&v); 
08058:  MOVLW  03
0805A:  MOVWF  x83
0805C:  MOVLW  72
0805E:  MOVWF  x82
08060:  MOVLB  0
08062:  RCALL  7D2A
08064:  MOVLB  3
08066:  INCF   x73,F
08068:  BRA    8052
....................                } 
....................                else 
0806A:  BRA    80AC
0806C:  MOVLB  0
....................                { 
....................                        UDPGet(&tempMask.v[0]); 
0806E:  MOVLW  01
08070:  MOVLB  3
08072:  MOVWF  x83
08074:  MOVLW  55
08076:  MOVWF  x82
08078:  MOVLB  0
0807A:  RCALL  7D2A
....................                        UDPGet(&tempMask.v[1]); 
0807C:  MOVLW  01
0807E:  MOVLB  3
08080:  MOVWF  x83
08082:  MOVLW  56
08084:  MOVWF  x82
08086:  MOVLB  0
08088:  RCALL  7D2A
....................                        UDPGet(&tempMask.v[2]); 
0808A:  MOVLW  01
0808C:  MOVLB  3
0808E:  MOVWF  x83
08090:  MOVLW  57
08092:  MOVWF  x82
08094:  MOVLB  0
08096:  RCALL  7D2A
....................                        UDPGet(&tempMask.v[3]); 
08098:  MOVLW  01
0809A:  MOVLB  3
0809C:  MOVWF  x83
0809E:  MOVLW  58
080A0:  MOVWF  x82
080A2:  MOVLB  0
080A4:  RCALL  7D2A
....................                   ValidValues.bits.Mask = 1; 
080A6:  MOVLB  1
080A8:  BSF    x5D.2
080AA:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
080AC:  BRA    80B0
....................                     goto UDPInvalid; 
080AE:  BRA    8376
....................                 break; 
080B0:  MOVLB  0
080B2:  BRA    831A
....................  
....................             case DHCP_ROUTER: 
....................                 UDPGet(&j); 
080B4:  MOVLW  03
080B6:  MOVLB  3
080B8:  MOVWF  x83
080BA:  MOVLW  74
080BC:  MOVWF  x82
080BE:  MOVLB  0
080C0:  RCALL  7D2A
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
080C2:  MOVLB  3
080C4:  MOVF   x74,W
080C6:  SUBLW  03
080C8:  BC    8130
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
080CA:  MOVLB  0
080CC:  BTFSS  x88.1
080CE:  BRA    80F0
....................                { 
....................                     // Discard offered Gateway address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
080D0:  MOVLB  3
080D2:  CLRF   x73
080D4:  MOVF   x73,W
080D6:  SUBLW  03
080D8:  BNC   80EC
....................                         UDPGet(&v); 
080DA:  MOVLW  03
080DC:  MOVWF  x83
080DE:  MOVLW  72
080E0:  MOVWF  x82
080E2:  MOVLB  0
080E4:  RCALL  7D2A
080E6:  MOVLB  3
080E8:  INCF   x73,F
080EA:  BRA    80D4
....................                } 
....................                else 
080EC:  BRA    812E
080EE:  MOVLB  0
....................                { 
....................                        UDPGet(&tempGateway.v[0]); 
080F0:  MOVLW  01
080F2:  MOVLB  3
080F4:  MOVWF  x83
080F6:  MOVLW  51
080F8:  MOVWF  x82
080FA:  MOVLB  0
080FC:  RCALL  7D2A
....................                        UDPGet(&tempGateway.v[1]); 
080FE:  MOVLW  01
08100:  MOVLB  3
08102:  MOVWF  x83
08104:  MOVLW  52
08106:  MOVWF  x82
08108:  MOVLB  0
0810A:  RCALL  7D2A
....................                        UDPGet(&tempGateway.v[2]); 
0810C:  MOVLW  01
0810E:  MOVLB  3
08110:  MOVWF  x83
08112:  MOVLW  53
08114:  MOVWF  x82
08116:  MOVLB  0
08118:  RCALL  7D2A
....................                        UDPGet(&tempGateway.v[3]); 
0811A:  MOVLW  01
0811C:  MOVLB  3
0811E:  MOVWF  x83
08120:  MOVLW  54
08122:  MOVWF  x82
08124:  MOVLB  0
08126:  RCALL  7D2A
....................                   ValidValues.bits.Gateway = 1; 
08128:  MOVLB  1
0812A:  BSF    x5D.1
0812C:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
0812E:  BRA    8132
....................                     goto UDPInvalid; 
08130:  BRA    8376
....................  
....................                 // Discard any other router addresses. 
....................                 j -= 4; 
08132:  MOVLW  04
08134:  SUBWF  x74,F
....................                 while(j--) 
....................                     UDPGet(&v); 
08136:  MOVF   x74,W
08138:  DECF   x74,F
0813A:  XORLW  00
0813C:  BZ    814E
0813E:  MOVLW  03
08140:  MOVWF  x83
08142:  MOVLW  72
08144:  MOVWF  x82
08146:  MOVLB  0
08148:  RCALL  7D2A
0814A:  MOVLB  3
0814C:  BRA    8136
....................                 break; 
0814E:  MOVLB  0
08150:  BRA    831A
....................  
.................... #if STACK_USE_DNS 
....................             case DHCP_DNS: 
....................                 UDPGet(&j); 
08152:  MOVLW  03
08154:  MOVLB  3
08156:  MOVWF  x83
08158:  MOVLW  74
0815A:  MOVWF  x82
0815C:  MOVLB  0
0815E:  RCALL  7D2A
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
08160:  MOVLB  3
08162:  MOVF   x74,W
08164:  SUBLW  03
08166:  BC    81CE
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
08168:  MOVLB  0
0816A:  BTFSS  x88.1
0816C:  BRA    818E
....................                { 
....................                     // Discard offered DNS server address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
0816E:  MOVLB  3
08170:  CLRF   x73
08172:  MOVF   x73,W
08174:  SUBLW  03
08176:  BNC   818A
....................                         UDPGet(&v); 
08178:  MOVLW  03
0817A:  MOVWF  x83
0817C:  MOVLW  72
0817E:  MOVWF  x82
08180:  MOVLB  0
08182:  RCALL  7D2A
08184:  MOVLB  3
08186:  INCF   x73,F
08188:  BRA    8172
....................                } 
....................                else 
0818A:  BRA    81CC
0818C:  MOVLB  0
....................                { 
....................                        UDPGet(&tempDNS.v[0]); 
0818E:  MOVLW  01
08190:  MOVLB  3
08192:  MOVWF  x83
08194:  MOVLW  59
08196:  MOVWF  x82
08198:  MOVLB  0
0819A:  RCALL  7D2A
....................                        UDPGet(&tempDNS.v[1]); 
0819C:  MOVLW  01
0819E:  MOVLB  3
081A0:  MOVWF  x83
081A2:  MOVLW  5A
081A4:  MOVWF  x82
081A6:  MOVLB  0
081A8:  RCALL  7D2A
....................                        UDPGet(&tempDNS.v[2]); 
081AA:  MOVLW  01
081AC:  MOVLB  3
081AE:  MOVWF  x83
081B0:  MOVLW  5B
081B2:  MOVWF  x82
081B4:  MOVLB  0
081B6:  RCALL  7D2A
....................                        UDPGet(&tempDNS.v[3]); 
081B8:  MOVLW  01
081BA:  MOVLB  3
081BC:  MOVWF  x83
081BE:  MOVLW  5C
081C0:  MOVWF  x82
081C2:  MOVLB  0
081C4:  RCALL  7D2A
....................                   ValidValues.bits.DNS = 1; 
081C6:  MOVLB  1
081C8:  BSF    x5D.3
081CA:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
081CC:  BRA    81D0
....................                     goto UDPInvalid; 
081CE:  BRA    8376
....................  
....................                 // Discard any other DNS server addresses 
....................                 j -= 4; 
081D0:  MOVLW  04
081D2:  SUBWF  x74,F
....................                 while(j--) 
....................                     UDPGet(&v); 
081D4:  MOVF   x74,W
081D6:  DECF   x74,F
081D8:  XORLW  00
081DA:  BZ    81EC
081DC:  MOVLW  03
081DE:  MOVWF  x83
081E0:  MOVLW  72
081E2:  MOVWF  x82
081E4:  MOVLB  0
081E6:  RCALL  7D2A
081E8:  MOVLB  3
081EA:  BRA    81D4
....................                 break; 
081EC:  MOVLB  0
081EE:  BRA    831A
.................... #endif 
....................  
.................... //            case DHCP_HOST_NAME: 
.................... //                UDPGet(&j); 
.................... //                // Len must be >= 4. 
.................... //                if(j < 1u) 
.................... //               goto UDPInvalid; 
.................... // 
.................... //            // Check to see if this is the first offer 
.................... //            if(DHCPState.bits.bOfferReceived) 
.................... //            { 
.................... //                 // Discard offered host name, we already have an offer 
.................... //                   while(j--) 
.................... //                       UDPGet(&v); 
.................... //            } 
.................... //            else 
.................... //            { 
.................... //               for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
.................... //               { 
.................... //                  UDPGet(&tempHostName[i]); 
.................... //               } 
.................... //               while(j--) 
.................... //               { 
.................... //                  UDPGet(&v); 
.................... //               } 
.................... //               ValidValues.bits.HostName = 1; 
.................... //            } 
.................... // 
.................... //                break; 
....................  
....................             case DHCP_SERVER_IDENTIFIER: 
....................                 UDPGet(&v);                         // Get len 
081F0:  MOVLW  03
081F2:  MOVLB  3
081F4:  MOVWF  x83
081F6:  MOVLW  72
081F8:  MOVWF  x82
081FA:  MOVLB  0
081FC:  RCALL  7D2A
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
081FE:  MOVLB  3
08200:  MOVF   x72,W
08202:  SUBLW  04
08204:  BNZ   8240
....................                 { 
....................                     UDPGet(&tempServerID.v[3]);   // Get the id 
08206:  MOVLW  03
08208:  MOVWF  x83
0820A:  MOVLW  7A
0820C:  MOVWF  x82
0820E:  MOVLB  0
08210:  RCALL  7D2A
....................                     UDPGet(&tempServerID.v[2]); 
08212:  MOVLW  03
08214:  MOVLB  3
08216:  MOVWF  x83
08218:  MOVLW  79
0821A:  MOVWF  x82
0821C:  MOVLB  0
0821E:  RCALL  7D2A
....................                     UDPGet(&tempServerID.v[1]); 
08220:  MOVLW  03
08222:  MOVLB  3
08224:  MOVWF  x83
08226:  MOVLW  78
08228:  MOVWF  x82
0822A:  MOVLB  0
0822C:  RCALL  7D2A
....................                     UDPGet(&tempServerID.v[0]); 
0822E:  MOVLW  03
08230:  MOVLB  3
08232:  MOVWF  x83
08234:  MOVLW  77
08236:  MOVWF  x82
08238:  MOVLB  0
0823A:  RCALL  7D2A
....................                 } 
....................                 else 
0823C:  BRA    8244
0823E:  MOVLB  3
....................                     goto UDPInvalid; 
08240:  BRA    8376
08242:  MOVLB  0
....................                 break; 
08244:  BRA    831A
....................  
....................             case DHCP_END_OPTION: 
....................                 lbDone = TRUE; 
08246:  MOVLB  3
08248:  BSF    x76.0
....................                 break; 
0824A:  MOVLB  0
0824C:  BRA    831A
....................  
....................             case DHCP_IP_LEASE_TIME: 
....................                 UDPGet(&v);                         // Get len 
0824E:  MOVLW  03
08250:  MOVLB  3
08252:  MOVWF  x83
08254:  MOVLW  72
08256:  MOVWF  x82
08258:  MOVLB  0
0825A:  RCALL  7D2A
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
0825C:  MOVLB  3
0825E:  MOVF   x72,W
08260:  SUBLW  04
08262:  BNZ   82EE
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
08264:  MOVLB  0
08266:  BTFSS  x88.1
08268:  BRA    828A
....................                { 
....................                     // Discard offered lease time, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
0826A:  MOVLB  3
0826C:  CLRF   x73
0826E:  MOVF   x73,W
08270:  SUBLW  03
08272:  BNC   8286
....................                         UDPGet(&v); 
08274:  MOVLW  03
08276:  MOVWF  x83
08278:  MOVLW  72
0827A:  MOVWF  x82
0827C:  MOVLB  0
0827E:  RCALL  7D2A
08280:  MOVLB  3
08282:  INCF   x73,F
08284:  BRA    826E
....................                } 
....................                else 
08286:  BRA    82EC
08288:  MOVLB  0
....................                { 
....................                        UDPGet(&DHCPLeaseTime.v[3]); 
0828A:  MOVLW  01
0828C:  MOVLB  3
0828E:  MOVWF  x83
08290:  MOVLW  4C
08292:  MOVWF  x82
08294:  MOVLB  0
08296:  RCALL  7D2A
....................                        UDPGet(&DHCPLeaseTime.v[2]); 
08298:  MOVLW  01
0829A:  MOVLB  3
0829C:  MOVWF  x83
0829E:  MOVLW  4B
082A0:  MOVWF  x82
082A2:  MOVLB  0
082A4:  RCALL  7D2A
....................                        UDPGet(&DHCPLeaseTime.v[1]); 
082A6:  MOVLW  01
082A8:  MOVLB  3
082AA:  MOVWF  x83
082AC:  MOVLW  4A
082AE:  MOVWF  x82
082B0:  MOVLB  0
082B2:  RCALL  7D2A
....................                        UDPGet(&DHCPLeaseTime.v[0]); 
082B4:  MOVLW  01
082B6:  MOVLB  3
082B8:  MOVWF  x83
082BA:  MOVLW  49
082BC:  MOVWF  x82
082BE:  MOVLB  0
082C0:  RCALL  7D2A
....................  
....................                        // Due to possible timing delays, consider actual lease 
....................                        // time less by half hour. 
....................                        if ( DHCPLeaseTime.Val > HALF_HOUR ) 
082C2:  MOVLB  1
082C4:  MOVF   x4C,F
082C6:  BNZ   82DC
082C8:  MOVF   x4B,F
082CA:  BNZ   82DC
082CC:  MOVF   x4A,W
082CE:  SUBLW  06
082D0:  BC    82EA
082D2:  XORLW  FF
082D4:  BNZ   82DC
082D6:  MOVF   x49,W
082D8:  SUBLW  08
082DA:  BC    82EA
....................                            DHCPLeaseTime.Val = DHCPLeaseTime.Val - HALF_HOUR; 
082DC:  MOVLW  08
082DE:  SUBWF  x49,F
082E0:  MOVLW  07
082E2:  SUBWFB x4A,F
082E4:  MOVLW  00
082E6:  SUBWFB x4B,F
082E8:  SUBWFB x4C,F
082EA:  MOVLB  3
....................                } 
....................                 } 
....................                 else 
082EC:  BRA    82F0
....................                     goto UDPInvalid; 
082EE:  BRA    8376
....................                 break; 
082F0:  MOVLB  0
082F2:  BRA    831A
....................  
....................             default: 
....................                 // Ignore all unsupport tags. 
....................                 UDPGet(&j);                     // Get option len 
082F4:  MOVLW  03
082F6:  MOVLB  3
082F8:  MOVWF  x83
082FA:  MOVLW  74
082FC:  MOVWF  x82
082FE:  MOVLB  0
08300:  RCALL  7D2A
....................                 while( j-- )                    // Ignore option values 
....................                     UDPGet(&v); 
08302:  MOVLB  3
08304:  MOVF   x74,W
08306:  DECF   x74,F
08308:  XORLW  00
0830A:  BZ    831C
0830C:  MOVLW  03
0830E:  MOVWF  x83
08310:  MOVLW  72
08312:  MOVWF  x82
08314:  MOVLB  0
08316:  RCALL  7D2A
08318:  BRA    8302
0831A:  MOVLB  3
....................             } 
....................         } while( !lbDone ); 
0831C:  BTFSS  x76.0
0831E:  BRA    7FAC
....................     } 
....................  
....................     // If this is an OFFER message, remember current server id. 
....................     if ( type == DHCP_OFFER_MESSAGE ) 
08320:  MOVF   x75,W
08322:  SUBLW  02
08324:  BNZ   833E
....................     { 
....................         DHCPServerID.Val = tempServerID.Val; 
08326:  MOVFF  37A,148
0832A:  MOVFF  379,147
0832E:  MOVFF  378,146
08332:  MOVFF  377,145
....................       DHCPState.bits.bOfferReceived = TRUE; 
08336:  MOVLB  0
08338:  BSF    x88.1
....................     } 
....................     else 
0833A:  BRA    836C
0833C:  MOVLB  3
....................     { 
....................         // For other types of messages, make sure that received 
....................         // server id matches with our previous one. 
....................         if ( DHCPServerID.Val != tempServerID.Val ) 
0833E:  MOVF   x77,W
08340:  MOVLB  1
08342:  SUBWF  x45,W
08344:  BNZ   8364
08346:  MOVLB  3
08348:  MOVF   x78,W
0834A:  MOVLB  1
0834C:  SUBWF  x46,W
0834E:  BNZ   8364
08350:  MOVLB  3
08352:  MOVF   x79,W
08354:  MOVLB  1
08356:  SUBWF  x47,W
08358:  BNZ   8364
0835A:  MOVLB  3
0835C:  MOVF   x7A,W
0835E:  MOVLB  1
08360:  SUBWF  x48,W
08362:  BZ    836A
....................             type = DHCP_UNKNOWN_MESSAGE; 
08364:  MOVLB  3
08366:  CLRF   x75
08368:  MOVLB  1
0836A:  MOVLB  0
....................     } 
....................  
....................     UDPDiscard();                             // We are done with this packet 
0836C:  RCALL  7E44
....................     return type; 
0836E:  MOVLB  3
08370:  MOVFF  375,01
08374:  BRA    8380
....................  
.................... UDPInvalid: 
....................     UDPDiscard(); 
08376:  MOVLB  0
08378:  RCALL  7E44
....................     return DHCP_UNKNOWN_MESSAGE; 
0837A:  MOVLW  00
0837C:  MOVWF  01
0837E:  MOVLB  3
....................  
.................... } 
08380:  MOVLB  0
08382:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... static void _DHCPSend(BYTE messageType) 
.................... { 
....................     BYTE  i; 
....................  
....................     UDPPut(BOOT_REQUEST);                       // op 
*
07AF0:  MOVLW  01
07AF2:  MOVLB  3
07AF4:  MOVWF  x85
07AF6:  MOVLB  0
07AF8:  RCALL  79B4
....................     UDPPut(HW_TYPE);                            // htype 
07AFA:  MOVLW  01
07AFC:  MOVLB  3
07AFE:  MOVWF  x85
07B00:  MOVLB  0
07B02:  RCALL  79B4
....................     UDPPut(LEN_OF_HW_TYPE);                     // hlen 
07B04:  MOVLW  06
07B06:  MOVLB  3
07B08:  MOVWF  x85
07B0A:  MOVLB  0
07B0C:  RCALL  79B4
....................     UDPPut(0);                                  // hops 
07B0E:  MOVLB  3
07B10:  CLRF   x85
07B12:  MOVLB  0
07B14:  RCALL  79B4
....................     UDPPut(0x12);                               // xid[0] 
07B16:  MOVLW  12
07B18:  MOVLB  3
07B1A:  MOVWF  x85
07B1C:  MOVLB  0
07B1E:  RCALL  79B4
....................     UDPPut(0x23);                               // xid[1] 
07B20:  MOVLW  23
07B22:  MOVLB  3
07B24:  MOVWF  x85
07B26:  MOVLB  0
07B28:  RCALL  79B4
....................     UDPPut(0x34);                               // xid[2] 
07B2A:  MOVLW  34
07B2C:  MOVLB  3
07B2E:  MOVWF  x85
07B30:  MOVLB  0
07B32:  RCALL  79B4
....................     UDPPut(0x56);                               // xid[3] 
07B34:  MOVLW  56
07B36:  MOVLB  3
07B38:  MOVWF  x85
07B3A:  MOVLB  0
07B3C:  RCALL  79B4
....................     UDPPut(0);                                  // secs[0] 
07B3E:  MOVLB  3
07B40:  CLRF   x85
07B42:  MOVLB  0
07B44:  RCALL  79B4
....................     UDPPut(0);                                  // secs[1] 
07B46:  MOVLB  3
07B48:  CLRF   x85
07B4A:  MOVLB  0
07B4C:  RCALL  79B4
....................     UDPPut(0x80);                               // flags[0] with BF set 
07B4E:  MOVLW  80
07B50:  MOVLB  3
07B52:  MOVWF  x85
07B54:  MOVLB  0
07B56:  RCALL  79B4
....................     UDPPut(0);                                  // flags[1] 
07B58:  MOVLB  3
07B5A:  CLRF   x85
07B5C:  MOVLB  0
07B5E:  RCALL  79B4
....................  
....................  
....................      // If this is DHCP REQUEST message, use previously allocated IP address. 
.................... #if 0 
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
....................     { 
....................         UDPPut(tempIPAddress.v[0]); 
....................         UDPPut(tempIPAddress.v[1]); 
....................         UDPPut(tempIPAddress.v[2]); 
....................         UDPPut(tempIPAddress.v[3]); 
....................     } 
....................     else 
.................... #endif 
....................     { 
....................         UDPPut(0x00); 
07B60:  MOVLB  3
07B62:  CLRF   x85
07B64:  MOVLB  0
07B66:  RCALL  79B4
....................         UDPPut(0x00); 
07B68:  MOVLB  3
07B6A:  CLRF   x85
07B6C:  MOVLB  0
07B6E:  RCALL  79B4
....................         UDPPut(0x00); 
07B70:  MOVLB  3
07B72:  CLRF   x85
07B74:  MOVLB  0
07B76:  RCALL  79B4
....................         UDPPut(0x00); 
07B78:  MOVLB  3
07B7A:  CLRF   x85
07B7C:  MOVLB  0
07B7E:  RCALL  79B4
....................     } 
....................  
....................     // Set yiaddr, siaddr, giaddr as zeros, 
....................     for ( i = 0; i < 12u; i++ ) 
07B80:  MOVLB  3
07B82:  CLRF   x73
07B84:  MOVF   x73,W
07B86:  SUBLW  0B
07B88:  BNC   7B96
....................         UDPPut(0x00); 
07B8A:  CLRF   x85
07B8C:  MOVLB  0
07B8E:  RCALL  79B4
07B90:  MOVLB  3
07B92:  INCF   x73,F
07B94:  BRA    7B84
....................  
....................     // Load chaddr - Client hardware address. 
....................     UDPPut(AppConfig.MyMACAddr.v[0]); 
07B96:  MOVFF  1C,385
07B9A:  MOVLB  0
07B9C:  RCALL  79B4
....................     UDPPut(AppConfig.MyMACAddr.v[1]); 
07B9E:  MOVFF  1D,385
07BA2:  RCALL  79B4
....................     UDPPut(AppConfig.MyMACAddr.v[2]); 
07BA4:  MOVFF  1E,385
07BA8:  RCALL  79B4
....................     UDPPut(AppConfig.MyMACAddr.v[3]); 
07BAA:  MOVFF  1F,385
07BAE:  RCALL  79B4
....................     UDPPut(AppConfig.MyMACAddr.v[4]); 
07BB0:  MOVFF  20,385
07BB4:  RCALL  79B4
....................     UDPPut(AppConfig.MyMACAddr.v[5]); 
07BB6:  MOVFF  21,385
07BBA:  RCALL  79B4
....................  
....................     // Set chaddr[6..15], sname and file as zeros. 
....................     for ( i = 0; i < 202u; i++ ) 
07BBC:  MOVLB  3
07BBE:  CLRF   x73
07BC0:  MOVF   x73,W
07BC2:  SUBLW  C9
07BC4:  BNC   7BD2
....................         UDPPut(0); 
07BC6:  CLRF   x85
07BC8:  MOVLB  0
07BCA:  RCALL  79B4
07BCC:  MOVLB  3
07BCE:  INCF   x73,F
07BD0:  BRA    7BC0
....................  
....................     // Load magic cookie as per RFC 1533. 
....................     UDPPut(99); 
07BD2:  MOVLW  63
07BD4:  MOVWF  x85
07BD6:  MOVLB  0
07BD8:  RCALL  79B4
....................     UDPPut(130); 
07BDA:  MOVLW  82
07BDC:  MOVLB  3
07BDE:  MOVWF  x85
07BE0:  MOVLB  0
07BE2:  RCALL  79B4
....................     UDPPut(83); 
07BE4:  MOVLW  53
07BE6:  MOVLB  3
07BE8:  MOVWF  x85
07BEA:  MOVLB  0
07BEC:  RCALL  79B4
....................     UDPPut(99); 
07BEE:  MOVLW  63
07BF0:  MOVLB  3
07BF2:  MOVWF  x85
07BF4:  MOVLB  0
07BF6:  RCALL  79B4
....................  
....................     // Load message type. 
....................     UDPPut(DHCP_MESSAGE_TYPE); 
07BF8:  MOVLW  35
07BFA:  MOVLB  3
07BFC:  MOVWF  x85
07BFE:  MOVLB  0
07C00:  RCALL  79B4
....................     UDPPut(DHCP_MESSAGE_TYPE_LEN); 
07C02:  MOVLW  01
07C04:  MOVLB  3
07C06:  MOVWF  x85
07C08:  MOVLB  0
07C0A:  RCALL  79B4
....................     UDPPut(messageType); 
07C0C:  MOVFF  372,385
07C10:  RCALL  79B4
....................  
....................    if(messageType == DHCP_DISCOVER_MESSAGE) 
07C12:  MOVLB  3
07C14:  DECFSZ x72,W
07C16:  BRA    7C1E
....................    { 
....................       // Reset offered flag so we know to act upon the next valid offer 
....................       DHCPState.bits.bOfferReceived = FALSE; 
07C18:  MOVLB  0
07C1A:  BCF    x88.1
07C1C:  MOVLB  3
....................    } 
....................  
....................     if ( messageType != DHCP_DISCOVER_MESSAGE && tempIPAddress.Val != 0x0000u ) 
07C1E:  DECFSZ x72,W
07C20:  BRA    7C24
07C22:  BRA    7C6A
07C24:  MOVLB  1
07C26:  MOVF   x4D,F
07C28:  BNZ   7C3C
07C2A:  MOVF   x4E,F
07C2C:  BNZ   7C3C
07C2E:  MOVF   x4F,F
07C30:  BNZ   7C3C
07C32:  MOVF   x50,F
07C34:  BTFSS  FD8.2
07C36:  BRA    7C3C
07C38:  MOVLB  3
07C3A:  BRA    7C6A
....................     { 
....................          // DHCP REQUEST message may include server identifier, 
....................          // to identify the server we are talking to. 
....................          // DHCP ACK may include it too.  To simplify logic, 
....................          // we will include server identifier in DHCP ACK message too. 
....................          // _DHCPReceive() would populate "serverID" when it 
....................          // receives DHCP OFFER message. We will simply use that 
....................          // when we are replying to server. 
....................          // If this is a renwal request, do not include server id. 
....................          UDPPut(DHCP_SERVER_IDENTIFIER); 
07C3C:  MOVLW  36
07C3E:  MOVLB  3
07C40:  MOVWF  x85
07C42:  MOVLB  0
07C44:  RCALL  79B4
....................          UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
07C46:  MOVLW  04
07C48:  MOVLB  3
07C4A:  MOVWF  x85
07C4C:  MOVLB  0
07C4E:  RCALL  79B4
....................          UDPPut(DHCPServerID.v[3]); 
07C50:  MOVFF  148,385
07C54:  RCALL  79B4
....................          UDPPut(DHCPServerID.v[2]); 
07C56:  MOVFF  147,385
07C5A:  RCALL  79B4
....................          UDPPut(DHCPServerID.v[1]); 
07C5C:  MOVFF  146,385
07C60:  RCALL  79B4
....................          UDPPut(DHCPServerID.v[0]); 
07C62:  MOVFF  145,385
07C66:  RCALL  79B4
07C68:  MOVLB  3
....................      } 
....................  
....................     // Load our interested parameters 
....................     // This is hardcoded list.  If any new parameters are desired, 
....................     // new lines must be added here. 
....................     UDPPut(DHCP_PARAM_REQUEST_LIST); 
07C6A:  MOVLW  37
07C6C:  MOVWF  x85
07C6E:  MOVLB  0
07C70:  RCALL  79B4
....................     UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
07C72:  MOVLW  04
07C74:  MOVLB  3
07C76:  MOVWF  x85
07C78:  MOVLB  0
07C7A:  RCALL  79B4
....................     UDPPut(DHCP_SUBNET_MASK); 
07C7C:  MOVLW  01
07C7E:  MOVLB  3
07C80:  MOVWF  x85
07C82:  MOVLB  0
07C84:  RCALL  79B4
....................     UDPPut(DHCP_ROUTER); 
07C86:  MOVLW  03
07C88:  MOVLB  3
07C8A:  MOVWF  x85
07C8C:  MOVLB  0
07C8E:  RCALL  79B4
....................     UDPPut(DHCP_DNS); 
07C90:  MOVLW  06
07C92:  MOVLB  3
07C94:  MOVWF  x85
07C96:  MOVLB  0
07C98:  RCALL  79B4
....................     UDPPut(DHCP_HOST_NAME); 
07C9A:  MOVLW  0C
07C9C:  MOVLB  3
07C9E:  MOVWF  x85
07CA0:  MOVLB  0
07CA2:  RCALL  79B4
....................  
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
07CA4:  MOVLB  3
07CA6:  MOVF   x72,W
07CA8:  SUBLW  03
07CAA:  BNZ   7CD8
....................     { 
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
07CAC:  MOVLW  32
07CAE:  MOVWF  x85
07CB0:  MOVLB  0
07CB2:  RCALL  79B4
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
07CB4:  MOVLW  04
07CB6:  MOVLB  3
07CB8:  MOVWF  x85
07CBA:  MOVLB  0
07CBC:  RCALL  79B4
....................  
....................         UDPPut(tempIPAddress.v[0]); 
07CBE:  MOVFF  14D,385
07CC2:  RCALL  79B4
....................         UDPPut(tempIPAddress.v[1]); 
07CC4:  MOVFF  14E,385
07CC8:  RCALL  79B4
....................         UDPPut(tempIPAddress.v[2]); 
07CCA:  MOVFF  14F,385
07CCE:  RCALL  79B4
....................         UDPPut(tempIPAddress.v[3]); 
07CD0:  MOVFF  150,385
07CD4:  RCALL  79B4
07CD6:  MOVLB  3
....................     } 
....................  
....................     // Add any new paramter request here. 
....................  
....................     // End of Options. 
....................     UDPPut(DHCP_END_OPTION); 
07CD8:  MOVLW  FF
07CDA:  MOVWF  x85
07CDC:  MOVLB  0
07CDE:  RCALL  79B4
....................  
....................     UDPFlush(); 
07CE0:  RCALL  785C
.................... } 
07CE2:  RETLW  00
....................  
....................  
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
015AC:  BCF    58.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
015AE:  MOVLW  FF
015B0:  MOVLB  1
015B2:  MOVWF  x61
....................     Cache.MACAddr.v[1] = 0xff; 
015B4:  MOVWF  x62
....................     Cache.MACAddr.v[2] = 0xff; 
015B6:  MOVWF  x63
....................     Cache.MACAddr.v[3] = 0xff; 
015B8:  MOVWF  x64
....................     Cache.MACAddr.v[4] = 0xff; 
015BA:  MOVWF  x65
....................     Cache.MACAddr.v[5] = 0xff; 
015BC:  MOVWF  x66
....................  
....................     Cache.IPAddr.Val = 0x0; 
015BE:  CLRF   x6A
015C0:  CLRF   x69
015C2:  CLRF   x68
015C4:  CLRF   x67
.................... } 
015C6:  MOVLB  0
015C8:  GOTO   2BFC (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
04896:  MOVLW  00
04898:  BTFSC  58.1
0489A:  MOVLW  01
0489C:  XORLW  00
0489E:  BZ    48A2
048A0:  BRA    4900
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
048A2:  MOVLW  03
048A4:  MOVLB  3
048A6:  MOVWF  x71
048A8:  MOVLW  65
048AA:  MOVWF  x70
048AC:  MOVLW  03
048AE:  MOVWF  x73
048B0:  MOVLW  6F
048B2:  MOVWF  x72
048B4:  MOVLB  0
048B6:  BRA    4618
048B8:  MOVF   01,F
048BA:  BNZ   48BE
....................             break; 
048BC:  BRA    4920
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
048BE:  CALL   1908
....................  
....................         if ( opCode == ARP_REPLY ) 
048C2:  MOVLB  3
048C4:  MOVF   x6F,F
048C6:  BNZ   48FC
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
048C8:  MOVLW  01
048CA:  MOVWF  FEA
048CC:  MOVLW  61
048CE:  MOVWF  FE9
048D0:  MOVLW  03
048D2:  MOVWF  FE2
048D4:  MOVLW  65
048D6:  MOVWF  FE1
048D8:  MOVLW  06
048DA:  MOVWF  01
048DC:  MOVFF  FE6,FEE
048E0:  DECFSZ 01,F
048E2:  BRA    48DC
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
048E4:  MOVFF  36E,16A
048E8:  MOVFF  36D,169
048EC:  MOVFF  36C,168
048F0:  MOVFF  36B,167
....................             break; 
048F4:  MOVLB  0
048F6:  BRA    4920
....................         } 
....................         else 
048F8:  BRA    4900
048FA:  MOVLB  3
....................             smARP = SM_ARP_REPLY; 
048FC:  BSF    58.1
048FE:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
04900:  MOVLW  03
04902:  MOVLB  3
04904:  MOVWF  x8B
04906:  MOVLW  65
04908:  MOVWF  x8A
0490A:  CLRF   x8C
0490C:  MOVLB  0
0490E:  RCALL  46FE
04910:  MOVF   01,F
04912:  BZ    4918
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
04914:  BCF    58.1
.................... 		} 
....................         else 
04916:  BRA    491E
....................             return FALSE; 
04918:  MOVLW  00
0491A:  MOVWF  01
0491C:  BRA    4924
....................         break; 
0491E:  BRA    4920
....................  
....................     } 
....................     return TRUE; 
04920:  MOVLW  01
04922:  MOVWF  01
.................... } 
04924:  GOTO   88AA (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
060B4:  MOVLB  3
060B6:  MOVFF  37E,FE9
060BA:  MOVFF  37F,FEA
060BE:  MOVFF  FEF,00
060C2:  MOVFF  FEC,01
060C6:  MOVFF  FEC,02
060CA:  MOVFF  FEC,03
060CE:  MOVFF  03,389
060D2:  MOVFF  02,388
060D6:  MOVFF  01,387
060DA:  MOVFF  00,386
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
060DE:  MOVLW  03
060E0:  MOVWF  x8B
060E2:  MOVLW  80
060E4:  MOVWF  x8A
060E6:  MOVLW  01
060E8:  MOVWF  x8C
060EA:  MOVLB  0
060EC:  CALL   46FE
.................... } 
060F0:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
*
06100:  MOVLB  3
06102:  MOVFF  37E,FE9
06106:  MOVFF  37F,FEA
0610A:  MOVFF  FEF,00
0610E:  MOVFF  FEC,01
06112:  MOVFF  FEC,02
06116:  MOVFF  FEC,03
0611A:  MOVF   00,W
0611C:  MOVLB  1
0611E:  SUBWF  x67,W
06120:  BNZ   6134
06122:  MOVF   01,W
06124:  SUBWF  x68,W
06126:  BNZ   6134
06128:  MOVF   02,W
0612A:  SUBWF  x69,W
0612C:  BNZ   6134
0612E:  MOVF   03,W
06130:  SUBWF  x6A,W
06132:  BZ    614C
06134:  MOVF   26,W
06136:  SUBWF  x67,W
06138:  BNZ   6176
0613A:  MOVF   27,W
0613C:  SUBWF  x68,W
0613E:  BNZ   6176
06140:  MOVF   28,W
06142:  SUBWF  x69,W
06144:  BNZ   6176
06146:  MOVF   29,W
06148:  SUBWF  x6A,W
0614A:  BNZ   6176
....................     { 
....................         *MACAddr = Cache.MACAddr; 
0614C:  MOVFF  381,03
06150:  MOVLB  3
06152:  MOVFF  380,FE9
06156:  MOVFF  381,FEA
0615A:  MOVLW  01
0615C:  MOVWF  FE2
0615E:  MOVLW  61
06160:  MOVWF  FE1
06162:  MOVLW  06
06164:  MOVWF  01
06166:  MOVFF  FE6,FEE
0616A:  DECFSZ 01,F
0616C:  BRA    6166
....................         return TRUE; 
0616E:  MOVLW  01
06170:  MOVWF  01
06172:  BRA    617C
06174:  MOVLB  1
....................     } 
....................     return FALSE; 
06176:  MOVLW  00
06178:  MOVWF  01
0617A:  MOVLB  3
.................... } 
0617C:  MOVLB  0
0617E:  RETLW  00
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
04618:  MOVLW  03
0461A:  MOVLB  3
0461C:  MOVWF  xFA
0461E:  MOVLW  74
04620:  MOVWF  xF9
04622:  CLRF   xFC
04624:  MOVLW  1C
04626:  MOVWF  xFB
04628:  MOVLB  0
0462A:  CALL   25BE
....................  
....................     MACDiscardRx(); 
0462E:  CALL   1908
....................  
....................     SwapARPPacket(&packet); 
04632:  MOVLW  03
04634:  MOVLB  3
04636:  MOVWF  xAB
04638:  MOVLW  74
0463A:  MOVWF  xAA
0463C:  MOVLB  0
0463E:  RCALL  453E
....................  
.................... //   debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
.................... //      packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
.................... //      packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
.................... //      packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
.................... //      packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
04640:  MOVLB  3
04642:  DECFSZ x74,W
04644:  BRA    4656
04646:  MOVF   x75,F
04648:  BNZ   4656
0464A:  MOVF   x78,W
0464C:  SUBLW  06
0464E:  BNZ   4656
04650:  MOVF   x79,W
04652:  SUBLW  04
04654:  BZ    465C
....................          return FALSE; 
04656:  MOVLW  00
04658:  MOVWF  01
0465A:  BRA    46F8
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
0465C:  MOVF   x7A,W
0465E:  SUBLW  02
04660:  BNZ   4672
04662:  MOVF   x7B,F
04664:  BNZ   4672
....................         *opCode = ARP_REPLY; 
04666:  MOVFF  372,FE9
0466A:  MOVFF  373,FEA
0466E:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
04670:  BRA    469A
04672:  DECFSZ x7A,W
04674:  BRA    4688
04676:  MOVF   x7B,F
04678:  BNZ   4688
....................         *opCode = ARP_REQUEST; 
0467A:  MOVFF  372,FE9
0467E:  MOVFF  373,FEA
04682:  MOVLW  01
04684:  MOVWF  FEF
....................     else 
04686:  BRA    469A
....................     { 
....................         *opCode = ARP_UNKNOWN; 
04688:  MOVFF  372,FE9
0468C:  MOVFF  373,FEA
04690:  MOVLW  02
04692:  MOVWF  FEF
....................         return FALSE; 
04694:  MOVLW  00
04696:  MOVWF  01
04698:  BRA    46F8
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
0469A:  MOVF   18,W
0469C:  SUBWF  x8C,W
0469E:  BNZ   46F2
046A0:  MOVF   19,W
046A2:  SUBWF  x8D,W
046A4:  BNZ   46F2
046A6:  MOVF   1A,W
046A8:  SUBWF  x8E,W
046AA:  BNZ   46F2
046AC:  MOVF   1B,W
046AE:  SUBWF  x8F,W
046B0:  BNZ   46F2
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
046B2:  MOVFF  370,FE9
046B6:  MOVFF  371,FEA
046BA:  MOVLW  03
046BC:  MOVWF  FE2
046BE:  MOVLW  7C
046C0:  MOVWF  FE1
046C2:  MOVLW  06
046C4:  MOVWF  01
046C6:  MOVFF  FE6,FEE
046CA:  DECFSZ 01,F
046CC:  BRA    46C6
....................         remote->IPAddr      = packet.SenderIPAddr; 
046CE:  MOVLW  06
046D0:  ADDWF  x70,W
046D2:  MOVWF  FE9
046D4:  MOVLW  00
046D6:  ADDWFC x71,W
046D8:  MOVWF  FEA
046DA:  MOVFF  382,FEF
046DE:  MOVFF  383,FEC
046E2:  MOVFF  384,FEC
046E6:  MOVFF  385,FEC
....................         return TRUE; 
046EA:  MOVLW  01
046EC:  MOVWF  01
046EE:  BRA    46F8
....................     } 
....................     else 
046F0:  BRA    46F8
....................         return FALSE; 
046F2:  MOVLW  00
046F4:  MOVWF  01
046F6:  BRA    46F8
.................... } 
046F8:  MOVLB  0
046FA:  GOTO   48B8 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
046FE:  MOVLW  01
04700:  MOVLB  3
04702:  MOVWF  xEB
04704:  MOVLB  0
04706:  CALL   1AEA
0470A:  MOVFF  01,3A9
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
0470E:  MOVLB  3
04710:  INCFSZ xA9,W
04712:  BRA    471A
....................       return FALSE; 
04714:  MOVLW  00
04716:  MOVWF  01
04718:  BRA    4892
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
0471A:  MOVFF  3A9,404
0471E:  MOVLB  4
04720:  CLRF   x06
04722:  CLRF   x05
04724:  MOVLB  0
04726:  CALL   1B14
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
0472A:  MOVLB  3
0472C:  CLRF   x8E
0472E:  MOVLW  01
04730:  MOVWF  x8D
....................     packet.Protocol                 = ARP_IP; 
04732:  MOVLW  08
04734:  MOVWF  x90
04736:  CLRF   x8F
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
04738:  MOVLW  06
0473A:  MOVWF  x91
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
0473C:  MOVLW  04
0473E:  MOVWF  x92
....................  
....................     if ( opCode == ARP_REQUEST ) 
04740:  DECFSZ x8C,W
04742:  BRA    475A
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
04744:  CLRF   x94
04746:  MOVLW  01
04748:  MOVWF  x93
....................         packet.TargetMACAddr.v[0]   = 0xff; 
0474A:  MOVLW  FF
0474C:  MOVWF  x9F
....................         packet.TargetMACAddr.v[1]   = 0xff; 
0474E:  MOVWF  xA0
....................         packet.TargetMACAddr.v[2]   = 0xff; 
04750:  MOVWF  xA1
....................         packet.TargetMACAddr.v[3]   = 0xff; 
04752:  MOVWF  xA2
....................         packet.TargetMACAddr.v[4]   = 0xff; 
04754:  MOVWF  xA3
....................         packet.TargetMACAddr.v[5]   = 0xff; 
04756:  MOVWF  xA4
....................     } 
....................     else 
04758:  BRA    4788
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
0475A:  CLRF   x94
0475C:  MOVLW  02
0475E:  MOVWF  x93
....................         packet.TargetMACAddr        = remote->MACAddr; 
04760:  MOVFF  38B,03
04764:  MOVFF  38A,3AA
04768:  MOVFF  38B,3AB
0476C:  MOVLW  03
0476E:  MOVWF  FEA
04770:  MOVLW  9F
04772:  MOVWF  FE9
04774:  MOVFF  38B,FE2
04778:  MOVFF  38A,FE1
0477C:  MOVLW  06
0477E:  MOVWF  01
04780:  MOVFF  FE6,FEE
04784:  DECFSZ 01,F
04786:  BRA    4780
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
04788:  MOVLW  03
0478A:  MOVWF  FEA
0478C:  MOVLW  95
0478E:  MOVWF  FE9
04790:  CLRF   FE2
04792:  MOVLW  1C
04794:  MOVWF  FE1
04796:  MOVLW  06
04798:  MOVWF  01
0479A:  MOVFF  FE6,FEE
0479E:  DECFSZ 01,F
047A0:  BRA    479A
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
047A2:  MOVFF  1B,39E
047A6:  MOVFF  1A,39D
047AA:  MOVFF  19,39C
047AE:  MOVFF  18,39B
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
047B2:  MOVLW  06
047B4:  ADDWF  x8A,W
047B6:  MOVWF  FE9
047B8:  MOVLW  00
047BA:  ADDWFC x8B,W
047BC:  MOVWF  FEA
047BE:  MOVFF  FEF,00
047C2:  MOVFF  FEC,01
047C6:  MOVFF  FEC,02
047CA:  MOVFF  FEC,03
047CE:  MOVF   00,W
047D0:  XORWF  x9B,W
047D2:  MOVWF  xAA
047D4:  MOVF   01,W
047D6:  XORWF  x9C,W
047D8:  MOVWF  xAB
047DA:  MOVF   02,W
047DC:  XORWF  x9D,W
047DE:  MOVWF  xAC
047E0:  MOVF   03,W
047E2:  XORWF  x9E,W
047E4:  MOVWF  xAD
047E6:  MOVF   xAA,W
047E8:  ANDWF  22,W
047EA:  MOVWF  00
047EC:  MOVF   xAB,W
047EE:  ANDWF  23,W
047F0:  MOVWF  01
047F2:  MOVF   xAC,W
047F4:  ANDWF  24,W
047F6:  MOVWF  02
047F8:  MOVF   xAD,W
047FA:  ANDWF  25,W
047FC:  MOVWF  03
047FE:  MOVF   00,F
04800:  BNZ   480E
04802:  MOVF   01,F
04804:  BNZ   480E
04806:  MOVF   02,F
04808:  BNZ   480E
0480A:  MOVF   03,F
0480C:  BZ    4820
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
0480E:  MOVFF  29,3A8
04812:  MOVFF  28,3A7
04816:  MOVFF  27,3A6
0481A:  MOVFF  26,3A5
....................     } 
....................     else 
0481E:  BRA    484C
....................         packet.TargetIPAddr             = remote->IPAddr; 
04820:  MOVLW  06
04822:  ADDWF  x8A,W
04824:  MOVWF  FE9
04826:  MOVLW  00
04828:  ADDWFC x8B,W
0482A:  MOVWF  FEA
0482C:  MOVFF  FEF,00
04830:  MOVFF  FEC,01
04834:  MOVFF  FEC,02
04838:  MOVFF  FEC,03
0483C:  MOVFF  03,3A8
04840:  MOVFF  02,3A7
04844:  MOVFF  01,3A6
04848:  MOVFF  00,3A5
....................  
....................     SwapARPPacket(&packet); 
0484C:  MOVLW  03
0484E:  MOVWF  xAB
04850:  MOVLW  8D
04852:  MOVWF  xAA
04854:  MOVLB  0
04856:  RCALL  453E
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
04858:  MOVLW  03
0485A:  MOVLB  4
0485C:  MOVWF  x09
0485E:  MOVLW  9F
04860:  MOVWF  x08
04862:  MOVLW  06
04864:  MOVWF  x0A
04866:  CLRF   x0C
04868:  MOVLW  1C
0486A:  MOVWF  x0B
0486C:  MOVLB  0
0486E:  CALL   2162
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
04872:  MOVLW  03
04874:  MOVLB  4
04876:  MOVWF  x10
04878:  MOVLW  8D
0487A:  MOVWF  x0F
0487C:  CLRF   x12
0487E:  MOVLW  1C
04880:  MOVWF  x11
04882:  MOVLB  0
04884:  CALL   2118
....................  
....................     MACFlush(); 
04888:  CALL   2622
....................     
....................    return TRUE; 
0488C:  MOVLW  01
0488E:  MOVWF  01
04890:  MOVLB  3
.................... } 
04892:  MOVLB  0
04894:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
0453E:  MOVLB  3
04540:  MOVFF  3AA,01
04544:  MOVFF  3AB,03
04548:  MOVFF  3AA,3AC
0454C:  MOVFF  3AB,3AD
04550:  MOVFF  3AA,FE9
04554:  MOVFF  3AB,FEA
04558:  MOVFF  FEC,3AF
0455C:  MOVF   FED,F
0455E:  MOVFF  FEF,3AE
04562:  MOVFF  3AF,40B
04566:  MOVFF  3AE,40A
0456A:  MOVLB  0
0456C:  CALL   1CDA
04570:  MOVFF  3AD,FEA
04574:  MOVFF  3AC,FE9
04578:  MOVFF  02,FEC
0457C:  MOVF   FED,F
0457E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
04582:  MOVLW  02
04584:  MOVLB  3
04586:  ADDWF  xAA,W
04588:  MOVWF  01
0458A:  MOVLW  00
0458C:  ADDWFC xAB,W
0458E:  MOVWF  03
04590:  MOVFF  01,3AC
04594:  MOVWF  xAD
04596:  MOVLW  02
04598:  ADDWF  xAA,W
0459A:  MOVWF  FE9
0459C:  MOVLW  00
0459E:  ADDWFC xAB,W
045A0:  MOVWF  FEA
045A2:  MOVFF  FEC,3AF
045A6:  MOVF   FED,F
045A8:  MOVFF  FEF,3AE
045AC:  MOVFF  3AF,40B
045B0:  MOVFF  3AE,40A
045B4:  MOVLB  0
045B6:  CALL   1CDA
045BA:  MOVFF  3AD,FEA
045BE:  MOVFF  3AC,FE9
045C2:  MOVFF  02,FEC
045C6:  MOVF   FED,F
045C8:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
045CC:  MOVLW  06
045CE:  MOVLB  3
045D0:  ADDWF  xAA,W
045D2:  MOVWF  01
045D4:  MOVLW  00
045D6:  ADDWFC xAB,W
045D8:  MOVWF  03
045DA:  MOVFF  01,3AC
045DE:  MOVWF  xAD
045E0:  MOVLW  06
045E2:  ADDWF  xAA,W
045E4:  MOVWF  FE9
045E6:  MOVLW  00
045E8:  ADDWFC xAB,W
045EA:  MOVWF  FEA
045EC:  MOVFF  FEC,3AF
045F0:  MOVF   FED,F
045F2:  MOVFF  FEF,3AE
045F6:  MOVFF  3AF,40B
045FA:  MOVFF  3AE,40A
045FE:  MOVLB  0
04600:  CALL   1CDA
04604:  MOVFF  3AD,FEA
04608:  MOVFF  3AC,FE9
0460C:  MOVFF  02,FEC
04610:  MOVF   FED,F
04612:  MOVFF  01,FEF
.................... } 
04616:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                          // 
.................... //                                 SMTP.C                                   // 
.................... //              SMTP Engine for Microchip TCP/IP Stack API                  // 
.................... // 
.................... // Define STACK_USE_SMTP to TRUE before including stacktsk.h in your code 
.................... // to enable this SMTP API.  Once enabled, you can use these functions: 
.................... // 
.................... // SMTPConnect(IP_ADDR ip, int16 port, char *from, char *to, char *subject) 
.................... //    Will open the IP address and TCP port (which should be your SMTP 
.................... //    server), and start the engine that will initiate SMTP connection. 
.................... //    The SMTP engine will then send the mail to: and rcpt from: command, 
.................... //    and create basic E-Mail headers.  Will return TRUE if successfully 
.................... //    started the engine, will return FALSE if a previous engine is still 
.................... //    running. 
.................... //    Once an engine is running, it will stop running once 
.................... //    SMTPIsPutReady() returns TRUE -OR- SMTPLastError() returns a 
.................... //    non-zero number. 
.................... // 
.................... // SMTPIsPutReady() 
.................... //    After a succesfull SMTPConnect(), the SMTP engine will be sending 
.................... //    SMTP commands.  You cannot start sending the body of the e-mail 
.................... //    until the SMTP engine has got the SMTP server in a state that is 
.................... //    ready for the body of the e-mail.  SMTPIsPutReady() returns TRUE 
.................... //    if the SMTP engine and the SMTP server is ready. 
.................... // 
.................... // SMTPLastError() 
.................... //    If there was an error with the SMTP, this will return non-zero. 
.................... //    Once this returns non-zero then you can try again by calling 
.................... //    SMTPConnect(). 
.................... // 
.................... // SMTPPut(char c) 
.................... //    Puts this char into the body of the e-mail.  SMTPIsPutReady() must 
.................... //    return TRUE before this is called. 
.................... // 
.................... // SMTPDisconnect() 
.................... //    Close the e-mail and have the SMTP server send it.  SMTPIsPutReady() 
.................... //    must return TRUE before you call this.  After calling this, wait 
.................... //    until SMTPIsFree() returns TRUE and use SMTPLastError() to see 
.................... //    if the email was sent sucessfully. 
.................... // 
.................... // SMTPIsFree() 
.................... //    Will return TRUE if the SMTP engine is free for another connection. 
.................... // 
.................... // NOTE: You *MUST* use the SMTP server for your ISP.  If you do not know it 
.................... //  then ask your ISP.  The reason for this is that because of the war on 
.................... //  spam almost all SMTP servers block access to clients who aren't on their 
.................... //  network. 
.................... // 
.................... // NOTE: The SMTP engine can only handle one socket at a time.  Therefore you 
.................... //  cannot call a SMTPConnect() until the previous SMTPConnect() has been 
.................... //  disconnected. 
.................... // 
.................... // NOTE: Due to the war on spam many internet service providers are placing 
.................... //  restrictions upon SMTP servers.  Such restrictions may be authentication, 
.................... //  sender-id, message-id and max message-per-minute rate.  This engine 
.................... //  deals with none of those restrictions.  It's very likely in the future 
.................... //  that it will be impossible for a PIC to have the resources to send e-mail 
.................... //  using SMTP. 
.................... // 
.................... // NOTE: If you are using Ethernet, you will have to enable ARP!!! 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef debugf_smtp 
.................... #define debugf_smtp 
.................... #endif 
....................  
.................... enum { 
....................    SMTP_STATE_WAITING=0, SMTP_STATE_START=1, SMTP_STATE_ARP_REQ=2, 
....................    SMTP_STATE_ARP_WAIT=3, SMTP_STATE_CONNECT=4, SMTP_STATE_CONNECT_WAIT=5, 
....................    SMTP_STATE_EHLO=6, SMTP_STATE_MAIL_FROM=7, SMTP_STATE_RCPT_TO=8, 
....................    SMTP_STATE_DATA_START=9, SMTP_STATE_DO_CMD=10, SMTP_STATE_DO_CMD_GET_RESP=11, 
....................    SMTP_STATE_PUT_HEADER=12, SMTP_STATE_PUT_BODY=13, SMTP_STATE_FINISH_EMAIL=14, 
....................    SMTP_STATE_FINISH_EMAIL_WAIT=15, SMTP_STATE_CLOSE=16, 
....................    SMTP_STATE_FORCE_CLOSE=17, SMTP_STATE_RESET=18 
.................... } smtp_state; 
....................  
....................  
.................... TCP_SOCKET smtp_socket=INVALID_SOCKET; 
.................... NODE_INFO smtp_remote; 
.................... char *smtp_engine_from; 
.................... char *smtp_engine_to; 
.................... char *smtp_engine_subject; 
.................... SMTP_EC smtp_last_error=0; 
.................... int16 smtp_engine_port; 
....................  
.................... //user functions 
.................... int8 SMTPConnect(IP_ADDR *ip, int16 port, char *from, char *to, char *subject) { 
....................    if (smtp_socket==INVALID_SOCKET) { 
*
0916A:  MOVLB  1
0916C:  MOVF   x6C,W
0916E:  SUBLW  FE
09170:  BNZ   91B8
....................       smtp_state=SMTP_STATE_START; 
09172:  MOVLW  01
09174:  MOVWF  x6B
....................       memcpy(&smtp_remote.IPAddr, ip, sizeof(IP_ADDR)); 
09176:  MOVWF  FEA
09178:  MOVLW  73
0917A:  MOVWF  FE9
0917C:  MOVFF  362,FE2
09180:  MOVFF  361,FE1
09184:  MOVLW  04
09186:  MOVWF  01
09188:  MOVFF  FE6,FEE
0918C:  DECFSZ 01,F
0918E:  BRA    9188
....................       smtp_engine_port=port; 
09190:  MOVFF  364,17F
09194:  MOVFF  363,17E
....................       smtp_engine_from=from; 
09198:  MOVFF  366,178
0919C:  MOVFF  365,177
....................       smtp_engine_to=to; 
091A0:  MOVFF  368,17A
091A4:  MOVFF  367,179
....................       smtp_engine_subject=subject; 
091A8:  MOVFF  36A,17C
091AC:  MOVFF  369,17B
....................       smtp_last_error=0; 
091B0:  CLRF   x7D
....................       return(TRUE); 
091B2:  MOVLW  01
091B4:  MOVWF  01
091B6:  BRA    91C0
....................    } 
....................    smtp_last_error=SMTP_EC_CLOSE_PREVIOUS; 
091B8:  MOVLW  01
091BA:  MOVWF  x7D
....................    return(FALSE); 
091BC:  MOVLW  00
091BE:  MOVWF  01
.................... } 
091C0:  MOVLB  0
091C2:  GOTO   93F4 (RETURN)
....................  
.................... int8 SMTPIsFree(void) { 
....................    return(smtp_socket==INVALID_SOCKET); 
*
09236:  MOVLB  1
09238:  MOVF   x6C,W
0923A:  SUBLW  FE
0923C:  BZ    9242
0923E:  MOVLW  00
09240:  BRA    9244
09242:  MOVLW  01
09244:  MOVWF  01
.................... } 
09246:  MOVLB  0
09248:  GOTO   94E4 (RETURN)
....................  
.................... int8 SMTPIsPutReady(void) { 
....................    return((smtp_state==SMTP_STATE_PUT_BODY)&&(TCPIsPutReady(smtp_socket))); 
*
091D0:  MOVLB  1
091D2:  MOVF   x6B,W
091D4:  SUBLW  0D
091D6:  BNZ   91E8
091D8:  MOVFF  16C,369
091DC:  MOVLB  0
091DE:  CALL   63D0
091E2:  MOVF   01,F
091E4:  BNZ   91EC
091E6:  MOVLB  1
091E8:  MOVLW  00
091EA:  BRA    91F0
091EC:  MOVLW  01
091EE:  MOVLB  1
091F0:  MOVWF  01
.................... } 
091F2:  MOVLB  0
091F4:  RETLW  00
....................  
.................... void SMTPPut(char c) { 
....................    if (SMTPIsPutReady() && TCPIsPutReady(smtp_socket)) { 
091F6:  RCALL  91D0
091F8:  MOVF   01,F
091FA:  BZ    9214
091FC:  MOVFF  16C,369
09200:  CALL   63D0
09204:  MOVF   01,F
09206:  BZ    9214
....................       TCPPut(smtp_socket,c); 
09208:  MOVFF  16C,36C
0920C:  MOVFF  363,36D
09210:  CALL   6638
....................    } 
.................... } 
09214:  GOTO   94C2 (RETURN)
....................  
.................... void SMTPDisconnect(void) { 
....................    if (smtp_state==SMTP_STATE_PUT_BODY) 
09218:  MOVLB  1
0921A:  MOVF   x6B,W
0921C:  SUBLW  0D
0921E:  BNZ   9226
....................       smtp_state=SMTP_STATE_FINISH_EMAIL; 
09220:  MOVLW  0E
09222:  MOVWF  x6B
....................    else if (smtp_socket!=INVALID_SOCKET) 
09224:  BRA    9230
09226:  MOVF   x6C,W
09228:  SUBLW  FE
0922A:  BZ    9230
....................       smtp_state=SMTP_STATE_CLOSE; 
0922C:  MOVLW  10
0922E:  MOVWF  x6B
.................... } 
09230:  MOVLB  0
09232:  GOTO   94D8 (RETURN)
....................  
.................... SMTP_EC SMTPLastError(void) { 
....................    return(smtp_last_error); 
*
091C6:  MOVLB  1
091C8:  MOVFF  17D,01
.................... } 
091CC:  MOVLB  0
091CE:  RETLW  00
....................  
.................... //stack functions 
.................... void SMTPInit(void) { 
....................    if (smtp_socket!=INVALID_SOCKET) { 
*
02BCC:  MOVLB  1
02BCE:  MOVF   x6C,W
02BD0:  SUBLW  FE
02BD2:  BZ    2BDE
....................       TCPDisconnect(smtp_socket); 
02BD4:  MOVFF  16C,369
02BD8:  MOVLB  0
02BDA:  RCALL  2A92
02BDC:  MOVLB  1
....................    } 
....................    smtp_socket=INVALID_SOCKET; 
02BDE:  MOVLW  FE
02BE0:  MOVWF  x6C
....................    smtp_state=SMTP_STATE_WAITING; 
02BE2:  CLRF   x6B
.................... } 
02BE4:  MOVLB  0
02BE6:  RETLW  00
....................  
.................... void SMTPError(SMTP_EC ec) { 
....................    smtp_last_error=ec; 
*
060F2:  MOVFF  369,17D
....................    smtp_state=SMTP_STATE_RESET; 
060F6:  MOVLW  12
060F8:  MOVLB  1
060FA:  MOVWF  x6B
.................... } 
060FC:  MOVLB  0
060FE:  RETLW  00
....................  
.................... void SMTPPutCmd(char c) { 
....................    TCPPut(smtp_socket,c); 
*
06782:  MOVFF  16C,36C
06786:  MOVFF  36B,36D
0678A:  RCALL  6638
.................... } 
0678C:  RETLW  00
....................  
....................  
.................... void SMTPTask(void) { 
....................    TICKTYPE currTick; 
....................    static TICKTYPE lastTick; 
....................    int16 smtp_result; 
....................    static int16 smtp_expected_result; 
....................  
....................    static char ehlomsg[]="ehlo me"; 
....................    static char datamsg[]="data"; 
....................    static char mailfrommsg[]="mail from: "; 
....................    static char rcpttomsg[]="rcpt to: "; 
....................  
....................    static char *cmdptr; 
....................    static char *cmdptr2; 
....................    static SMTP_EC on_err; 
....................    static int8 next_state; 
....................  
....................    currTick=TickGet(); 
*
06940:  CALL   514A
06944:  MOVFF  02,366
06948:  MOVFF  01,365
....................  
....................    switch(smtp_state) { 
0694C:  MOVLB  1
0694E:  MOVF   x6B,W
06950:  ADDLW  ED
06952:  BTFSC  FD8.0
06954:  GOTO   7262
06958:  ADDLW  13
0695A:  MOVLB  0
0695C:  GOTO   7268
....................       case SMTP_STATE_WAITING: 
....................          break; 
06960:  MOVLB  1
06962:  GOTO   7262
....................  
....................       case SMTP_STATE_START: 
....................          lastTick=currTick; 
06966:  MOVFF  366,181
0696A:  MOVFF  365,180
....................          smtp_state=SMTP_STATE_ARP_REQ; 
0696E:  MOVLW  02
06970:  MOVLB  1
06972:  MOVWF  x6B
06974:  MOVLB  0
....................  
....................    #if STACK_USE_ARP 
....................       case SMTP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
06976:  MOVLW  01
06978:  MOVLB  3
0697A:  MOVWF  xEB
0697C:  MOVLB  0
0697E:  CALL   1AC0
06982:  MOVF   01,F
06984:  BZ    69A6
....................             ARPResolve(&smtp_remote.IPAddr); 
06986:  MOVLW  01
06988:  MOVLB  3
0698A:  MOVWF  x7F
0698C:  MOVLW  73
0698E:  MOVWF  x7E
06990:  MOVLB  0
06992:  CALL   60B4
....................             lastTick=currTick; 
06996:  MOVFF  366,181
0699A:  MOVFF  365,180
....................             smtp_state=SMTP_STATE_ARP_WAIT; 
0699E:  MOVLW  03
069A0:  MOVLB  1
069A2:  MOVWF  x6B
....................          } 
....................          else if (TickGetDiff(currTick,lastTick) > (TICKS_PER_SECOND / 2)) { 
069A4:  BRA    6A20
069A6:  MOVLB  3
069A8:  MOVF   x66,W
069AA:  MOVLB  1
069AC:  SUBWF  x81,W
069AE:  BNC   69C2
069B0:  BNZ   69C6
069B2:  MOVF   x80,W
069B4:  MOVLB  3
069B6:  SUBWF  x65,W
069B8:  BTFSC  FD8.0
069BA:  BRA    69C0
069BC:  MOVLB  1
069BE:  BRA    69C6
069C0:  MOVLB  1
069C2:  MOVLW  00
069C4:  BRA    69C8
069C6:  MOVLW  01
069C8:  CLRF   03
069CA:  IORWF  03,W
069CC:  BZ    69FC
069CE:  MOVLW  FF
069D0:  BSF    FD8.0
069D2:  SUBFWB x80,W
069D4:  MOVLB  3
069D6:  MOVWF  x69
069D8:  MOVLW  FF
069DA:  MOVLB  1
069DC:  SUBFWB x81,W
069DE:  MOVLB  3
069E0:  MOVWF  x6A
069E2:  MOVF   x65,W
069E4:  ADDWF  x69,F
069E6:  MOVF   x66,W
069E8:  ADDWFC x6A,F
069EA:  MOVLW  01
069EC:  ADDWF  x69,W
069EE:  MOVWF  01
069F0:  MOVLW  00
069F2:  ADDWFC x6A,W
069F4:  MOVWF  03
069F6:  MOVF   01,W
069F8:  BRA    6A10
069FA:  MOVLB  1
069FC:  MOVF   x80,W
069FE:  MOVLB  3
06A00:  SUBWF  x65,W
06A02:  MOVWF  00
06A04:  MOVLB  1
06A06:  MOVF   x81,W
06A08:  MOVLB  3
06A0A:  SUBWFB x66,W
06A0C:  MOVWF  03
06A0E:  MOVF   00,W
06A10:  SUBLW  05
06A12:  BC    6A1E
....................             SMTPError(SMTP_EC_MAC_TX_FAIL); 
06A14:  MOVLW  02
06A16:  MOVWF  x69
06A18:  MOVLB  0
06A1A:  CALL   60F2
06A1E:  MOVLB  1
....................          } 
....................          break; 
06A20:  GOTO   7262
....................  
....................       case SMTP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&smtp_remote.IPAddr, &smtp_remote.MACAddr)) { 
06A24:  MOVLW  01
06A26:  MOVLB  3
06A28:  MOVWF  x7F
06A2A:  MOVLW  73
06A2C:  MOVWF  x7E
06A2E:  MOVLW  01
06A30:  MOVWF  x81
06A32:  MOVLW  6D
06A34:  MOVWF  x80
06A36:  MOVLB  0
06A38:  CALL   6100
06A3C:  MOVF   01,F
06A3E:  BZ    6A48
....................             smtp_state=SMTP_STATE_CONNECT; 
06A40:  MOVLW  04
06A42:  MOVLB  1
06A44:  MOVWF  x6B
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * (TICKTYPE)5)) { 
06A46:  BRA    6AC2
06A48:  MOVLB  3
06A4A:  MOVF   x66,W
06A4C:  MOVLB  1
06A4E:  SUBWF  x81,W
06A50:  BNC   6A64
06A52:  BNZ   6A68
06A54:  MOVF   x80,W
06A56:  MOVLB  3
06A58:  SUBWF  x65,W
06A5A:  BTFSC  FD8.0
06A5C:  BRA    6A62
06A5E:  MOVLB  1
06A60:  BRA    6A68
06A62:  MOVLB  1
06A64:  MOVLW  00
06A66:  BRA    6A6A
06A68:  MOVLW  01
06A6A:  CLRF   03
06A6C:  IORWF  03,W
06A6E:  BZ    6A9E
06A70:  MOVLW  FF
06A72:  BSF    FD8.0
06A74:  SUBFWB x80,W
06A76:  MOVLB  3
06A78:  MOVWF  x69
06A7A:  MOVLW  FF
06A7C:  MOVLB  1
06A7E:  SUBFWB x81,W
06A80:  MOVLB  3
06A82:  MOVWF  x6A
06A84:  MOVF   x65,W
06A86:  ADDWF  x69,F
06A88:  MOVF   x66,W
06A8A:  ADDWFC x6A,F
06A8C:  MOVLW  01
06A8E:  ADDWF  x69,W
06A90:  MOVWF  01
06A92:  MOVLW  00
06A94:  ADDWFC x6A,W
06A96:  MOVWF  03
06A98:  MOVF   01,W
06A9A:  BRA    6AB2
06A9C:  MOVLB  1
06A9E:  MOVF   x80,W
06AA0:  MOVLB  3
06AA2:  SUBWF  x65,W
06AA4:  MOVWF  00
06AA6:  MOVLB  1
06AA8:  MOVF   x81,W
06AAA:  MOVLB  3
06AAC:  SUBWFB x66,W
06AAE:  MOVWF  03
06AB0:  MOVF   00,W
06AB2:  SUBLW  32
06AB4:  BC    6AC0
....................             SMTPError(SMTP_EC_ARP_FAIL); 
06AB6:  MOVLW  03
06AB8:  MOVWF  x69
06ABA:  MOVLB  0
06ABC:  CALL   60F2
06AC0:  MOVLB  1
....................          } 
....................          break; 
06AC2:  GOTO   7262
....................    #else     
....................       case SMTP_STATE_ARP_REQ: 
....................       case SMTP_STATE_ARP_WAIT: 
....................          smtp_state=SMTP_STATE_CONNECT; 
....................    #endif 
....................  
....................  
....................       case SMTP_STATE_CONNECT: 
....................          smtp_socket=TCPConnect(&smtp_remote, smtp_engine_port); 
06AC6:  MOVLW  01
06AC8:  MOVLB  3
06ACA:  MOVWF  x6A
06ACC:  MOVLW  6D
06ACE:  MOVWF  x69
06AD0:  MOVFF  17F,36C
06AD4:  MOVFF  17E,36B
06AD8:  MOVLB  0
06ADA:  GOTO   6180
06ADE:  MOVFF  01,16C
....................          if (smtp_socket!=INVALID_SOCKET) { 
06AE2:  MOVLB  1
06AE4:  MOVF   x6C,W
06AE6:  SUBLW  FE
06AE8:  BZ    6AF8
....................             lastTick=currTick; 
06AEA:  MOVFF  366,181
06AEE:  MOVFF  365,180
....................             smtp_state=SMTP_STATE_CONNECT_WAIT; 
06AF2:  MOVLW  05
06AF4:  MOVWF  x6B
....................          } 
....................          else { 
06AF6:  BRA    6B06
....................             SMTPError(SMTP_EC_INVALID_SOCKET); 
06AF8:  MOVLW  04
06AFA:  MOVLB  3
06AFC:  MOVWF  x69
06AFE:  MOVLB  0
06B00:  CALL   60F2
06B04:  MOVLB  1
....................          } 
....................          break; 
06B06:  GOTO   7262
....................  
....................       case SMTP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(smtp_socket)) { 
06B0A:  MOVFF  16C,369
06B0E:  BRA    6398
06B10:  MOVF   01,F
06B12:  BZ    6B36
....................             smtp_state=SMTP_STATE_DO_CMD_GET_RESP; 
06B14:  MOVLW  0B
06B16:  MOVLB  1
06B18:  MOVWF  x6B
....................             smtp_expected_result=220; 
06B1A:  CLRF   x83
06B1C:  MOVLW  DC
06B1E:  MOVWF  x82
....................             next_state=SMTP_STATE_EHLO; 
06B20:  MOVLW  06
06B22:  MOVWF  xAC
....................             on_err=SMTP_EC_BAD_WELCOME; 
06B24:  MOVLW  0B
06B26:  MOVWF  xAB
....................             lastTick=currTick; 
06B28:  MOVFF  366,181
06B2C:  MOVFF  365,180
....................             SMTPReadResultCodeReset(); 
06B30:  MOVLB  0
06B32:  RCALL  63C4
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
06B34:  BRA    6BBA
06B36:  MOVLB  3
06B38:  MOVF   x66,W
06B3A:  MOVLB  1
06B3C:  SUBWF  x81,W
06B3E:  BNC   6B52
06B40:  BNZ   6B56
06B42:  MOVF   x80,W
06B44:  MOVLB  3
06B46:  SUBWF  x65,W
06B48:  BTFSC  FD8.0
06B4A:  BRA    6B50
06B4C:  MOVLB  1
06B4E:  BRA    6B56
06B50:  MOVLB  1
06B52:  MOVLW  00
06B54:  BRA    6B58
06B56:  MOVLW  01
06B58:  CLRF   03
06B5A:  IORWF  03,W
06B5C:  BZ    6B8C
06B5E:  MOVLW  FF
06B60:  BSF    FD8.0
06B62:  SUBFWB x80,W
06B64:  MOVLB  3
06B66:  MOVWF  x69
06B68:  MOVLW  FF
06B6A:  MOVLB  1
06B6C:  SUBFWB x81,W
06B6E:  MOVLB  3
06B70:  MOVWF  x6A
06B72:  MOVF   x65,W
06B74:  ADDWF  x69,F
06B76:  MOVF   x66,W
06B78:  ADDWFC x6A,F
06B7A:  MOVLW  01
06B7C:  ADDWF  x69,W
06B7E:  MOVWF  01
06B80:  MOVLW  00
06B82:  ADDWFC x6A,W
06B84:  MOVWF  03
06B86:  MOVF   01,W
06B88:  BRA    6BA0
06B8A:  MOVLB  1
06B8C:  MOVF   x80,W
06B8E:  MOVLB  3
06B90:  SUBWF  x65,W
06B92:  MOVWF  00
06B94:  MOVLB  1
06B96:  MOVF   x81,W
06B98:  MOVLB  3
06B9A:  SUBWFB x66,W
06B9C:  MOVWF  03
06B9E:  MOVF   00,W
06BA0:  MOVWF  x69
06BA2:  MOVFF  03,36A
06BA6:  MOVF   x6A,F
06BA8:  BNZ   6BB0
06BAA:  MOVF   x69,W
06BAC:  SUBLW  64
06BAE:  BC    6BBA
....................             SMTPError(SMTP_EC_CONNECT_FAIL); 
06BB0:  MOVLW  05
06BB2:  MOVWF  x69
06BB4:  MOVLB  0
06BB6:  CALL   60F2
....................          } 
....................          break; 
06BBA:  MOVLB  1
06BBC:  BRA    7262
....................  
....................       case SMTP_STATE_EHLO: 
....................          cmdptr=ehlomsg; 
06BBE:  MOVLW  01
06BC0:  MOVLB  1
06BC2:  MOVWF  xA8
06BC4:  MOVLW  84
06BC6:  MOVWF  xA7
....................          cmdptr2=0; 
06BC8:  CLRF   xAA
06BCA:  CLRF   xA9
....................          smtp_expected_result=250; 
06BCC:  CLRF   x83
06BCE:  MOVLW  FA
06BD0:  MOVWF  x82
....................          on_err=SMTP_EC_BAD_EHLO; 
06BD2:  MOVLW  06
06BD4:  MOVWF  xAB
....................          smtp_state=SMTP_STATE_DO_CMD; 
06BD6:  MOVLW  0A
06BD8:  MOVWF  x6B
....................          next_state=SMTP_STATE_MAIL_FROM; 
06BDA:  MOVLW  07
06BDC:  MOVWF  xAC
....................          lastTick=currTick; 
06BDE:  MOVFF  366,181
06BE2:  MOVFF  365,180
....................          break; 
06BE6:  BRA    7262
....................  
....................       case SMTP_STATE_MAIL_FROM: 
....................          cmdptr=mailfrommsg; 
06BE8:  MOVLW  01
06BEA:  MOVLB  1
06BEC:  MOVWF  xA8
06BEE:  MOVLW  91
06BF0:  MOVWF  xA7
....................          cmdptr2=smtp_engine_from; 
06BF2:  MOVFF  178,1AA
06BF6:  MOVFF  177,1A9
....................          smtp_expected_result=250; 
06BFA:  CLRF   x83
06BFC:  MOVLW  FA
06BFE:  MOVWF  x82
....................          on_err=SMTP_EC_BAD_MAILFROM; 
06C00:  MOVLW  07
06C02:  MOVWF  xAB
....................          smtp_state=SMTP_STATE_DO_CMD; 
06C04:  MOVLW  0A
06C06:  MOVWF  x6B
....................          next_state=SMTP_STATE_RCPT_TO; 
06C08:  MOVLW  08
06C0A:  MOVWF  xAC
....................          lastTick=currTick; 
06C0C:  MOVFF  366,181
06C10:  MOVFF  365,180
....................          break; 
06C14:  BRA    7262
....................  
....................       case SMTP_STATE_RCPT_TO: 
....................          cmdptr=rcpttomsg; 
06C16:  MOVLW  01
06C18:  MOVLB  1
06C1A:  MOVWF  xA8
06C1C:  MOVLW  9D
06C1E:  MOVWF  xA7
....................          cmdptr2=smtp_engine_to; 
06C20:  MOVFF  17A,1AA
06C24:  MOVFF  179,1A9
....................          smtp_expected_result=250; 
06C28:  CLRF   x83
06C2A:  MOVLW  FA
06C2C:  MOVWF  x82
....................          on_err=SMTP_EC_BAD_RCPTTO; 
06C2E:  MOVLW  08
06C30:  MOVWF  xAB
....................          smtp_state=SMTP_STATE_DO_CMD; 
06C32:  MOVLW  0A
06C34:  MOVWF  x6B
....................          next_state=SMTP_STATE_DATA_START; 
06C36:  MOVLW  09
06C38:  MOVWF  xAC
....................          lastTick=currTick; 
06C3A:  MOVFF  366,181
06C3E:  MOVFF  365,180
....................          break; 
06C42:  BRA    7262
....................  
....................       case SMTP_STATE_DATA_START: 
....................          cmdptr=datamsg; 
06C44:  MOVLW  01
06C46:  MOVLB  1
06C48:  MOVWF  xA8
06C4A:  MOVLW  8C
06C4C:  MOVWF  xA7
....................          cmdptr2=0; 
06C4E:  CLRF   xAA
06C50:  CLRF   xA9
....................          smtp_expected_result=354; 
06C52:  MOVLW  01
06C54:  MOVWF  x83
06C56:  MOVLW  62
06C58:  MOVWF  x82
....................          on_err=SMTP_EC_BAD_RCPTTO; 
06C5A:  MOVLW  08
06C5C:  MOVWF  xAB
....................          smtp_state=SMTP_STATE_DO_CMD; 
06C5E:  MOVLW  0A
06C60:  MOVWF  x6B
....................          next_state=SMTP_STATE_PUT_HEADER; 
06C62:  MOVLW  0C
06C64:  MOVWF  xAC
....................          lastTick=currTick; 
06C66:  MOVFF  366,181
06C6A:  MOVFF  365,180
....................          break; 
06C6E:  BRA    7262
....................  
....................       case SMTP_STATE_DO_CMD: 
....................          TCPDiscard(smtp_socket); 
06C70:  MOVFF  16C,36C
06C74:  CALL   1A74
....................          if (TCPIsPutReady(smtp_socket)) { 
06C78:  MOVFF  16C,369
06C7C:  CALL   63D0
06C80:  MOVF   01,F
06C82:  BZ    6D1A
....................            printf(SMTPPutCmd, "%s", cmdptr); 
06C84:  MOVFF  1A8,FEA
06C88:  MOVFF  1A7,FE9
06C8C:  MOVLW  00
06C8E:  IORWF  FEF,W
06C90:  BZ    6CB0
06C92:  MOVFF  FEA,36A
06C96:  MOVFF  FE9,369
06C9A:  MOVFF  FEF,36B
06C9E:  RCALL  6782
06CA0:  MOVFF  36A,FEA
06CA4:  MOVFF  369,FE9
06CA8:  INCF   FE9,F
06CAA:  BTFSC  FD8.2
06CAC:  INCF   FEA,F
06CAE:  BRA    6C8C
....................            if (cmdptr2) 
06CB0:  MOVLB  1
06CB2:  MOVF   xA9,W
06CB4:  IORWF  xAA,W
06CB6:  BZ    6CE8
....................               printf(SMTPPutCmd, "%s", cmdptr2); 
06CB8:  MOVFF  1AA,FEA
06CBC:  MOVFF  1A9,FE9
06CC0:  MOVLW  00
06CC2:  IORWF  FEF,W
06CC4:  BZ    6CE8
06CC6:  MOVFF  FEA,36A
06CCA:  MOVFF  FE9,369
06CCE:  MOVFF  FEF,36B
06CD2:  MOVLB  0
06CD4:  RCALL  6782
06CD6:  MOVFF  36A,FEA
06CDA:  MOVFF  369,FE9
06CDE:  INCF   FE9,F
06CE0:  BTFSC  FD8.2
06CE2:  INCF   FEA,F
06CE4:  MOVLB  1
06CE6:  BRA    6CC0
....................            SMTPPutCmd('\r'); 
06CE8:  MOVLW  0D
06CEA:  MOVLB  3
06CEC:  MOVWF  x6B
06CEE:  MOVLB  0
06CF0:  RCALL  6782
....................            SMTPPutCmd('\n'); 
06CF2:  MOVLW  0A
06CF4:  MOVLB  3
06CF6:  MOVWF  x6B
06CF8:  MOVLB  0
06CFA:  RCALL  6782
....................            TCPFlush(smtp_socket); 
06CFC:  MOVFF  16C,372
06D00:  CALL   646E
....................            smtp_state=SMTP_STATE_DO_CMD_GET_RESP; 
06D04:  MOVLW  0B
06D06:  MOVLB  1
06D08:  MOVWF  x6B
....................            lastTick=currTick; 
06D0A:  MOVFF  366,181
06D0E:  MOVFF  365,180
....................            SMTPReadResultCodeReset(); 
06D12:  MOVLB  0
06D14:  CALL   63C4
....................          } 
....................          else if (TickGetDiff(currTick,lastTick) > (TICKS_PER_SECOND / 2)) { 
06D18:  BRA    6D9E
06D1A:  MOVLB  3
06D1C:  MOVF   x66,W
06D1E:  MOVLB  1
06D20:  SUBWF  x81,W
06D22:  BNC   6D36
06D24:  BNZ   6D3A
06D26:  MOVF   x80,W
06D28:  MOVLB  3
06D2A:  SUBWF  x65,W
06D2C:  BTFSC  FD8.0
06D2E:  BRA    6D34
06D30:  MOVLB  1
06D32:  BRA    6D3A
06D34:  MOVLB  1
06D36:  MOVLW  00
06D38:  BRA    6D3C
06D3A:  MOVLW  01
06D3C:  CLRF   03
06D3E:  IORWF  03,W
06D40:  BZ    6D70
06D42:  MOVLW  FF
06D44:  BSF    FD8.0
06D46:  SUBFWB x80,W
06D48:  MOVLB  3
06D4A:  MOVWF  x69
06D4C:  MOVLW  FF
06D4E:  MOVLB  1
06D50:  SUBFWB x81,W
06D52:  MOVLB  3
06D54:  MOVWF  x6A
06D56:  MOVF   x65,W
06D58:  ADDWF  x69,F
06D5A:  MOVF   x66,W
06D5C:  ADDWFC x6A,F
06D5E:  MOVLW  01
06D60:  ADDWF  x69,W
06D62:  MOVWF  01
06D64:  MOVLW  00
06D66:  ADDWFC x6A,W
06D68:  MOVWF  03
06D6A:  MOVF   01,W
06D6C:  BRA    6D84
06D6E:  MOVLB  1
06D70:  MOVF   x80,W
06D72:  MOVLB  3
06D74:  SUBWF  x65,W
06D76:  MOVWF  00
06D78:  MOVLB  1
06D7A:  MOVF   x81,W
06D7C:  MOVLB  3
06D7E:  SUBWFB x66,W
06D80:  MOVWF  03
06D82:  MOVF   00,W
06D84:  MOVWF  x69
06D86:  MOVFF  03,36A
06D8A:  MOVF   x6A,F
06D8C:  BNZ   6D94
06D8E:  MOVF   x69,W
06D90:  SUBLW  05
06D92:  BC    6D9E
....................             SMTPError(SMTP_EC_MAC_TX_FAIL); 
06D94:  MOVLW  02
06D96:  MOVWF  x69
06D98:  MOVLB  0
06D9A:  CALL   60F2
....................          } 
....................          break; 
06D9E:  MOVLB  1
06DA0:  BRA    7262
....................  
....................       case SMTP_STATE_DO_CMD_GET_RESP: 
....................          if (TCPIsGetReady(smtp_socket)) { 
06DA2:  MOVFF  16C,369
06DA6:  RCALL  678E
06DA8:  MOVF   01,F
06DAA:  BZ    6DF6
....................             lastTick=currTick; 
06DAC:  MOVFF  366,181
06DB0:  MOVFF  365,180
....................             if (SMTPReadResultCode(&smtp_result)) { 
06DB4:  MOVLW  03
06DB6:  MOVLB  3
06DB8:  MOVWF  x6A
06DBA:  MOVLW  67
06DBC:  MOVWF  x69
06DBE:  MOVLB  0
06DC0:  BRA    6890
06DC2:  MOVF   01,F
06DC4:  BZ    6DF2
....................                if (smtp_result==smtp_expected_result) { 
06DC6:  MOVLB  1
06DC8:  MOVF   x82,W
06DCA:  MOVLB  3
06DCC:  SUBWF  x67,W
06DCE:  BNZ   6DE8
06DD0:  MOVLB  1
06DD2:  MOVF   x83,W
06DD4:  MOVLB  3
06DD6:  SUBWF  x68,W
06DD8:  BNZ   6DE8
....................                   lastTick=currTick; 
06DDA:  MOVFF  366,181
06DDE:  MOVFF  365,180
....................                   smtp_state=next_state; 
06DE2:  MOVFF  1AC,16B
....................                } 
....................                else { 
06DE6:  BRA    6DF4
....................                   SMTPError(on_err); 
06DE8:  MOVFF  1AB,369
06DEC:  MOVLB  0
06DEE:  CALL   60F2
06DF2:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * (TICKTYPE)10)) { 
06DF4:  BRA    6E6E
06DF6:  MOVLB  3
06DF8:  MOVF   x66,W
06DFA:  MOVLB  1
06DFC:  SUBWF  x81,W
06DFE:  BNC   6E12
06E00:  BNZ   6E16
06E02:  MOVF   x80,W
06E04:  MOVLB  3
06E06:  SUBWF  x65,W
06E08:  BTFSC  FD8.0
06E0A:  BRA    6E10
06E0C:  MOVLB  1
06E0E:  BRA    6E16
06E10:  MOVLB  1
06E12:  MOVLW  00
06E14:  BRA    6E18
06E16:  MOVLW  01
06E18:  CLRF   03
06E1A:  IORWF  03,W
06E1C:  BZ    6E4C
06E1E:  MOVLW  FF
06E20:  BSF    FD8.0
06E22:  SUBFWB x80,W
06E24:  MOVLB  3
06E26:  MOVWF  x69
06E28:  MOVLW  FF
06E2A:  MOVLB  1
06E2C:  SUBFWB x81,W
06E2E:  MOVLB  3
06E30:  MOVWF  x6A
06E32:  MOVF   x65,W
06E34:  ADDWF  x69,F
06E36:  MOVF   x66,W
06E38:  ADDWFC x6A,F
06E3A:  MOVLW  01
06E3C:  ADDWF  x69,W
06E3E:  MOVWF  01
06E40:  MOVLW  00
06E42:  ADDWFC x6A,W
06E44:  MOVWF  03
06E46:  MOVF   01,W
06E48:  BRA    6E60
06E4A:  MOVLB  1
06E4C:  MOVF   x80,W
06E4E:  MOVLB  3
06E50:  SUBWF  x65,W
06E52:  MOVWF  00
06E54:  MOVLB  1
06E56:  MOVF   x81,W
06E58:  MOVLB  3
06E5A:  SUBWFB x66,W
06E5C:  MOVWF  03
06E5E:  MOVF   00,W
06E60:  SUBLW  64
06E62:  BC    6E6E
....................             SMTPError(on_err); 
06E64:  MOVFF  1AB,369
06E68:  MOVLB  0
06E6A:  CALL   60F2
....................          } 
....................          break; 
06E6E:  MOVLB  1
06E70:  BRA    7262
....................  
....................       case SMTP_STATE_PUT_HEADER: 
....................          if (TCPIsPutReady(smtp_socket)) { 
06E72:  MOVFF  16C,369
06E76:  CALL   63D0
06E7A:  MOVF   01,F
06E7C:  BTFSC  FD8.2
06E7E:  BRA    6FC2
....................             printf(SMTPPutCmd, "To: %s\r\n", smtp_engine_to); 
06E80:  MOVLB  3
06E82:  CLRF   x69
06E84:  MOVF   x69,W
06E86:  MOVLB  0
06E88:  CALL   009E
06E8C:  MOVLB  3
06E8E:  INCF   x69,F
06E90:  MOVWF  00
06E92:  MOVWF  x6B
06E94:  MOVLB  0
06E96:  RCALL  6782
06E98:  MOVLW  04
06E9A:  MOVLB  3
06E9C:  SUBWF  x69,W
06E9E:  BNZ   6E84
06EA0:  MOVFF  17A,FEA
06EA4:  MOVFF  179,FE9
06EA8:  MOVLW  00
06EAA:  IORWF  FEF,W
06EAC:  BZ    6ED0
06EAE:  MOVFF  FEA,36A
06EB2:  MOVFF  FE9,369
06EB6:  MOVFF  FEF,36B
06EBA:  MOVLB  0
06EBC:  RCALL  6782
06EBE:  MOVFF  36A,FEA
06EC2:  MOVFF  369,FE9
06EC6:  INCF   FE9,F
06EC8:  BTFSC  FD8.2
06ECA:  INCF   FEA,F
06ECC:  MOVLB  3
06ECE:  BRA    6EA8
06ED0:  MOVLW  0D
06ED2:  MOVWF  x6B
06ED4:  MOVLB  0
06ED6:  RCALL  6782
06ED8:  MOVLW  0A
06EDA:  MOVLB  3
06EDC:  MOVWF  x6B
06EDE:  MOVLB  0
06EE0:  RCALL  6782
....................             printf(SMTPPutCmd, "From: %s\r\n", smtp_engine_from); 
06EE2:  MOVLB  3
06EE4:  CLRF   x69
06EE6:  MOVF   x69,W
06EE8:  MOVLB  0
06EEA:  CALL   00C2
06EEE:  MOVLB  3
06EF0:  INCF   x69,F
06EF2:  MOVWF  00
06EF4:  MOVWF  x6B
06EF6:  MOVLB  0
06EF8:  RCALL  6782
06EFA:  MOVLW  06
06EFC:  MOVLB  3
06EFE:  SUBWF  x69,W
06F00:  BNZ   6EE6
06F02:  MOVFF  178,FEA
06F06:  MOVFF  177,FE9
06F0A:  MOVLW  00
06F0C:  IORWF  FEF,W
06F0E:  BZ    6F32
06F10:  MOVFF  FEA,36A
06F14:  MOVFF  FE9,369
06F18:  MOVFF  FEF,36B
06F1C:  MOVLB  0
06F1E:  RCALL  6782
06F20:  MOVFF  36A,FEA
06F24:  MOVFF  369,FE9
06F28:  INCF   FE9,F
06F2A:  BTFSC  FD8.2
06F2C:  INCF   FEA,F
06F2E:  MOVLB  3
06F30:  BRA    6F0A
06F32:  MOVLW  0D
06F34:  MOVWF  x6B
06F36:  MOVLB  0
06F38:  RCALL  6782
06F3A:  MOVLW  0A
06F3C:  MOVLB  3
06F3E:  MOVWF  x6B
06F40:  MOVLB  0
06F42:  RCALL  6782
....................             printf(SMTPPutCmd, "Subject: %s\r\n", smtp_engine_subject); 
06F44:  MOVLB  3
06F46:  CLRF   x69
06F48:  MOVF   x69,W
06F4A:  MOVLB  0
06F4C:  CALL   00E8
06F50:  MOVLB  3
06F52:  INCF   x69,F
06F54:  MOVWF  00
06F56:  MOVWF  x6B
06F58:  MOVLB  0
06F5A:  RCALL  6782
06F5C:  MOVLW  09
06F5E:  MOVLB  3
06F60:  SUBWF  x69,W
06F62:  BNZ   6F48
06F64:  MOVFF  17C,FEA
06F68:  MOVFF  17B,FE9
06F6C:  MOVLW  00
06F6E:  IORWF  FEF,W
06F70:  BZ    6F94
06F72:  MOVFF  FEA,36A
06F76:  MOVFF  FE9,369
06F7A:  MOVFF  FEF,36B
06F7E:  MOVLB  0
06F80:  RCALL  6782
06F82:  MOVFF  36A,FEA
06F86:  MOVFF  369,FE9
06F8A:  INCF   FE9,F
06F8C:  BTFSC  FD8.2
06F8E:  INCF   FEA,F
06F90:  MOVLB  3
06F92:  BRA    6F6C
06F94:  MOVLW  0D
06F96:  MOVWF  x6B
06F98:  MOVLB  0
06F9A:  CALL   6782
06F9E:  MOVLW  0A
06FA0:  MOVLB  3
06FA2:  MOVWF  x6B
06FA4:  MOVLB  0
06FA6:  CALL   6782
....................             TCPFlush(smtp_socket); 
06FAA:  MOVFF  16C,372
06FAE:  CALL   646E
....................             smtp_state=SMTP_STATE_PUT_BODY; 
06FB2:  MOVLW  0D
06FB4:  MOVLB  1
06FB6:  MOVWF  x6B
....................             lastTick=currTick; 
06FB8:  MOVFF  366,181
06FBC:  MOVFF  365,180
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 3)) { 
06FC0:  BRA    7048
06FC2:  MOVLB  3
06FC4:  MOVF   x66,W
06FC6:  MOVLB  1
06FC8:  SUBWF  x81,W
06FCA:  BNC   6FDE
06FCC:  BNZ   6FE2
06FCE:  MOVF   x80,W
06FD0:  MOVLB  3
06FD2:  SUBWF  x65,W
06FD4:  BTFSC  FD8.0
06FD6:  BRA    6FDC
06FD8:  MOVLB  1
06FDA:  BRA    6FE2
06FDC:  MOVLB  1
06FDE:  MOVLW  00
06FE0:  BRA    6FE4
06FE2:  MOVLW  01
06FE4:  CLRF   03
06FE6:  IORWF  03,W
06FE8:  BZ    7018
06FEA:  MOVLW  FF
06FEC:  BSF    FD8.0
06FEE:  SUBFWB x80,W
06FF0:  MOVLB  3
06FF2:  MOVWF  x69
06FF4:  MOVLW  FF
06FF6:  MOVLB  1
06FF8:  SUBFWB x81,W
06FFA:  MOVLB  3
06FFC:  MOVWF  x6A
06FFE:  MOVF   x65,W
07000:  ADDWF  x69,F
07002:  MOVF   x66,W
07004:  ADDWFC x6A,F
07006:  MOVLW  01
07008:  ADDWF  x69,W
0700A:  MOVWF  01
0700C:  MOVLW  00
0700E:  ADDWFC x6A,W
07010:  MOVWF  03
07012:  MOVF   01,W
07014:  BRA    702C
07016:  MOVLB  1
07018:  MOVF   x80,W
0701A:  MOVLB  3
0701C:  SUBWF  x65,W
0701E:  MOVWF  00
07020:  MOVLB  1
07022:  MOVF   x81,W
07024:  MOVLB  3
07026:  SUBWFB x66,W
07028:  MOVWF  03
0702A:  MOVF   00,W
0702C:  MOVWF  x69
0702E:  MOVFF  03,36A
07032:  MOVF   x6A,F
07034:  BNZ   703C
07036:  MOVF   x69,W
07038:  SUBLW  1E
0703A:  BC    7046
....................             SMTPError(SMTP_EC_PUT_HEADER); 
0703C:  MOVLW  0A
0703E:  MOVWF  x69
07040:  MOVLB  0
07042:  CALL   60F2
07046:  MOVLB  1
....................          } 
....................          break; 
07048:  BRA    7262
....................  
....................       case SMTP_STATE_PUT_BODY: 
....................          //sit in an infinite loop here. 
....................          //now the user can add their own contents to the email by using SMTPPut(). 
....................          //but do a timeout check: 
....................          if (TCPIsGetReady(smtp_socket)) 
0704A:  MOVFF  16C,369
0704E:  CALL   678E
07052:  MOVF   01,F
07054:  BZ    705E
....................             TCPDiscard(smtp_socket); 
07056:  MOVFF  16C,36C
0705A:  CALL   1A74
....................          if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 60)) { 
0705E:  MOVLB  3
07060:  MOVF   x66,W
07062:  MOVLB  1
07064:  SUBWF  x81,W
07066:  BNC   707A
07068:  BNZ   707E
0706A:  MOVF   x80,W
0706C:  MOVLB  3
0706E:  SUBWF  x65,W
07070:  BTFSC  FD8.0
07072:  BRA    7078
07074:  MOVLB  1
07076:  BRA    707E
07078:  MOVLB  1
0707A:  MOVLW  00
0707C:  BRA    7080
0707E:  MOVLW  01
07080:  CLRF   03
07082:  IORWF  03,W
07084:  BZ    70B4
07086:  MOVLW  FF
07088:  BSF    FD8.0
0708A:  SUBFWB x80,W
0708C:  MOVLB  3
0708E:  MOVWF  x69
07090:  MOVLW  FF
07092:  MOVLB  1
07094:  SUBFWB x81,W
07096:  MOVLB  3
07098:  MOVWF  x6A
0709A:  MOVF   x65,W
0709C:  ADDWF  x69,F
0709E:  MOVF   x66,W
070A0:  ADDWFC x6A,F
070A2:  MOVLW  01
070A4:  ADDWF  x69,W
070A6:  MOVWF  01
070A8:  MOVLW  00
070AA:  ADDWFC x6A,W
070AC:  MOVWF  03
070AE:  MOVF   01,W
070B0:  BRA    70B2
070B2:  MOVLB  1
....................             smtp_state=SMTP_STATE_FINISH_EMAIL; 
....................          } 
....................          else 
....................             break; 
070B4:  BRA    7262
070B6:  MOVLB  0
....................  
....................       case SMTP_STATE_FINISH_EMAIL: 
....................          lastTick=currTick; 
070B8:  MOVFF  366,181
070BC:  MOVFF  365,180
....................          smtp_state=SMTP_STATE_FINISH_EMAIL_WAIT; 
070C0:  MOVLW  0F
070C2:  MOVLB  1
070C4:  MOVWF  x6B
070C6:  MOVLB  0
....................  
....................       case SMTP_STATE_FINISH_EMAIL_WAIT: 
....................          if (TCPIsPutReady(smtp_socket)) { 
070C8:  MOVFF  16C,369
070CC:  CALL   63D0
070D0:  MOVF   01,F
070D2:  BZ    713C
....................             SMTPPutCmd('\r'); 
070D4:  MOVLW  0D
070D6:  MOVLB  3
070D8:  MOVWF  x6B
070DA:  MOVLB  0
070DC:  CALL   6782
....................             SMTPPutCmd('\n'); 
070E0:  MOVLW  0A
070E2:  MOVLB  3
070E4:  MOVWF  x6B
070E6:  MOVLB  0
070E8:  CALL   6782
....................             SMTPPutCmd('.'); 
070EC:  MOVLW  2E
070EE:  MOVLB  3
070F0:  MOVWF  x6B
070F2:  MOVLB  0
070F4:  CALL   6782
....................             SMTPPutCmd('\r'); 
070F8:  MOVLW  0D
070FA:  MOVLB  3
070FC:  MOVWF  x6B
070FE:  MOVLB  0
07100:  CALL   6782
....................             SMTPPutCmd('\n'); 
07104:  MOVLW  0A
07106:  MOVLB  3
07108:  MOVWF  x6B
0710A:  MOVLB  0
0710C:  CALL   6782
....................             TCPFlush(smtp_socket); 
07110:  MOVFF  16C,372
07114:  CALL   646E
....................  
....................             smtp_state=SMTP_STATE_DO_CMD_GET_RESP; 
07118:  MOVLW  0B
0711A:  MOVLB  1
0711C:  MOVWF  x6B
....................             smtp_expected_result=250; 
0711E:  CLRF   x83
07120:  MOVLW  FA
07122:  MOVWF  x82
....................             next_state=SMTP_STATE_CLOSE; 
07124:  MOVLW  10
07126:  MOVWF  xAC
....................             on_err=SMTP_EC_BODY_NOT_ACCEPTED; 
07128:  MOVLW  0C
0712A:  MOVWF  xAB
....................             lastTick=currTick; 
0712C:  MOVFF  366,181
07130:  MOVFF  365,180
....................             SMTPReadResultCodeReset(); 
07134:  MOVLB  0
07136:  CALL   63C4
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 3)) { 
0713A:  BRA    71BC
0713C:  MOVLB  3
0713E:  MOVF   x66,W
07140:  MOVLB  1
07142:  SUBWF  x81,W
07144:  BNC   7158
07146:  BNZ   715C
07148:  MOVF   x80,W
0714A:  MOVLB  3
0714C:  SUBWF  x65,W
0714E:  BTFSC  FD8.0
07150:  BRA    7156
07152:  MOVLB  1
07154:  BRA    715C
07156:  MOVLB  1
07158:  MOVLW  00
0715A:  BRA    715E
0715C:  MOVLW  01
0715E:  CLRF   03
07160:  IORWF  03,W
07162:  BZ    7192
07164:  MOVLW  FF
07166:  BSF    FD8.0
07168:  SUBFWB x80,W
0716A:  MOVLB  3
0716C:  MOVWF  x69
0716E:  MOVLW  FF
07170:  MOVLB  1
07172:  SUBFWB x81,W
07174:  MOVLB  3
07176:  MOVWF  x6A
07178:  MOVF   x65,W
0717A:  ADDWF  x69,F
0717C:  MOVF   x66,W
0717E:  ADDWFC x6A,F
07180:  MOVLW  01
07182:  ADDWF  x69,W
07184:  MOVWF  01
07186:  MOVLW  00
07188:  ADDWFC x6A,W
0718A:  MOVWF  03
0718C:  MOVF   01,W
0718E:  BRA    71A6
07190:  MOVLB  1
07192:  MOVF   x80,W
07194:  MOVLB  3
07196:  SUBWF  x65,W
07198:  MOVWF  00
0719A:  MOVLB  1
0719C:  MOVF   x81,W
0719E:  MOVLB  3
071A0:  SUBWFB x66,W
071A2:  MOVWF  03
071A4:  MOVF   00,W
071A6:  MOVWF  x69
071A8:  MOVFF  03,36A
071AC:  MOVF   x6A,F
071AE:  BNZ   71B6
071B0:  MOVF   x69,W
071B2:  SUBLW  1E
071B4:  BC    71BC
....................             smtp_state=SMTP_STATE_FORCE_CLOSE; 
071B6:  MOVLW  11
071B8:  MOVLB  1
071BA:  MOVWF  x6B
....................          } 
....................          break; 
071BC:  MOVLB  1
071BE:  BRA    7262
....................  
....................       case SMTP_STATE_CLOSE: 
....................          if (TCPIsPutReady(smtp_socket)) { 
071C0:  MOVFF  16C,369
071C4:  CALL   63D0
071C8:  MOVF   01,F
071CA:  BZ    71D4
....................             smtp_state=SMTP_STATE_FORCE_CLOSE; 
071CC:  MOVLW  11
071CE:  MOVLB  1
071D0:  MOVWF  x6B
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 3)) { 
071D2:  BRA    724E
071D4:  MOVLB  3
071D6:  MOVF   x66,W
071D8:  MOVLB  1
071DA:  SUBWF  x81,W
071DC:  BNC   71F0
071DE:  BNZ   71F4
071E0:  MOVF   x80,W
071E2:  MOVLB  3
071E4:  SUBWF  x65,W
071E6:  BTFSC  FD8.0
071E8:  BRA    71EE
071EA:  MOVLB  1
071EC:  BRA    71F4
071EE:  MOVLB  1
071F0:  MOVLW  00
071F2:  BRA    71F6
071F4:  MOVLW  01
071F6:  CLRF   03
071F8:  IORWF  03,W
071FA:  BZ    722A
071FC:  MOVLW  FF
071FE:  BSF    FD8.0
07200:  SUBFWB x80,W
07202:  MOVLB  3
07204:  MOVWF  x69
07206:  MOVLW  FF
07208:  MOVLB  1
0720A:  SUBFWB x81,W
0720C:  MOVLB  3
0720E:  MOVWF  x6A
07210:  MOVF   x65,W
07212:  ADDWF  x69,F
07214:  MOVF   x66,W
07216:  ADDWFC x6A,F
07218:  MOVLW  01
0721A:  ADDWF  x69,W
0721C:  MOVWF  01
0721E:  MOVLW  00
07220:  ADDWFC x6A,W
07222:  MOVWF  03
07224:  MOVF   01,W
07226:  BRA    723E
07228:  MOVLB  1
0722A:  MOVF   x80,W
0722C:  MOVLB  3
0722E:  SUBWF  x65,W
07230:  MOVWF  00
07232:  MOVLB  1
07234:  MOVF   x81,W
07236:  MOVLB  3
07238:  SUBWFB x66,W
0723A:  MOVWF  03
0723C:  MOVF   00,W
0723E:  SUBLW  1E
07240:  BC    724A
....................             smtp_state=SMTP_STATE_FORCE_CLOSE; 
07242:  MOVLW  11
07244:  MOVLB  1
07246:  MOVWF  x6B
....................          } 
....................          else 
07248:  BRA    724E
....................             break; 
0724A:  MOVLB  1
0724C:  BRA    7262
0724E:  MOVLB  0
....................  
....................       case SMTP_STATE_FORCE_CLOSE: 
....................          TCPDisconnect(smtp_socket); 
07250:  MOVFF  16C,369
07254:  CALL   2A92
....................  
....................       case SMTP_STATE_RESET: 
....................          SMTPInit(); 
07258:  CALL   2BCC
....................          break; 
0725C:  MOVLB  1
0725E:  BRA    7262
07260:  MOVLB  1
....................    } 
.................... } 
07262:  MOVLB  0
07264:  GOTO   8A3E (RETURN)
....................  
.................... ///*** read result code 
....................  
.................... int16 smtp_result_code_scratch; 
.................... char smtp_result_code_fnnc;   //first non-numeric char 
....................  
.................... void SMTPReadResultCodeReset(void) { 
....................    smtp_result_code_scratch=0; 
*
063C4:  MOVLB  1
063C6:  CLRF   xAE
063C8:  CLRF   xAD
....................    smtp_result_code_fnnc=0; 
063CA:  CLRF   xAF
.................... } 
063CC:  MOVLB  0
063CE:  RETLW  00
....................  
.................... int8 SMTPReadResultCode(int16 *smtp_result) { 
....................    char c; 
....................    debugf_smtp("\r\nGet Result:\r\n"); 
....................    while (TCPGet(smtp_socket, &c)) { 
*
06890:  MOVFF  16C,36C
06894:  MOVLW  03
06896:  MOVLB  3
06898:  MOVWF  x6E
0689A:  MOVLW  6B
0689C:  MOVWF  x6D
0689E:  MOVLB  0
068A0:  BRA    67BA
068A2:  MOVF   01,F
068A4:  BZ    6938
....................       debugf_smtp("%c",c); 
....................       if ( (c>='0') && (c<='9') && (smtp_result_code_fnnc==0) ) { 
068A6:  MOVLB  3
068A8:  MOVF   x6B,W
068AA:  SUBLW  2F
068AC:  BC    68EE
068AE:  MOVF   x6B,W
068B0:  SUBLW  39
068B2:  BNC   68EE
068B4:  MOVLB  1
068B6:  MOVF   xAF,F
068B8:  BTFSC  FD8.2
068BA:  BRA    68C0
068BC:  MOVLB  3
068BE:  BRA    68EE
....................          smtp_result_code_scratch*=10; 
068C0:  MOVFF  1AE,3B7
068C4:  MOVFF  1AD,3B6
068C8:  MOVLB  3
068CA:  CLRF   xB9
068CC:  MOVLW  0A
068CE:  MOVWF  xB8
068D0:  MOVLB  0
068D2:  CALL   37E6
068D6:  MOVFF  02,1AE
068DA:  MOVFF  01,1AD
....................          smtp_result_code_scratch+=c-'0'; 
068DE:  MOVLW  30
068E0:  MOVLB  3
068E2:  SUBWF  x6B,W
068E4:  MOVLB  1
068E6:  ADDWF  xAD,F
068E8:  MOVLW  00
068EA:  ADDWFC xAE,F
....................       } 
....................       else if (smtp_result_code_fnnc==0) { 
068EC:  BRA    68F8
068EE:  MOVLB  1
068F0:  MOVF   xAF,F
068F2:  BNZ   68F8
....................          smtp_result_code_fnnc=c; 
068F4:  MOVFF  36B,1AF
....................       } 
....................       if (c==0x0A) { 
068F8:  MOVLB  3
068FA:  MOVF   x6B,W
068FC:  SUBLW  0A
068FE:  BNZ   6934
....................          if (smtp_result_code_fnnc==' ') { 
06900:  MOVLB  1
06902:  MOVF   xAF,W
06904:  SUBLW  20
06906:  BNZ   6930
....................             debugf_smtp("\r\nResult=%LU",smtp_result_code_scratch); 
....................             *smtp_result=smtp_result_code_scratch; 
06908:  MOVLB  3
0690A:  MOVFF  369,FE9
0690E:  MOVFF  36A,FEA
06912:  MOVFF  1AE,FEC
06916:  MOVF   FED,F
06918:  MOVFF  1AD,FEF
....................             TCPDiscard(smtp_socket); 
0691C:  MOVFF  16C,36C
06920:  MOVLB  0
06922:  CALL   1A74
....................             return(TRUE); 
06926:  MOVLW  01
06928:  MOVWF  01
0692A:  BRA    693C
....................          } 
....................          else { 
0692C:  BRA    6934
0692E:  MOVLB  1
....................             debugf_smtp("\r\nContinue"); 
....................             SMTPReadResultCodeReset(); //read next line (some commands have multi-line responses) 
06930:  MOVLB  0
06932:  RCALL  63C4
....................          } 
....................       } 
....................    } 
06934:  MOVLB  0
06936:  BRA    6890
....................    return(FALSE); 
06938:  MOVLW  00
0693A:  MOVWF  01
.................... } 
0693C:  GOTO   6DC2 (RETURN)
....................  
.................... ///*** read result code 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... /********************************************************************* 
....................  * 
....................  *   DNS Client Module for Microchip TCP/IP Stack 
....................  *    -Provides DNS resolution (client) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.c 
....................  * Dependencies:    UDP, ARP, Tick 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *               Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06   Original 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #include "tcpip/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ARPTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/DNS.h" 
.................... /********************************************************************* 
....................  * 
....................  *   DNS Client Module Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *               Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06  Original 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef DNS_H 
.................... #define DNS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... void   DNSResolve(BYTE *HostName); 
.................... BOOL   DNSIsResolved(IP_ADDR *HostIP); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
....................  
.................... #define DNS_PORT      53 
.................... #define DNS_TIMEOUT      (TICK_SECOND*2) 
....................  
....................  
.................... static BYTE *DNSHostName; 
.................... static enum 
.................... { 
....................    DNS_HOME = 0, 
....................    DNS_RESOLVE_ARP, 
....................    DNS_OPEN_SOCKET, 
....................    DNS_QUERY, 
....................    DNS_GET_RESULT, 
....................    DNS_DONE 
.................... } smDNS = DNS_DONE; 
....................  
.................... typedef struct _DNS_HEADER 
.................... { 
....................    WORD_VAL TransactionID; 
....................    WORD_VAL Flags; 
....................    WORD_VAL Questions; 
....................    WORD_VAL Answers; 
....................    WORD_VAL AuthoritativeRecords; 
....................    WORD_VAL AdditionalRecords; 
.................... } DNS_HEADER; 
....................  
.................... typedef struct _DNS_ANSWER_HEADER 
.................... { 
....................    WORD_VAL   ResponseName; 
....................    WORD_VAL   ResponseType; 
....................    WORD_VAL   ResponseClass; 
....................    DWORD_VAL   ResponseTTL; 
....................    WORD_VAL   ResponseLen; 
.................... } DNS_ANSWER_HEADER; 
....................  
.................... static void DNSPutString(BYTE *String); 
.................... static void DNSGetString(BYTE *String); 
....................  
.................... /********************************************************************* 
....................  * Function:        void DNSResolve(BYTE *Hostname) 
....................  * 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Input:           *Hostname: Null terminated string specifying the 
....................  *                        host address to resolve to an IP 
....................  *                        address. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Call DNSIsResolved() until the host is resolved. 
....................  * 
....................  * Note:            A UDP socket must be available before this 
....................  *               function is called.  It is freed at the end of 
....................  *               the resolution.  MAX_UDP_SOCKETS may need to be 
....................  *               increased if other modules use UDP sockets. 
....................  * 
....................  *               You must not modify *Hostname until DNSIsResolved() 
....................  *               returns TRUE. 
....................  ********************************************************************/ 
.................... void DNSResolve(BYTE *Hostname) 
.................... { 
....................    DNSHostName = Hostname; 
*
08A82:  MOVFF  362,1B1
08A86:  MOVFF  361,1B0
....................    smDNS = DNS_HOME; 
08A8A:  MOVLB  1
08A8C:  CLRF   xB2
.................... } 
08A8E:  MOVLB  0
08A90:  GOTO   932C (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL DNSIsResolved(IP_ADDR *HostIP) 
....................  * 
....................  * PreCondition:    DNSResolve() was called. 
....................  * 
....................  * Input:           HostIP: Pointer to IP_ADDR structure to store the 
....................  *                     returned host IP address when DNS 
....................  *                     resolution is complete. 
....................  * 
....................  * Output:          *HostIP, 4 byte IP address 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Call DNSIsResolved() until the host is resolved. 
....................  * 
....................  * Note:            You cannot start two DNS resolution proceedures 
....................  *               concurrently. 
....................  * 
....................  *               You must not modify *Hostname until DNSIsResolved() 
....................  *               returns TRUE. 
....................  ********************************************************************/ 
.................... BOOL DNSIsResolved(IP_ADDR *HostIP) 
.................... { 
....................    static UDP_SOCKET   MySocket; 
....................    static NODE_INFO   Remote; 
....................    static TICKTYPE         StartTime; 
....................    BYTE             i; 
....................    WORD_VAL         w; 
....................    DNS_HEADER         DNSHeader; 
....................    DNS_ANSWER_HEADER   DNSAnswerHeader; 
....................  
....................    switch(smDNS) 
....................    { 
*
08BCE:  MOVLB  1
08BD0:  MOVF   xB2,W
08BD2:  ADDLW  FA
08BD4:  BTFSC  FD8.0
08BD6:  BRA    9130
08BD8:  ADDLW  06
08BDA:  MOVLB  0
08BDC:  GOTO   913A
....................       case DNS_HOME: 
....................          Remote.IPAddr.Val = AppConfig.PrimaryDNSServer.Val; 
08BE0:  MOVFF  2D,1BD
08BE4:  MOVFF  2C,1BC
08BE8:  MOVFF  2B,1BB
08BEC:  MOVFF  2A,1BA
....................     #if STACK_USE_ARP 
....................          ARPResolve(&AppConfig.PrimaryDNSServer); 
08BF0:  MOVLB  3
08BF2:  CLRF   x7F
08BF4:  MOVLW  2A
08BF6:  MOVWF  x7E
08BF8:  MOVLB  0
08BFA:  CALL   60B4
....................          StartTime = TickGet(); 
08BFE:  CALL   514A
08C02:  MOVFF  02,1BF
08C06:  MOVFF  01,1BE
....................          smDNS++; 
08C0A:  MOVLB  1
08C0C:  INCF   xB2,F
....................          break; 
08C0E:  BRA    9130
....................           
....................       case DNS_RESOLVE_ARP: 
....................          if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &Remote.MACAddr)) 
08C10:  MOVLB  3
08C12:  CLRF   x7F
08C14:  MOVLW  2A
08C16:  MOVWF  x7E
08C18:  MOVLW  01
08C1A:  MOVWF  x81
08C1C:  MOVLW  B4
08C1E:  MOVWF  x80
08C20:  MOVLB  0
08C22:  CALL   6100
08C26:  MOVF   01,F
08C28:  BNZ   8CCA
....................          { 
....................             //if(TickGet() - StartTime > DNS_TIMEOUT) 
....................             if(TickGetDiff(TickGet(),StartTime) > DNS_TIMEOUT) 
08C2A:  CALL   514A
08C2E:  MOVFF  02,37F
08C32:  MOVFF  01,37E
08C36:  MOVLB  3
08C38:  MOVF   02,W
08C3A:  MOVLB  1
08C3C:  SUBWF  xBF,W
08C3E:  BNC   8C52
08C40:  BNZ   8C56
08C42:  MOVF   xBE,W
08C44:  MOVLB  3
08C46:  SUBWF  x7E,W
08C48:  BTFSC  FD8.0
08C4A:  BRA    8C50
08C4C:  MOVLB  1
08C4E:  BRA    8C56
08C50:  MOVLB  1
08C52:  MOVLW  00
08C54:  BRA    8C58
08C56:  MOVLW  01
08C58:  CLRF   03
08C5A:  IORWF  03,W
08C5C:  BZ    8C92
08C5E:  MOVLW  FF
08C60:  BSF    FD8.0
08C62:  SUBFWB xBE,W
08C64:  MOVLB  3
08C66:  MOVWF  x7E
08C68:  MOVLW  FF
08C6A:  MOVLB  1
08C6C:  SUBFWB xBF,W
08C6E:  MOVLB  3
08C70:  MOVWF  x7F
08C72:  MOVLB  0
08C74:  CALL   514A
08C78:  MOVF   01,W
08C7A:  MOVLB  3
08C7C:  ADDWF  x7E,F
08C7E:  MOVF   02,W
08C80:  ADDWFC x7F,F
08C82:  MOVLW  01
08C84:  ADDWF  x7E,W
08C86:  MOVWF  01
08C88:  MOVLW  00
08C8A:  ADDWFC x7F,W
08C8C:  MOVWF  03
08C8E:  MOVF   01,W
08C90:  BRA    8CB2
08C92:  MOVLB  0
08C94:  CALL   514A
08C98:  MOVFF  02,37F
08C9C:  MOVLB  1
08C9E:  MOVF   xBE,W
08CA0:  MOVLB  3
08CA2:  SUBWF  01,W
08CA4:  MOVWF  00
08CA6:  MOVLB  1
08CA8:  MOVF   xBF,W
08CAA:  MOVLB  3
08CAC:  SUBWFB 02,W
08CAE:  MOVWF  03
08CB0:  MOVF   00,W
08CB2:  MOVWF  x7E
08CB4:  MOVFF  03,37F
08CB8:  MOVF   x7F,F
08CBA:  BNZ   8CC2
08CBC:  MOVF   x7E,W
08CBE:  SUBLW  14
08CC0:  BC    8CC6
....................             { 
....................                smDNS--; 
08CC2:  MOVLB  1
08CC4:  DECF   xB2,F
....................             } 
....................             break; 
08CC6:  MOVLB  1
08CC8:  BRA    9130
....................          } 
....................          smDNS++; 
08CCA:  MOVLB  1
08CCC:  INCF   xB2,F
08CCE:  MOVLB  0
....................          // No need to break, we can immediately start resolution 
....................       #else 
....................          smDNS=DNS_OPEN_SOCKET; 
....................       #endif 
....................  
....................       case DNS_OPEN_SOCKET: 
....................          MySocket = UDPOpen(2000, &Remote, DNS_PORT); 
08CD0:  MOVLW  07
08CD2:  MOVLB  3
08CD4:  MOVWF  x7F
08CD6:  MOVLW  D0
08CD8:  MOVWF  x7E
08CDA:  MOVLW  01
08CDC:  MOVWF  x81
08CDE:  MOVLW  B4
08CE0:  MOVWF  x80
08CE2:  CLRF   x83
08CE4:  MOVLW  35
08CE6:  MOVWF  x82
08CE8:  MOVLB  0
08CEA:  CALL   7782
08CEE:  MOVFF  01,1B3
....................          if(MySocket == INVALID_UDP_SOCKET) 
08CF2:  MOVLB  1
08CF4:  INCFSZ xB3,W
08CF6:  BRA    8CFA
....................             break; 
08CF8:  BRA    9130
....................  
....................          smDNS++; 
08CFA:  INCF   xB2,F
08CFC:  MOVLB  0
....................          // No need to break, we can immediately start resolution 
....................  
....................       case DNS_QUERY: 
....................          //if (UDPIsGetReady(MySocket)) 
....................          //   UDPDiscard(); 
....................          if(!UDPIsPutReady(MySocket)) 
08CFE:  MOVFF  1B3,37E
08D02:  CALL   7848
08D06:  MOVF   01,F
08D08:  BNZ   8D0E
....................             break; 
08D0A:  MOVLB  1
08D0C:  BRA    9130
....................  
....................          // Put DNS query here 
....................          UDPPut(0x12);      // User chosen ID 
08D0E:  MOVLW  12
08D10:  MOVLB  3
08D12:  MOVWF  x85
08D14:  MOVLB  0
08D16:  CALL   79B4
....................          UDPPut(0x34); 
08D1A:  MOVLW  34
08D1C:  MOVLB  3
08D1E:  MOVWF  x85
08D20:  MOVLB  0
08D22:  CALL   79B4
....................          UDPPut(0x01);      // Standard query with recursion 
08D26:  MOVLW  01
08D28:  MOVLB  3
08D2A:  MOVWF  x85
08D2C:  MOVLB  0
08D2E:  CALL   79B4
....................          UDPPut(0x00); 
08D32:  MOVLB  3
08D34:  CLRF   x85
08D36:  MOVLB  0
08D38:  CALL   79B4
....................          UDPPut(0x00);      // 0x0001 questions 
08D3C:  MOVLB  3
08D3E:  CLRF   x85
08D40:  MOVLB  0
08D42:  CALL   79B4
....................          UDPPut(0x01); 
08D46:  MOVLW  01
08D48:  MOVLB  3
08D4A:  MOVWF  x85
08D4C:  MOVLB  0
08D4E:  CALL   79B4
....................          UDPPut(0x00);      // 0x0000 answers 
08D52:  MOVLB  3
08D54:  CLRF   x85
08D56:  MOVLB  0
08D58:  CALL   79B4
....................          UDPPut(0x00); 
08D5C:  MOVLB  3
08D5E:  CLRF   x85
08D60:  MOVLB  0
08D62:  CALL   79B4
....................          UDPPut(0x00);      // 0x0000 name server resource records 
08D66:  MOVLB  3
08D68:  CLRF   x85
08D6A:  MOVLB  0
08D6C:  CALL   79B4
....................          UDPPut(0x00); 
08D70:  MOVLB  3
08D72:  CLRF   x85
08D74:  MOVLB  0
08D76:  CALL   79B4
....................          UDPPut(0x00);      // 0x0000 additional records 
08D7A:  MOVLB  3
08D7C:  CLRF   x85
08D7E:  MOVLB  0
08D80:  CALL   79B4
....................          UDPPut(0x00); 
08D84:  MOVLB  3
08D86:  CLRF   x85
08D88:  MOVLB  0
08D8A:  CALL   79B4
....................  
....................          // Put hostname string to resolve 
....................          DNSPutString(DNSHostName); 
08D8E:  MOVFF  1B1,37F
08D92:  MOVFF  1B0,37E
08D96:  BRA    8A94
....................  
....................          UDPPut(0x00);      // Type: A (host address) 
08D98:  MOVLB  3
08D9A:  CLRF   x85
08D9C:  MOVLB  0
08D9E:  CALL   79B4
....................          UDPPut(0x01); 
08DA2:  MOVLW  01
08DA4:  MOVLB  3
08DA6:  MOVWF  x85
08DA8:  MOVLB  0
08DAA:  CALL   79B4
....................          UDPPut(0x00);      // Class: IN (Internet) 
08DAE:  MOVLB  3
08DB0:  CLRF   x85
08DB2:  MOVLB  0
08DB4:  CALL   79B4
....................          UDPPut(0x01); 
08DB8:  MOVLW  01
08DBA:  MOVLB  3
08DBC:  MOVWF  x85
08DBE:  MOVLB  0
08DC0:  CALL   79B4
....................  
....................          UDPFlush(); 
08DC4:  CALL   785C
....................          StartTime = TickGet(); 
08DC8:  CALL   514A
08DCC:  MOVFF  02,1BF
08DD0:  MOVFF  01,1BE
....................          smDNS++; 
08DD4:  MOVLB  1
08DD6:  INCF   xB2,F
....................          break; 
08DD8:  BRA    9130
....................  
....................       case DNS_GET_RESULT: 
....................          if(!UDPIsGetReady(MySocket)) 
08DDA:  MOVFF  1B3,37E
08DDE:  CALL   7CE4
08DE2:  MOVF   01,F
08DE4:  BNZ   8E7E
....................          { 
....................             //if(TickGet() - StartTime > DNS_TIMEOUT) 
....................             if(TickGetDiff(TickGet(),StartTime) > DNS_TIMEOUT) 
08DE6:  CALL   514A
08DEA:  MOVFF  02,37F
08DEE:  MOVFF  01,37E
08DF2:  MOVLB  3
08DF4:  MOVF   02,W
08DF6:  MOVLB  1
08DF8:  SUBWF  xBF,W
08DFA:  BNC   8E0E
08DFC:  BNZ   8E12
08DFE:  MOVF   xBE,W
08E00:  MOVLB  3
08E02:  SUBWF  x7E,W
08E04:  BTFSC  FD8.0
08E06:  BRA    8E0C
08E08:  MOVLB  1
08E0A:  BRA    8E12
08E0C:  MOVLB  1
08E0E:  MOVLW  00
08E10:  BRA    8E14
08E12:  MOVLW  01
08E14:  CLRF   03
08E16:  IORWF  03,W
08E18:  BZ    8E4E
08E1A:  MOVLW  FF
08E1C:  BSF    FD8.0
08E1E:  SUBFWB xBE,W
08E20:  MOVLB  3
08E22:  MOVWF  x7E
08E24:  MOVLW  FF
08E26:  MOVLB  1
08E28:  SUBFWB xBF,W
08E2A:  MOVLB  3
08E2C:  MOVWF  x7F
08E2E:  MOVLB  0
08E30:  CALL   514A
08E34:  MOVF   01,W
08E36:  MOVLB  3
08E38:  ADDWF  x7E,F
08E3A:  MOVF   02,W
08E3C:  ADDWFC x7F,F
08E3E:  MOVLW  01
08E40:  ADDWF  x7E,W
08E42:  MOVWF  01
08E44:  MOVLW  00
08E46:  ADDWFC x7F,W
08E48:  MOVWF  03
08E4A:  MOVF   01,W
08E4C:  BRA    8E72
08E4E:  MOVLB  0
08E50:  CALL   514A
08E54:  MOVFF  02,37F
08E58:  MOVFF  01,37E
08E5C:  MOVLB  1
08E5E:  MOVF   xBE,W
08E60:  MOVLB  3
08E62:  SUBWF  01,W
08E64:  MOVWF  00
08E66:  MOVLB  1
08E68:  MOVF   xBF,W
08E6A:  MOVLB  3
08E6C:  SUBWFB 02,W
08E6E:  MOVWF  03
08E70:  MOVF   00,W
08E72:  SUBLW  14
08E74:  BC    8E7A
....................             { 
....................                smDNS--; 
08E76:  MOVLB  1
08E78:  DECF   xB2,F
....................             } 
....................             break; 
08E7A:  MOVLB  1
08E7C:  BRA    9130
....................          } 
....................  
....................          // Retrieve the DNS header and de-big-endian it 
....................          UDPGet(&DNSHeader.TransactionID.v[1]); 
08E7E:  MOVLW  03
08E80:  MOVLB  3
08E82:  MOVWF  x83
08E84:  MOVLW  67
08E86:  MOVWF  x82
08E88:  MOVLB  0
08E8A:  CALL   7D2A
....................          UDPGet(&DNSHeader.TransactionID.v[0]); 
08E8E:  MOVLW  03
08E90:  MOVLB  3
08E92:  MOVWF  x83
08E94:  MOVLW  66
08E96:  MOVWF  x82
08E98:  MOVLB  0
08E9A:  CALL   7D2A
....................          UDPGet(&DNSHeader.Flags.v[1]); 
08E9E:  MOVLW  03
08EA0:  MOVLB  3
08EA2:  MOVWF  x83
08EA4:  MOVLW  69
08EA6:  MOVWF  x82
08EA8:  MOVLB  0
08EAA:  CALL   7D2A
....................          UDPGet(&DNSHeader.Flags.v[0]); 
08EAE:  MOVLW  03
08EB0:  MOVLB  3
08EB2:  MOVWF  x83
08EB4:  MOVLW  68
08EB6:  MOVWF  x82
08EB8:  MOVLB  0
08EBA:  CALL   7D2A
....................          UDPGet(&DNSHeader.Questions.v[1]); 
08EBE:  MOVLW  03
08EC0:  MOVLB  3
08EC2:  MOVWF  x83
08EC4:  MOVLW  6B
08EC6:  MOVWF  x82
08EC8:  MOVLB  0
08ECA:  CALL   7D2A
....................          UDPGet(&DNSHeader.Questions.v[0]); 
08ECE:  MOVLW  03
08ED0:  MOVLB  3
08ED2:  MOVWF  x83
08ED4:  MOVLW  6A
08ED6:  MOVWF  x82
08ED8:  MOVLB  0
08EDA:  CALL   7D2A
....................          UDPGet(&DNSHeader.Answers.v[1]); 
08EDE:  MOVLW  03
08EE0:  MOVLB  3
08EE2:  MOVWF  x83
08EE4:  MOVLW  6D
08EE6:  MOVWF  x82
08EE8:  MOVLB  0
08EEA:  CALL   7D2A
....................          UDPGet(&DNSHeader.Answers.v[0]); 
08EEE:  MOVLW  03
08EF0:  MOVLB  3
08EF2:  MOVWF  x83
08EF4:  MOVLW  6C
08EF6:  MOVWF  x82
08EF8:  MOVLB  0
08EFA:  CALL   7D2A
....................          UDPGet(&DNSHeader.AuthoritativeRecords.v[1]); 
08EFE:  MOVLW  03
08F00:  MOVLB  3
08F02:  MOVWF  x83
08F04:  MOVLW  6F
08F06:  MOVWF  x82
08F08:  MOVLB  0
08F0A:  CALL   7D2A
....................          UDPGet(&DNSHeader.AuthoritativeRecords.v[0]); 
08F0E:  MOVLW  03
08F10:  MOVLB  3
08F12:  MOVWF  x83
08F14:  MOVLW  6E
08F16:  MOVWF  x82
08F18:  MOVLB  0
08F1A:  CALL   7D2A
....................          UDPGet(&DNSHeader.AdditionalRecords.v[1]); 
08F1E:  MOVLW  03
08F20:  MOVLB  3
08F22:  MOVWF  x83
08F24:  MOVLW  71
08F26:  MOVWF  x82
08F28:  MOVLB  0
08F2A:  CALL   7D2A
....................          UDPGet(&DNSHeader.AdditionalRecords.v[0]); 
08F2E:  MOVLW  03
08F30:  MOVLB  3
08F32:  MOVWF  x83
08F34:  MOVLW  70
08F36:  MOVWF  x82
08F38:  MOVLB  0
08F3A:  CALL   7D2A
....................  
....................  
....................          // Remove all questions 
....................          //while(DNSHeader.Questions.Val--) 
....................          while(DNSHeader.Questions.Val) 
....................          { 
08F3E:  MOVLB  3
08F40:  MOVF   x6A,W
08F42:  IORWF  x6B,W
08F44:  BZ    8F9A
....................             DNSHeader.Questions.Val-=1; 
08F46:  MOVLW  01
08F48:  SUBWF  x6A,F
08F4A:  MOVLW  00
08F4C:  SUBWFB x6B,F
....................             DNSGetString(NULL); 
08F4E:  CLRF   x7F
08F50:  CLRF   x7E
08F52:  MOVLB  0
08F54:  BRA    8B36
....................             UDPGet(&w.v[1]);      // Question type 
08F56:  MOVLW  03
08F58:  MOVLB  3
08F5A:  MOVWF  x83
08F5C:  MOVLW  65
08F5E:  MOVWF  x82
08F60:  MOVLB  0
08F62:  CALL   7D2A
....................             UDPGet(&w.v[0]); 
08F66:  MOVLW  03
08F68:  MOVLB  3
08F6A:  MOVWF  x83
08F6C:  MOVLW  64
08F6E:  MOVWF  x82
08F70:  MOVLB  0
08F72:  CALL   7D2A
....................             UDPGet(&w.v[1]);      // Question class 
08F76:  MOVLW  03
08F78:  MOVLB  3
08F7A:  MOVWF  x83
08F7C:  MOVLW  65
08F7E:  MOVWF  x82
08F80:  MOVLB  0
08F82:  CALL   7D2A
....................             UDPGet(&w.v[0]); 
08F86:  MOVLW  03
08F88:  MOVLB  3
08F8A:  MOVWF  x83
08F8C:  MOVLW  64
08F8E:  MOVWF  x82
08F90:  MOVLB  0
08F92:  CALL   7D2A
....................          } 
08F96:  BRA    8F3E
08F98:  MOVLB  3
....................  
....................  
....................          // Scan through answers 
....................          //while(DNSHeader.Answers.Val--) 
....................          while(DNSHeader.Answers.Val) 
....................          { 
08F9A:  MOVF   x6C,W
08F9C:  IORWF  x6D,W
08F9E:  BTFSC  FD8.2
08FA0:  BRA    9110
....................             DNSHeader.Answers.Val-=1; 
08FA2:  MOVLW  01
08FA4:  SUBWF  x6C,F
08FA6:  MOVLW  00
08FA8:  SUBWFB x6D,F
....................             UDPGet(&DNSAnswerHeader.ResponseName.v[1]);      // Response name 
08FAA:  MOVLW  03
08FAC:  MOVWF  x83
08FAE:  MOVLW  73
08FB0:  MOVWF  x82
08FB2:  MOVLB  0
08FB4:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseName.v[0]); 
08FB8:  MOVLW  03
08FBA:  MOVLB  3
08FBC:  MOVWF  x83
08FBE:  MOVLW  72
08FC0:  MOVWF  x82
08FC2:  MOVLB  0
08FC4:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseType.v[1]);      // Response type 
08FC8:  MOVLW  03
08FCA:  MOVLB  3
08FCC:  MOVWF  x83
08FCE:  MOVLW  75
08FD0:  MOVWF  x82
08FD2:  MOVLB  0
08FD4:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseType.v[0]); 
08FD8:  MOVLW  03
08FDA:  MOVLB  3
08FDC:  MOVWF  x83
08FDE:  MOVLW  74
08FE0:  MOVWF  x82
08FE2:  MOVLB  0
08FE4:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);   // Response class 
08FE8:  MOVLW  03
08FEA:  MOVLB  3
08FEC:  MOVWF  x83
08FEE:  MOVLW  77
08FF0:  MOVWF  x82
08FF2:  MOVLB  0
08FF4:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseClass.v[0]); 
08FF8:  MOVLW  03
08FFA:  MOVLB  3
08FFC:  MOVWF  x83
08FFE:  MOVLW  76
09000:  MOVWF  x82
09002:  MOVLB  0
09004:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);      // Time to live 
09008:  MOVLW  03
0900A:  MOVLB  3
0900C:  MOVWF  x83
0900E:  MOVLW  7B
09010:  MOVWF  x82
09012:  MOVLB  0
09014:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]); 
09018:  MOVLW  03
0901A:  MOVLB  3
0901C:  MOVWF  x83
0901E:  MOVLW  7A
09020:  MOVWF  x82
09022:  MOVLB  0
09024:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]); 
09028:  MOVLW  03
0902A:  MOVLB  3
0902C:  MOVWF  x83
0902E:  MOVLW  79
09030:  MOVWF  x82
09032:  MOVLB  0
09034:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]); 
09038:  MOVLW  03
0903A:  MOVLB  3
0903C:  MOVWF  x83
0903E:  MOVLW  78
09040:  MOVWF  x82
09042:  MOVLB  0
09044:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);      // Response length 
09048:  MOVLW  03
0904A:  MOVLB  3
0904C:  MOVWF  x83
0904E:  MOVLW  7D
09050:  MOVWF  x82
09052:  MOVLB  0
09054:  CALL   7D2A
....................             UDPGet(&DNSAnswerHeader.ResponseLen.v[0]); 
09058:  MOVLW  03
0905A:  MOVLB  3
0905C:  MOVWF  x83
0905E:  MOVLW  7C
09060:  MOVWF  x82
09062:  MOVLB  0
09064:  CALL   7D2A
....................  
....................             // Make sure that this is a 4 byte IP address, response type A, class 1 
....................             // Check if this is Type A 
....................             if(   DNSAnswerHeader.ResponseType.Val   == 0x0001 && 
....................                DNSAnswerHeader.ResponseClass.Val   == 0x0001 && // Internet class 
....................                DNSAnswerHeader.ResponseLen.Val      == 0x0004) 
09068:  MOVLB  3
0906A:  DECFSZ x74,W
0906C:  BRA    90EE
0906E:  MOVF   x75,F
09070:  BNZ   90EE
09072:  DECFSZ x76,W
09074:  BRA    90EE
09076:  MOVF   x77,F
09078:  BNZ   90EE
0907A:  MOVF   x7C,W
0907C:  SUBLW  04
0907E:  BNZ   90EE
09080:  MOVF   x7D,F
09082:  BNZ   90EE
....................             { 
....................                UDPGet(&HostIP->v[0]); 
09084:  MOVFF  361,37E
09088:  MOVFF  362,37F
0908C:  MOVFF  362,383
09090:  MOVFF  361,382
09094:  MOVLB  0
09096:  CALL   7D2A
....................                UDPGet(&HostIP->v[1]); 
0909A:  MOVLW  01
0909C:  MOVLB  3
0909E:  ADDWF  x61,W
090A0:  MOVWF  x7E
090A2:  MOVLW  00
090A4:  ADDWFC x62,W
090A6:  MOVWF  x7F
090A8:  MOVWF  x83
090AA:  MOVFF  37E,382
090AE:  MOVLB  0
090B0:  CALL   7D2A
....................                UDPGet(&HostIP->v[2]); 
090B4:  MOVLW  02
090B6:  MOVLB  3
090B8:  ADDWF  x61,W
090BA:  MOVWF  x7E
090BC:  MOVLW  00
090BE:  ADDWFC x62,W
090C0:  MOVWF  x7F
090C2:  MOVWF  x83
090C4:  MOVFF  37E,382
090C8:  MOVLB  0
090CA:  CALL   7D2A
....................                UDPGet(&HostIP->v[3]); 
090CE:  MOVLW  03
090D0:  MOVLB  3
090D2:  ADDWF  x61,W
090D4:  MOVWF  x7E
090D6:  MOVLW  00
090D8:  ADDWFC x62,W
090DA:  MOVWF  x7F
090DC:  MOVWF  x83
090DE:  MOVFF  37E,382
090E2:  MOVLB  0
090E4:  CALL   7D2A
....................                break; 
090E8:  MOVLB  3
090EA:  BRA    9110
....................             } 
....................             else 
090EC:  BRA    910E
....................             { 
....................                //while(DNSAnswerHeader.ResponseLen.Val--) 
....................                while(DNSAnswerHeader.ResponseLen.Val) 
....................                { 
090EE:  MOVF   x7C,W
090F0:  IORWF  x7D,W
090F2:  BZ    910E
....................                   DNSAnswerHeader.ResponseLen.Val-=1; 
090F4:  MOVLW  01
090F6:  SUBWF  x7C,F
090F8:  MOVLW  00
090FA:  SUBWFB x7D,F
....................                   UDPGet(&i); 
090FC:  MOVLW  03
090FE:  MOVWF  x83
09100:  MOVLW  63
09102:  MOVWF  x82
09104:  MOVLB  0
09106:  CALL   7D2A
....................                } 
0910A:  MOVLB  3
0910C:  BRA    90EE
....................             } 
....................          } 
0910E:  BRA    8F9A
....................  
....................          UDPDiscard(); 
09110:  MOVLB  0
09112:  CALL   7E44
....................          UDPClose(MySocket); 
09116:  MOVFF  1B3,37E
0911A:  CALL   15CC
....................          MySocket = INVALID_UDP_SOCKET; 
0911E:  MOVLW  FF
09120:  MOVLB  1
09122:  MOVWF  xB3
....................          smDNS++; 
09124:  INCF   xB2,F
09126:  MOVLB  0
....................          // No need to break, we are done and need to return TRUE 
....................  
....................       case DNS_DONE: 
....................          return TRUE; 
09128:  MOVLW  01
0912A:  MOVWF  01
0912C:  BRA    9134
0912E:  MOVLB  1
....................    } 
....................  
....................    return FALSE; 
09130:  MOVLW  00
09132:  MOVWF  01
09134:  MOVLB  0
.................... } 
09136:  GOTO   934A (RETURN)
....................  
.................... static void DNSPutString(BYTE *String) 
.................... { 
....................    BYTE *RightPtr; 
....................    BYTE i; 
....................    BYTE Len; 
....................  
....................    RightPtr = String; 
*
08A94:  MOVFF  37F,381
08A98:  MOVFF  37E,380
....................  
....................    while(1) 
....................    { 
....................       do 
....................       { 
....................          i = *RightPtr++; 
08A9C:  MOVLB  3
08A9E:  MOVFF  381,03
08AA2:  MOVF   x80,W
08AA4:  INCF   x80,F
08AA6:  BTFSC  FD8.2
08AA8:  INCF   x81,F
08AAA:  MOVWF  FE9
08AAC:  MOVFF  03,FEA
08AB0:  MOVFF  FEF,382
....................       } while((i != 0x00) && (i != '.') && (i != '/')); 
08AB4:  MOVF   x82,F
08AB6:  BZ    8AC4
08AB8:  MOVF   x82,W
08ABA:  SUBLW  2E
08ABC:  BZ    8AC4
08ABE:  MOVF   x82,W
08AC0:  SUBLW  2F
08AC2:  BNZ   8A9E
....................  
....................       // Put the length parameter 
....................       Len = (BYTE)(RightPtr-String-1); 
08AC4:  MOVF   x7E,W
08AC6:  SUBWF  x80,W
08AC8:  MOVWF  x84
08ACA:  MOVF   x7F,W
08ACC:  SUBWFB x81,W
08ACE:  MOVWF  x85
08AD0:  MOVLW  01
08AD2:  SUBWF  x84,W
08AD4:  MOVWF  00
08AD6:  MOVLW  00
08AD8:  SUBWFB x85,W
08ADA:  MOVFF  00,383
....................       UDPPut(Len); 
08ADE:  MOVFF  383,385
08AE2:  MOVLB  0
08AE4:  CALL   79B4
....................       while(Len--) 
....................       { 
08AE8:  MOVLB  3
08AEA:  MOVF   x83,W
08AEC:  DECF   x83,F
08AEE:  XORLW  00
08AF0:  BZ    8B16
....................          UDPPut(*String++); 
08AF2:  MOVFF  37F,03
08AF6:  MOVF   x7E,W
08AF8:  INCF   x7E,F
08AFA:  BTFSC  FD8.2
08AFC:  INCF   x7F,F
08AFE:  MOVWF  FE9
08B00:  MOVFF  03,FEA
08B04:  MOVFF  FEF,384
08B08:  MOVFF  384,385
08B0C:  MOVLB  0
08B0E:  CALL   79B4
....................       } 
08B12:  BRA    8AE8
08B14:  MOVLB  3
....................       if(i == 0x00 || i == '/') 
08B16:  MOVF   x82,F
08B18:  BZ    8B20
08B1A:  MOVF   x82,W
08B1C:  SUBLW  2F
08B1E:  BNZ   8B22
....................          break; 
08B20:  BRA    8B2A
....................  
....................       // Skip over the '.' in the input string 
....................       String++; 
08B22:  INCF   x7E,F
08B24:  BTFSC  FD8.2
08B26:  INCF   x7F,F
....................    } 
08B28:  BRA    8A9E
....................  
....................    // Put the string terminator character 
....................    UDPPut(0x00); 
08B2A:  CLRF   x85
08B2C:  MOVLB  0
08B2E:  CALL   79B4
.................... } 
08B32:  GOTO   8D98 (RETURN)
....................  
.................... static void DNSGetString(BYTE *String) 
.................... { 
....................    BYTE i; 
....................    BYTE j; 
....................  
....................    if(String == NULL) 
08B36:  MOVLB  3
08B38:  MOVF   x7E,F
08B3A:  BNZ   8B82
08B3C:  MOVF   x7F,F
08B3E:  BNZ   8B82
....................    { 
....................       UDPGet(&i); 
08B40:  MOVLW  03
08B42:  MOVWF  x83
08B44:  MOVLW  80
08B46:  MOVWF  x82
08B48:  MOVLB  0
08B4A:  CALL   7D2A
....................       while(i) 
....................       { 
08B4E:  MOVLB  3
08B50:  MOVF   x80,F
08B52:  BZ    8B80
....................          while(i--) 
....................          { 
08B54:  MOVF   x80,W
08B56:  DECF   x80,F
08B58:  XORLW  00
08B5A:  BZ    8B6E
....................             UDPGet(&j); 
08B5C:  MOVLW  03
08B5E:  MOVWF  x83
08B60:  MOVLW  81
08B62:  MOVWF  x82
08B64:  MOVLB  0
08B66:  CALL   7D2A
....................          } 
08B6A:  MOVLB  3
08B6C:  BRA    8B54
....................          UDPGet(&i); 
08B6E:  MOVLW  03
08B70:  MOVWF  x83
08B72:  MOVLW  80
08B74:  MOVWF  x82
08B76:  MOVLB  0
08B78:  CALL   7D2A
....................       } 
08B7C:  BRA    8B4E
08B7E:  MOVLB  3
....................    } 
....................    else 
08B80:  BRA    8BC8
....................    { 
....................       UDPGet(&i); 
08B82:  MOVLW  03
08B84:  MOVWF  x83
08B86:  MOVLW  80
08B88:  MOVWF  x82
08B8A:  MOVLB  0
08B8C:  CALL   7D2A
....................       while(i) 
....................       { 
08B90:  MOVLB  3
08B92:  MOVF   x80,F
08B94:  BZ    8BC8
....................          while(i--) 
....................          { 
08B96:  MOVF   x80,W
08B98:  DECF   x80,F
08B9A:  XORLW  00
08B9C:  BZ    8BB6
....................             UDPGet(String); 
08B9E:  MOVFF  37F,383
08BA2:  MOVFF  37E,382
08BA6:  MOVLB  0
08BA8:  CALL   7D2A
....................             String++; 
08BAC:  MOVLB  3
08BAE:  INCF   x7E,F
08BB0:  BTFSC  FD8.2
08BB2:  INCF   x7F,F
....................          } 
08BB4:  BRA    8B96
....................          UDPGet(&i); 
08BB6:  MOVLW  03
08BB8:  MOVWF  x83
08BBA:  MOVLW  80
08BBC:  MOVWF  x82
08BBE:  MOVLB  0
08BC0:  CALL   7D2A
....................       } 
08BC4:  BRA    8B90
08BC6:  MOVLB  3
....................    } 
.................... } 
08BC8:  MOVLB  0
08BCA:  GOTO   8F56 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
02BE8:  MOVLB  1
02BEA:  CLRF   xC0
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
02BEC:  BSF    2E.1
.................... #endif 
....................  
....................    TickInit(); 
02BEE:  MOVLB  0
02BF0:  GOTO   10FC
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
02BF4:  GOTO   13DE
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
02BF8:  GOTO   15AC
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
02BFC:  GOTO   164A
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
02C00:  GOTO   1796
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
02C04:  CALL   18DC
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
02C08:  RCALL  2BCC
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
.................... #endif 
.................... } 
02C0A:  GOTO   2FC6 (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
08826:  MOVLB  3
08828:  BCF    x64.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
0882A:  BCF    x64.0
....................         switch(smStack) 
....................         { 
0882C:  MOVLB  1
0882E:  MOVF   xC0,W
08830:  ADDLW  F8
08832:  BTFSC  FD8.0
08834:  BRA    8A32
08836:  ADDLW  08
08838:  MOVLB  0
0883A:  GOTO   8A4E
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
0883E:  MOVLW  01
08840:  MOVLB  3
08842:  MOVWF  x66
08844:  MOVLW  C1
08846:  MOVWF  x65
08848:  MOVLW  03
0884A:  MOVWF  x68
0884C:  MOVLW  63
0884E:  MOVWF  x67
08850:  MOVLB  0
08852:  GOTO   43E2
08856:  MOVF   01,F
08858:  BNZ   887A
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
0885A:  MOVF   x87,W
0885C:  SUBLW  08
0885E:  BZ    8876
....................                     { 
....................                         if ( !MACIsLinked() ) 
08860:  CALL   4520
08864:  MOVF   01,F
08866:  BNZ   8876
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
08868:  CLRF   1B
0886A:  CLRF   1A
0886C:  CLRF   19
0886E:  CLRF   18
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
08870:  BSF    2E.1
....................                             DHCPReset(); 
08872:  CALL   18DC
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
08876:  MOVLB  1
08878:  BRA    8A32
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET ");      //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................  
....................             lbContinue = TRUE; 
0887A:  MOVLB  3
0887C:  BSF    x64.0
....................             if ( type.MACFrameType == MAC_IP ) { 
0887E:  MOVF   x63,F
08880:  BNZ   888C
....................                 smStack = SM_STACK_IP; 
08882:  MOVLW  02
08884:  MOVLB  1
08886:  MOVWF  xC0
.................... //                debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
08888:  BRA    88A4
0888A:  MOVLB  3
0888C:  MOVF   x63,W
0888E:  SUBLW  06
08890:  BNZ   889C
....................                 smStack = SM_STACK_ARP; 
08892:  MOVLW  05
08894:  MOVLB  1
08896:  MOVWF  xC0
.................... //                debug_stack("ARP ");          //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             else { 
08898:  BRA    88A4
0889A:  MOVLB  3
....................                 MACDiscardRx(); 
0889C:  MOVLB  0
0889E:  CALL   1908
088A2:  MOVLB  1
.................... //                debug_stack("DISCARD");       //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             break; 
088A4:  BRA    8A32
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
088A6:  GOTO   4896
088AA:  MOVF   01,F
088AC:  BZ    88B2
....................                 smStack = SM_STACK_IDLE; 
088AE:  MOVLB  1
088B0:  CLRF   xC0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
088B2:  MOVLB  1
088B4:  BRA    8A32
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
088B6:  MOVLW  03
088B8:  MOVLB  3
088BA:  MOVWF  x66
088BC:  MOVLW  5F
088BE:  MOVWF  x65
088C0:  MOVLW  01
088C2:  MOVWF  x68
088C4:  MOVLW  C1
088C6:  MOVWF  x67
088C8:  MOVLW  03
088CA:  MOVWF  x6A
088CC:  MOVLW  63
088CE:  MOVWF  x69
088D0:  MOVLW  01
088D2:  MOVWF  x6C
088D4:  MOVLW  CB
088D6:  MOVWF  x6B
088D8:  MOVLB  0
088DA:  GOTO   4AB4
088DE:  MOVF   01,F
088E0:  BZ    8924
....................             { 
....................                 lbContinue = TRUE; 
088E2:  MOVLB  3
088E4:  BSF    x64.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
088E6:  DECFSZ x63,W
088E8:  BRA    88F4
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
088EA:  MOVLW  03
088EC:  MOVLB  1
088EE:  MOVWF  xC0
.................... //                    debug_stack("ICMP ");        //SE COMENTA PARA TRABAJO CON ALUX 1.1 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
088F0:  BRA    8920
088F2:  MOVLB  3
088F4:  MOVF   x63,W
088F6:  SUBLW  06
088F8:  BNZ   8904
....................                     smStack = SM_STACK_TCP; 
088FA:  MOVLW  06
088FC:  MOVLB  1
088FE:  MOVWF  xC0
.................... //                    debug_stack("TCP ");            //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
08900:  BRA    8920
08902:  MOVLB  3
08904:  MOVF   x63,W
08906:  SUBLW  11
08908:  BNZ   8914
....................                     smStack = SM_STACK_UDP; 
0890A:  MOVLW  07
0890C:  MOVLB  1
0890E:  MOVWF  xC0
.................... //                    debug_stack("UDP ");            //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
.................... #endif 
....................  
....................                 else 
08910:  BRA    8920
08912:  MOVLB  3
....................                 { 
....................                     lbContinue = FALSE; 
08914:  BCF    x64.0
....................                     MACDiscardRx(); 
08916:  MOVLB  0
08918:  CALL   1908
....................  
....................                     smStack = SM_STACK_IDLE; 
0891C:  MOVLB  1
0891E:  CLRF   xC0
.................... //                    debug_stack("UNKOWN-IP1 ");     //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 } 
....................             } 
....................             else 
08920:  BRA    892C
08922:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
08924:  CALL   1908
....................                 smStack = SM_STACK_IDLE; 
08928:  MOVLB  1
0892A:  CLRF   xC0
.................... //                debug_stack("UNKOWN-IP2 ");         //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................             } 
....................             break; 
0892C:  BRA    8A32
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0892E:  MOVLW  01
08930:  MOVLB  3
08932:  MOVWF  x66
08934:  MOVLW  C1
08936:  MOVWF  x65
08938:  MOVLW  03
0893A:  MOVWF  x68
0893C:  MOVLW  5F
0893E:  MOVWF  x67
08940:  MOVFF  1CC,36A
08944:  MOVFF  1CB,369
08948:  MOVLB  0
0894A:  GOTO   4D5E
0894E:  MOVF   01,F
08950:  BZ    8956
....................             { 
....................                 //debug_stack("\r\nUDP PROCESSED");   //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
08952:  MOVLB  1
08954:  CLRF   xC0
....................             } 
....................             break; 
08956:  MOVLB  1
08958:  BRA    8A32
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0895A:  MOVLW  01
0895C:  MOVLB  3
0895E:  MOVWF  x66
08960:  MOVLW  C1
08962:  MOVWF  x65
08964:  MOVLW  03
08966:  MOVWF  x68
08968:  MOVLW  5F
0896A:  MOVWF  x67
0896C:  MOVFF  1CC,36A
08970:  MOVFF  1CB,369
08974:  MOVLB  0
08976:  GOTO   5C36
0897A:  MOVF   01,F
0897C:  BZ    8982
....................             { 
.................... //                debug_stack("\r\nTCP PROCESSED");   //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0897E:  MOVLB  1
08980:  CLRF   xC0
....................             } 
....................             break; 
08982:  MOVLB  1
08984:  BRA    8A32
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
08986:  MOVLB  1
08988:  CLRF   xC0
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
0898A:  MOVF   xCC,F
0898C:  BNZ   89E0
0898E:  MOVF   xCB,W
08990:  SUBLW  48
08992:  BNC   89E0
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
08994:  MOVLW  01
08996:  MOVLB  3
08998:  MOVWF  x66
0899A:  MOVLW  CB
0899C:  MOVWF  x65
0899E:  MOVLW  03
089A0:  MOVWF  x68
089A2:  MOVLW  63
089A4:  MOVWF  x67
089A6:  MOVLW  01
089A8:  MOVWF  x6A
089AA:  MOVLW  CD
089AC:  MOVWF  x69
089AE:  MOVFF  366,36C
089B2:  MOVFF  365,36B
089B6:  MOVLW  02
089B8:  MOVWF  x6E
089BA:  MOVLW  0D
089BC:  MOVWF  x6D
089BE:  MOVLW  02
089C0:  MOVWF  x70
089C2:  MOVLW  0F
089C4:  MOVWF  x6F
089C6:  MOVLB  0
089C8:  GOTO   5EC2
089CC:  MOVF   01,F
089CE:  BZ    89E4
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
089D0:  MOVLB  3
089D2:  MOVF   x63,W
089D4:  SUBLW  08
089D6:  BNZ   89E2
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED");      //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                         lbContinue = TRUE; 
089D8:  BSF    x64.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
089DA:  MOVLW  04
089DC:  MOVLB  1
089DE:  MOVWF  xC0
089E0:  MOVLB  3
089E2:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
089E4:  CALL   1908
....................             break; 
089E8:  MOVLB  1
089EA:  BRA    8A32
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
089EC:  MOVLW  01
089EE:  MOVLB  3
089F0:  MOVWF  xEB
089F2:  MOVLB  0
089F4:  CALL   1AC0
089F8:  MOVF   01,F
089FA:  BZ    8A2E
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
089FC:  MOVLW  01
089FE:  MOVLB  3
08A00:  MOVWF  x66
08A02:  MOVLW  C1
08A04:  MOVWF  x65
08A06:  CLRF   x67
08A08:  MOVLW  01
08A0A:  MOVWF  x69
08A0C:  MOVLW  CD
08A0E:  MOVWF  x68
08A10:  MOVFF  1CB,36A
08A14:  MOVFF  20E,36C
08A18:  MOVFF  20D,36B
08A1C:  MOVFF  210,36E
08A20:  MOVFF  20F,36D
08A24:  MOVLB  0
08A26:  GOTO   5F9A
....................  
.................... //                debug_stack("\r\nICMP REPLIED");    //SE COMENTA PARA TRABAJO CON ALUX 1.1 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
08A2A:  MOVLB  1
08A2C:  CLRF   xC0
....................             } 
....................             break; 
08A2E:  MOVLB  1
08A30:  BRA    8A32
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
08A32:  MOVLB  3
08A34:  BTFSC  x64.0
08A36:  BRA    882A
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
08A38:  MOVLB  0
08A3A:  GOTO   6940
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
08A3E:  GOTO   72B2
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
08A42:  BRA    8384
....................  
....................     if ( DHCPIsBound() ) 
08A44:  BTFSS  x88.0
08A46:  BRA    8A4A
....................         AppConfig.Flags.bInConfigMode = FALSE; 
08A48:  BCF    2E.1
....................  
.................... #endif 
.................... } 
08A4A:  GOTO   9BB6 (RETURN)
....................  
....................  
.................... #define CCS_EMAIL_EXAMPLE TRUE   //used by CCSHELPER.C 
.................... void my_smtp_send(void); 
....................  
.................... #include "ccshelper.c"   //include CCS's PICDEM.net/PICNET helper functions 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         CCSHELPER.C                               //// 
.................... ////                                                                   //// 
.................... //// Helper functions and definitions for using CCS's example programs //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            ////  
.................... ////                                                                   //// 
.................... ////    May 26, 2004: Fixed a bug in read_ext_eeprom_string() to       //// 
.................... ////                  prevent infinite loops when EEPROM is all 0xFF.  //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Settings saved to external EEPROM                //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
....................   #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
....................   #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICNET+STACK_USE_CCS_PICENS+STACK_USE_CCS_PICEEC)==0 
....................    #error You must define one of the prototype boards 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET 
....................    #define ADC_CHAN_0   0 
....................    #define ADC_CHAN_1   1 
....................    #define USER_BUTTON1 PIN_B0 
....................    #define USER_BUTTON2 PIN_B1 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
.................... #elif STACK_USE_CCS_PICENS 
....................    #define ADC_CHAN_0   0 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #elif STACK_USE_CCS_PICEEC 
....................    #define ADC_CHAN_0   2 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PICDEM_LCD 
....................    #define STACK_USE_PICDEM_LCD TRUE 
.................... #endif 
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, STREAM=USER) 
*
00EB4:  BTFSS  F9E.4
00EB6:  BRA    0EB4
00EB8:  MOVWF  FAD
00EBA:  RETLW  00
....................  
.................... #if STACK_USE_PICDEM_LCD 
....................    #IF STACK_USE_CCS_PICNET 
....................       #include "tcpip/dlcd.c" 
....................    #elif STACK_USE_CCS_PICENS 
....................       #include "tcpip/mlcd.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             MLCD.C                                //// 
.................... ////                Driver for LCD Module on CCS PICENS                //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     E2  enable 
.................... //     E0  rs 
.................... //     E1  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int     empty: 4;         // on PORT D 
....................            int     data : 4; 
....................         } lcd_io,lcd_lat,lcd_tris; 
....................  
.................... #bit lcd_enable=0xF8D.2 
.................... #bit lcd_rs=0xF8D.0 
.................... #bit lcd_rw=0xF8D.1 
....................  
.................... #byte lcd_io = 0xF83                   // This puts the entire structure on PORT D 
.................... #byte lcd_lat = 0xF8C 
.................... #byte lcd_tris = 0xF95 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       lcd_tris.data=0xF;  //set_tris_lcd(LCD_READ); 
*
02C38:  MOVLW  0F
02C3A:  ANDWF  F95,W
02C3C:  IORLW  F0
02C3E:  MOVWF  F95
....................       lcd_rw = 1; 
02C40:  BSF    F8D.1
....................       delay_us(1); 
02C42:  MOVLW  03
02C44:  MOVWF  00
02C46:  DECFSZ 00,F
02C48:  BRA    2C46
....................       lcd_enable = 1; 
02C4A:  BSF    F8D.2
....................       delay_us(1); 
02C4C:  MOVLW  03
02C4E:  MOVWF  00
02C50:  DECFSZ 00,F
02C52:  BRA    2C50
....................       high = lcd_io.data; 
02C54:  SWAPF  F83,W
02C56:  ANDLW  0F
02C58:  MOVLB  3
02C5A:  MOVWF  x6C
....................       lcd_enable = 0; 
02C5C:  BCF    F8D.2
....................       delay_us(1); 
02C5E:  MOVLW  03
02C60:  MOVWF  00
02C62:  DECFSZ 00,F
02C64:  BRA    2C62
....................       lcd_enable = 1; 
02C66:  BSF    F8D.2
....................       delay_us(1); 
02C68:  MOVLW  03
02C6A:  MOVWF  00
02C6C:  DECFSZ 00,F
02C6E:  BRA    2C6C
....................       low = lcd_io.data; 
02C70:  SWAPF  F83,W
02C72:  ANDLW  0F
02C74:  MOVWF  x6B
....................       lcd_enable = 0; 
02C76:  BCF    F8D.2
....................       lcd_tris.data=0;  //set_tris_lcd(LCD_WRITE); 
02C78:  MOVLW  0F
02C7A:  ANDWF  F95,W
02C7C:  MOVWF  F95
....................       return( (high<<4) | low); 
02C7E:  SWAPF  x6C,W
02C80:  MOVWF  00
02C82:  MOVLW  F0
02C84:  ANDWF  00,F
02C86:  MOVF   00,W
02C88:  IORWF  x6B,W
02C8A:  MOVWF  01
.................... } 
02C8C:  MOVLB  0
02C8E:  GOTO   2C9E (RETURN)
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd_lat.data = n; 
*
02C0E:  MOVLB  3
02C10:  SWAPF  x6C,W
02C12:  ANDLW  F0
02C14:  MOVWF  00
02C16:  MOVLW  0F
02C18:  ANDWF  F8C,W
02C1A:  IORWF  00,W
02C1C:  MOVWF  F8C
....................       delay_us(1); 
02C1E:  MOVLW  03
02C20:  MOVWF  00
02C22:  DECFSZ 00,F
02C24:  BRA    2C22
....................       lcd_enable = 1; 
02C26:  BSF    F8D.2
....................       delay_us(2); 
02C28:  MOVLW  06
02C2A:  MOVWF  00
02C2C:  DECFSZ 00,F
02C2E:  BRA    2C2C
02C30:  NOP   
....................       lcd_enable = 0; 
02C32:  BCF    F8D.2
.................... } 
02C34:  MOVLB  0
02C36:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd_rs = 0; 
*
02C92:  BCF    F8D.0
....................       delay_us(1); 
02C94:  MOVLW  03
02C96:  MOVWF  00
02C98:  DECFSZ 00,F
02C9A:  BRA    2C98
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
02C9C:  BRA    2C38
02C9E:  MOVFF  01,36B
02CA2:  MOVLB  3
02CA4:  BTFSS  01.7
02CA6:  BRA    2CAC
02CA8:  MOVLB  0
02CAA:  BRA    2C9C
....................       lcd_rs = address; 
02CAC:  BCF    F8D.0
02CAE:  BTFSC  x69.0
02CB0:  BSF    F8D.0
....................       delay_us(1); 
02CB2:  MOVLW  03
02CB4:  MOVWF  00
02CB6:  DECFSZ 00,F
02CB8:  BRA    2CB6
....................       lcd_rw = 0; 
02CBA:  BCF    F8D.1
....................       delay_us(1); 
02CBC:  MOVLW  03
02CBE:  MOVWF  00
02CC0:  DECFSZ 00,F
02CC2:  BRA    2CC0
....................       lcd_enable = 0; 
02CC4:  BCF    F8D.2
....................       lcd_send_nibble(n >> 4); 
02CC6:  SWAPF  x6A,W
02CC8:  MOVWF  x6B
02CCA:  MOVLW  0F
02CCC:  ANDWF  x6B,F
02CCE:  MOVFF  36B,36C
02CD2:  MOVLB  0
02CD4:  RCALL  2C0E
....................       lcd_send_nibble(n & 0xf); 
02CD6:  MOVLB  3
02CD8:  MOVF   x6A,W
02CDA:  ANDLW  0F
02CDC:  MOVWF  x6B
02CDE:  MOVWF  x6C
02CE0:  MOVLB  0
02CE2:  RCALL  2C0E
.................... } 
02CE4:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     lcd_tris.data=0;    //set_tris_lcd(LCD_WRITE); 
02CE6:  MOVLW  0F
02CE8:  ANDWF  F95,W
02CEA:  MOVWF  F95
....................     lcd_rs = 0; 
02CEC:  BCF    F8D.0
....................     lcd_rw = 0; 
02CEE:  BCF    F8D.1
....................     lcd_enable = 0; 
02CF0:  BCF    F8D.2
....................     *0xF96=*0xF96 & 0xF8; 
02CF2:  MOVLW  F8
02CF4:  ANDWF  F96,F
....................     delay_ms(15); 
02CF6:  MOVLW  0F
02CF8:  MOVLB  3
02CFA:  MOVWF  x65
02CFC:  MOVLB  0
02CFE:  CALL   0DF4
....................     for(i=1;i<=3;++i) { 
02D02:  MOVLW  01
02D04:  MOVLB  3
02D06:  MOVWF  x5F
02D08:  MOVF   x5F,W
02D0A:  SUBLW  03
02D0C:  BNC   2D28
....................        lcd_send_nibble(3); 
02D0E:  MOVLW  03
02D10:  MOVWF  x6C
02D12:  MOVLB  0
02D14:  RCALL  2C0E
....................        delay_ms(5); 
02D16:  MOVLW  05
02D18:  MOVLB  3
02D1A:  MOVWF  x65
02D1C:  MOVLB  0
02D1E:  CALL   0DF4
....................     } 
02D22:  MOVLB  3
02D24:  INCF   x5F,F
02D26:  BRA    2D08
....................     lcd_send_nibble(2); 
02D28:  MOVLW  02
02D2A:  MOVWF  x6C
02D2C:  MOVLB  0
02D2E:  RCALL  2C0E
....................     delay_ms(5); 
02D30:  MOVLW  05
02D32:  MOVLB  3
02D34:  MOVWF  x65
02D36:  MOVLB  0
02D38:  CALL   0DF4
....................     for(i=0;i<=3;++i) 
02D3C:  MOVLB  3
02D3E:  CLRF   x5F
02D40:  MOVF   x5F,W
02D42:  SUBLW  03
02D44:  BNC   2D6C
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
02D46:  CLRF   03
02D48:  MOVF   x5F,W
02D4A:  MOVFF  FF2,360
02D4E:  BCF    FF2.7
02D50:  MOVLB  0
02D52:  CALL   0110
02D56:  MOVLB  3
02D58:  BTFSC  x60.7
02D5A:  BSF    FF2.7
02D5C:  MOVWF  x60
02D5E:  CLRF   x69
02D60:  MOVWF  x6A
02D62:  MOVLB  0
02D64:  RCALL  2C92
02D66:  MOVLB  3
02D68:  INCF   x5F,F
02D6A:  BRA    2D40
.................... } 
02D6C:  MOVLB  0
02D6E:  GOTO   2FC8 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0959A:  MOVLB  3
0959C:  DECFSZ x66,W
0959E:  BRA    95A2
095A0:  BRA    95A8
....................      address=lcd_line_two; 
095A2:  MOVLW  40
095A4:  MOVWF  x67
....................    else 
095A6:  BRA    95AA
....................      address=0; 
095A8:  CLRF   x67
....................    address+=x-1; 
095AA:  MOVLW  01
095AC:  SUBWF  x65,W
095AE:  ADDWF  x67,F
....................    lcd_send_byte(0,0x80|address); 
095B0:  MOVF   x67,W
095B2:  IORLW  80
095B4:  MOVWF  x68
095B6:  CLRF   x69
095B8:  MOVWF  x6A
095BA:  MOVLB  0
095BC:  CALL   2C92
.................... } 
095C0:  GOTO   9626 (RETURN)
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
095C4:  MOVLB  3
095C6:  MOVF   x64,W
095C8:  XORLW  0C
095CA:  MOVLB  0
095CC:  BZ    95D8
095CE:  XORLW  06
095D0:  BZ    95F4
095D2:  XORLW  02
095D4:  BZ    9604
095D6:  BRA    9614
....................      case '\f'   : lcd_send_byte(0,1); 
095D8:  MOVLB  3
095DA:  CLRF   x69
095DC:  MOVLW  01
095DE:  MOVWF  x6A
095E0:  MOVLB  0
095E2:  CALL   2C92
....................                    delay_ms(2); 
095E6:  MOVLW  02
095E8:  MOVLB  3
095EA:  MOVWF  x65
095EC:  MOVLB  0
095EE:  CALL   0DF4
....................                                            break; 
095F2:  BRA    9626
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
095F4:  MOVLW  01
095F6:  MOVLB  3
095F8:  MOVWF  x65
095FA:  MOVLW  02
095FC:  MOVWF  x66
095FE:  MOVLB  0
09600:  BRA    959A
09602:  BRA    9626
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
09604:  MOVLB  3
09606:  CLRF   x69
09608:  MOVLW  10
0960A:  MOVWF  x6A
0960C:  MOVLB  0
0960E:  CALL   2C92
09612:  BRA    9626
....................      default     : lcd_send_byte(1,c);     break; 
09614:  MOVLW  01
09616:  MOVLB  3
09618:  MOVWF  x69
0961A:  MOVFF  364,36A
0961E:  MOVLB  0
09620:  CALL   2C92
09624:  BRA    9626
....................    } 
.................... } 
09626:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd_rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd_rs=0; 
....................     return(value); 
.................... } 
....................  
....................    #elif STACK_USE_CCS_PICEEC 
....................       #include "tcpip/elcd.c" 
....................    #else 
....................       #error Can't use LCD without specifying which hardware. Or write your own LCD driver. 
....................    #ENDIF 
.................... #endif 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... //uncomment this driver to use the 24lc256 on a picdem.net or picnet board 
.................... #if STACK_USE_CCS_PICNET 
....................  //both microchip picdem.net and ccs picnet board use these pins 
....................  //for the 24lc256 eeprom. 
....................  #define EEPROM_SDA  PIN_C4 
....................  #define EEPROM_SCL  PIN_C3 
....................  #include <24256.c>   //included with compiler 
.................... #elif STACK_USE_CCS_PICENS 
....................  #define EEPROM_SELECT PIN_B3 
....................  #define EEPROM_DI     PIN_C5 
....................  #define EEPROM_DO     PIN_C4 
....................  #define EEPROM_CLK    PIN_C3 
....................  #define EEPROM_USE_SPI    ENC_MAC_USE_SPI 
....................  #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... typedef union { 
....................    int16 val; 
....................    int8 b[2]; 
.................... } EEPROM_ADDRESS; 
....................  
.................... #define ext_eeprom_write_enable()   ext_eeprom_set_status(2) 
....................  
.................... int8 at25256_spi_exchange(int8 out) { 
....................  #if EEPROM_USE_SPI 
....................    return(spi_read(out)); 
*
00DBC:  MOVF   FC9,W
00DBE:  MOVFF  3AE,FC9
00DC2:  RRCF   FC7,W
00DC4:  BNC   0DC2
00DC6:  MOVFF  FC9,01
....................  #else 
....................    int8 in=0,i; 
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(&out,1,0)); 
....................       output_high(EEPROM_CLK);		//data latches 
....................       shift_left(&in,1,input(EEPROM_DO)); 
....................       output_low(EEPROM_CLK);		//back to idle 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
00DCA:  RETLW  00
....................  
.................... void ext_eeprom_set_status(int8 status) { 
....................    output_low(EEPROM_SELECT);   //at25256 is cs active LOW 
*
00E1E:  BCF    F8A.3
....................    at25256_spi_exchange(1);   //status 
00E20:  MOVLW  01
00E22:  MOVLB  3
00E24:  MOVWF  xAE
00E26:  MOVLB  0
00E28:  RCALL  0DBC
....................    at25256_spi_exchange(status); 
00E2A:  MOVFF  360,3AE
00E2E:  RCALL  0DBC
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
00E30:  BSF    F8A.3
.................... } 
00E32:  GOTO   0E7A (RETURN)
....................  
.................... int8 ext_eeprom_ready() { 
....................    BYTE data; 
....................  
....................    output_low(EEPROM_SELECT); 
*
00DCC:  BCF    F8A.3
....................  
....................    at25256_spi_exchange(5);   //rdsr opcode 
00DCE:  MOVLW  05
00DD0:  MOVLB  3
00DD2:  MOVWF  xAE
00DD4:  MOVLB  0
00DD6:  RCALL  0DBC
....................    data=at25256_spi_exchange(0); 
00DD8:  MOVLB  3
00DDA:  CLRF   xAE
00DDC:  MOVLB  0
00DDE:  RCALL  0DBC
00DE0:  MOVFF  01,3AD
....................  
....................    output_high(EEPROM_SELECT); 
00DE4:  BSF    F8A.3
....................    return (!bit_test(data, 0)); 
00DE6:  MOVLW  00
00DE8:  MOVLB  3
00DEA:  BTFSS  xAD.0
00DEC:  MOVLW  01
00DEE:  MOVWF  01
.................... } 
00DF0:  MOVLB  0
00DF2:  RETLW  00
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data) { 
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
*
00EBC:  RCALL  0DCC
00EBE:  MOVF   01,F
00EC0:  BZ    0EBC
....................  
....................    output_low(EEPROM_SELECT); 
00EC2:  BCF    F8A.3
....................    at25256_spi_exchange(0x06); 
00EC4:  MOVLW  06
00EC6:  MOVLB  3
00EC8:  MOVWF  xAE
00ECA:  MOVLB  0
00ECC:  RCALL  0DBC
....................    output_high(EEPROM_SELECT); 
00ECE:  BSF    F8A.3
....................  
....................    output_low(EEPROM_SELECT); 
00ED0:  BCF    F8A.3
....................    at25256_spi_exchange(0x02);   //write opcode 
00ED2:  MOVLW  02
00ED4:  MOVLB  3
00ED6:  MOVWF  xAE
00ED8:  MOVLB  0
00EDA:  RCALL  0DBC
....................    at25256_spi_exchange(address.b[1]); 
00EDC:  MOVFF  3AA,3AE
00EE0:  RCALL  0DBC
....................    at25256_spi_exchange(address.b[0]); 
00EE2:  MOVFF  3A9,3AE
00EE6:  RCALL  0DBC
....................    at25256_spi_exchange(data); 
00EE8:  MOVFF  3AB,3AE
00EEC:  RCALL  0DBC
....................    output_high(EEPROM_SELECT); 
00EEE:  BSF    F8A.3
.................... } 
00EF0:  RETLW  00
....................  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    BYTE data; 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
*
00E7E:  RCALL  0DCC
00E80:  MOVF   01,F
00E82:  BZ    0E7E
....................  
....................    output_low(EEPROM_SELECT); 
00E84:  BCF    F8A.3
....................    at25256_spi_exchange(0x03);   //read opcode 
00E86:  MOVLW  03
00E88:  MOVLB  3
00E8A:  MOVWF  xAE
00E8C:  MOVLB  0
00E8E:  RCALL  0DBC
....................    at25256_spi_exchange(address.b[1]); 
00E90:  MOVFF  3AB,3AE
00E94:  RCALL  0DBC
....................    at25256_spi_exchange(address.b[0]); 
00E96:  MOVFF  3AA,3AE
00E9A:  RCALL  0DBC
....................    data=at25256_spi_exchange(0); 
00E9C:  MOVLB  3
00E9E:  CLRF   xAE
00EA0:  MOVLB  0
00EA2:  RCALL  0DBC
00EA4:  MOVFF  01,3AC
....................    output_high(EEPROM_SELECT); 
00EA8:  BSF    F8A.3
....................  
....................    return(data); 
00EAA:  MOVLB  3
00EAC:  MOVFF  3AC,01
.................... } 
00EB0:  MOVLB  0
00EB2:  RETLW  00
....................  
.................... void init_ext_eeprom(void) { 
....................    int8 to=250; 
*
00E36:  MOVLW  FA
00E38:  MOVLB  3
00E3A:  MOVWF  x5F
....................  
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
00E3C:  BSF    F8A.3
....................  
....................    OUTPUT_DRIVE_MACRO(EEPROM_SELECT); 
00E3E:  BCF    F93.3
....................     
....................  #if EEPROM_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
00E40:  BCF    FC6.5
00E42:  MOVLW  20
00E44:  MOVWF  FC6
00E46:  MOVLW  40
00E48:  MOVWF  FC7
....................  #else 
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_CLK); 
....................  #endif 
....................  
....................    OUTPUT_DRIVE_MACRO(EEPROM_DI); 
00E4A:  BCF    F94.5
....................    OUTPUT_DRIVE_MACRO(EEPROM_CLK); 
00E4C:  BCF    F94.3
....................    output_float(EEPROM_DO); 
00E4E:  BSF    F94.4
....................  
....................  
....................    while(!ext_eeprom_ready() && to) 
....................    { 
00E50:  MOVLB  0
00E52:  RCALL  0DCC
00E54:  MOVF   01,F
00E56:  BNZ   0E70
00E58:  MOVLB  3
00E5A:  MOVF   x5F,F
00E5C:  BTFSS  FD8.2
00E5E:  BRA    0E64
00E60:  MOVLB  0
00E62:  BRA    0E70
....................       to--; 
00E64:  DECF   x5F,F
....................       delay_ms(1); 
00E66:  MOVLW  01
00E68:  MOVWF  x65
00E6A:  MOVLB  0
00E6C:  RCALL  0DF4
....................    } 
00E6E:  BRA    0E52
....................  
....................    ext_eeprom_write_enable(); 
00E70:  MOVLW  02
00E72:  MOVLB  3
00E74:  MOVWF  x60
00E76:  MOVLB  0
00E78:  BRA    0E1E
.................... } 
00E7A:  GOTO   2EEE (RETURN)
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................  #define EEPROM_SELECT PIN_C1  //o 
....................  #define EEPROM_DI     PIN_C5  //o 
....................  #define EEPROM_DO     PIN_C4  //i 
....................  #define EEPROM_CLK    PIN_C3  //o 
....................  #define MMC_SELECT    PIN_C2  //o 
....................  #define EEPROM_USE_SPI   FALSE 
....................  #include "AT25256.C" 
.................... #endif 
....................  
.................... //if using PPP 
.................... #define EE_ISP_PHONENUMBER 0      //size=64 
.................... #define EE_ISP_USERNAME    64      //size=64 
.................... #define EE_ISP_PASSWORD    128      //size=64 
.................... //if using ETHERNET 
.................... #define EE_NIC_DHCP        192   //size=1 
.................... #define EE_NIC_GATEWAY     193   //size=4 
.................... #define EE_NIC_IP          197   //size=4 
.................... #define EE_NIC_NETMASK     201   //size=4 
.................... #define EE_NIC_MAC         205   //size=6 
.................... #define EE_DNS             211   //size=4 
.................... //if using CCS E-Mail Example 
.................... #define EE_SMTP_PORT       215   //size=2   [TCP Port] 
.................... #define EE_SMTP_HOSTNAME   217   //size=64  [E-mail SMTP server hostname] 
.................... #define EE_SMTP_TO         281   //size=64  [E-mail To address] 
.................... #define EE_SMTP_FROM       345   //size=64  [E-mail From address] 
.................... #define EE_SMTP_SUBJECT    409   //size=64  [E-mail Subject] 
.................... #define EE_SMTP_BODY       473   //size=64  [E-mail Body] 
.................... //if using CCS UDP Example 
.................... #define EE_UDP_DEST_IP     537   //size=4   [destination IP address for UDP example] 
.................... #define EE_UDP_DEST_PORT   541   //size=2   [destination port for UDP example] 
.................... #define EE_UDP_SRC_PORT    543   //size=2    [source port for UDP example] 
....................  
.................... #define EE_MAGIC           545 
.................... #define EE_LAST            546 
....................  
.................... //global variables holding PPP information 
.................... //PPP stack requires these to be global 
.................... #if STACK_USE_PPP 
.................... char ppp_phonenumber[64]; 
.................... char ppp_username[64]; 
.................... char ppp_password[64]; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
.................... //Displays modem AT command result to LCD and RS232 serial output 
.................... void display_modem_result(MODEM_RESP err) { 
....................    char str[15]; 
....................    str[0]=0; 
....................  
....................    switch (err) { 
....................       case MODEM_OK:          sprintf(str,"OK");          break; 
....................       case MODEM_CONNECTED:   sprintf(str,"CONNECTED");   break; 
....................       case MODEM_BUSY:        sprintf(str,"BUSY");        break; 
....................       case MODEM_NO_RESPONSE: sprintf(str,"NO RESPONSE"); break; 
....................       case MODEM_NO_CARRIER:  sprintf(str,"NO CARRIER");  break; 
....................       case MODEM_NO_DIALTONE: sprintf(str,"NO DIALTONE"); break; 
....................       default:                sprintf(str,"ERR %U", err); break; 
....................    } 
....................  #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\n                "); 
....................    printf(lcd_putc,"\n%s",str); 
....................    delay_ms(3000); 
....................  #endif 
....................  fprintf(USER,"\r\nMODEM RESP: %s",str); 
.................... } 
.................... #endif 
....................  
.................... //Display's current IP address on the LCD and/or RS232 serial output 
.................... void display_ip_lcd(void) { 
.................... #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\n                    "); 
....................        #if STACK_USE_DHCP 
....................           if (MACIsLinked() && ((DHCPIsBound() && read_ext_eeprom(EE_NIC_DHCP))||(!read_ext_eeprom(EE_NIC_DHCP)))) 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................           else if (MACIsLinked()) 
....................              printf(lcd_putc,"\nDHCP NOT BOUND"); 
....................           else 
....................             printf(lcd_putc,"\nNO ETHERNET LINK"); 
....................  
....................        #elif STACK_USE_PPP 
....................          if (ppp_is_connected()) { 
....................             printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................          } 
....................          else { 
....................             printf(lcd_putc,"\nNOT CONNECTED"); 
....................          } 
....................        #else 
....................         if (MACIsLinked()) { 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................         } 
....................         else { 
....................            printf(lcd_putc,"\nNO ETHERNET LINK"); 
....................         } 
....................        #endif 
.................... #endif 
.................... } 
....................  
.................... //a simple routine to make a PPP connection 
.................... #if STACK_USE_PPP 
.................... void picdem_ppp_connect(void) { 
....................    MODEM_RESP ec; 
....................    int8 retries=5; 
....................  
....................    while (!ppp_is_connected() && retries--) { 
....................      #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\nDialing ISP     "); 
....................      #endif 
....................      fprintf(USER,"\r\n\nDialing ISP"); 
....................  
....................       ec=ppp_connect(ppp_username, ppp_password, ppp_phonenumber); 
....................       display_modem_result(ec); 
....................  
....................       if (connected_baudrate) { 
....................         #if STACK_USE_PICDEM_LCD 
....................          printf(lcd_putc,"\fConnect %LUbps    ", connected_baudrate); 
....................          printf(lcd_putc,"\nNegotiating PPP "); 
....................         #endif 
....................          fprintf(USER,"\r\nConnected %LU\r\nNegotiating PPP...", connected_baudrate); 
....................  
....................          while (connected_baudrate && !MY_IP.Val) { 
....................             restart_wdt(); 
....................             ppp_handle();    //keep calling the ppp task until we get assigned an IP address 
....................             //BUG: if it gets stuck, it should hang-up and redial. 
....................             //     (Many ISPs will do this for you though) 
....................          } 
....................          if (MY_IP.Val) { 
....................             display_ip_lcd();     //we got a connection, show the IP address on the LCD screen 
....................             fprintf(USER,"\r\nConnected to ISP, IP Address is %U.%U.%U.%U\r\n",MY_IP.v[0],MY_IP.v[1],MY_IP.v[2],MY_IP.v[3]); 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //null terminated 
.................... void write_ext_eeprom_string(int16 address, char *str) { 
....................    while(*str) { 
*
036AE:  MOVFF  3A5,03
036B2:  MOVLB  3
036B4:  MOVFF  3A4,FE9
036B8:  MOVFF  3A5,FEA
036BC:  MOVF   FEF,F
036BE:  BZ    36F6
....................       write_ext_eeprom(address,*str); 
036C0:  MOVFF  3A5,03
036C4:  MOVFF  3A4,FE9
036C8:  MOVFF  3A5,FEA
036CC:  MOVFF  FEF,3A6
036D0:  MOVFF  3A3,3AA
036D4:  MOVFF  3A2,3A9
036D8:  MOVFF  3A6,3AB
036DC:  MOVLB  0
036DE:  CALL   0EBC
....................       address++; 
036E2:  MOVLB  3
036E4:  INCF   xA2,F
036E6:  BTFSC  FD8.2
036E8:  INCF   xA3,F
....................       str++; 
036EA:  INCF   xA4,F
036EC:  BTFSC  FD8.2
036EE:  INCF   xA5,F
....................    } 
036F0:  MOVLB  0
036F2:  BRA    36AE
036F4:  MOVLB  3
....................    write_ext_eeprom(address,0); 
036F6:  MOVFF  3A3,3AA
036FA:  MOVFF  3A2,3A9
036FE:  CLRF   xAB
03700:  MOVLB  0
03702:  CALL   0EBC
.................... } 
03706:  RETLW  00
....................  
.................... void write_ext_eeprom16(int16 address, int16 data) 
.................... { 
....................    write_ext_eeprom(address++, make8(data,0)); 
*
00EF2:  MOVLB  3
00EF4:  MOVFF  3A3,03
00EF8:  MOVF   xA2,W
00EFA:  INCF   xA2,F
00EFC:  BTFSC  FD8.2
00EFE:  INCF   xA3,F
00F00:  MOVWF  xA6
00F02:  MOVFF  03,3A7
00F06:  MOVFF  3A4,3A8
00F0A:  MOVFF  03,3AA
00F0E:  MOVWF  xA9
00F10:  MOVFF  3A4,3AB
00F14:  MOVLB  0
00F16:  RCALL  0EBC
....................    write_ext_eeprom(address, make8(data,1)); 
00F18:  MOVFF  3A5,3A6
00F1C:  MOVFF  3A3,3AA
00F20:  MOVFF  3A2,3A9
00F24:  MOVFF  3A5,3AB
00F28:  RCALL  0EBC
.................... } 
00F2A:  RETLW  00
....................  
.................... int16 read_ext_eeprom16(int16 address) 
.................... { 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 val; 
....................    } result; 
....................  
....................    result.b[0]=read_ext_eeprom(address++); 
*
02DC4:  MOVLB  3
02DC6:  MOVFF  3A3,03
02DCA:  MOVF   xA2,W
02DCC:  INCF   xA2,F
02DCE:  BTFSC  FD8.2
02DD0:  INCF   xA3,F
02DD2:  MOVWF  xA6
02DD4:  MOVFF  03,3A7
02DD8:  MOVFF  03,3AB
02DDC:  MOVWF  xAA
02DDE:  MOVLB  0
02DE0:  CALL   0E7E
02DE4:  MOVFF  01,3A4
....................    result.b[1]=read_ext_eeprom(address); 
02DE8:  MOVFF  3A3,3AB
02DEC:  MOVFF  3A2,3AA
02DF0:  CALL   0E7E
02DF4:  MOVFF  01,3A5
....................  
....................    return(result.val); 
02DF8:  MOVLB  3
02DFA:  MOVFF  3A4,01
02DFE:  MOVFF  3A5,02
.................... } 
02E02:  MOVLB  0
02E04:  RETLW  00
....................  
.................... void read_ext_eeprom_string(int16 address, char *str, int8 max) { 
....................    char c; 
....................    do { 
....................       c=read_ext_eeprom(address++); 
*
02D72:  MOVLB  3
02D74:  MOVFF  3A3,03
02D78:  MOVF   xA2,W
02D7A:  INCF   xA2,F
02D7C:  BTFSC  FD8.2
02D7E:  INCF   xA3,F
02D80:  MOVWF  xA8
02D82:  MOVFF  03,3A9
02D86:  MOVFF  03,3AB
02D8A:  MOVWF  xAA
02D8C:  MOVLB  0
02D8E:  CALL   0E7E
02D92:  MOVFF  01,3A7
....................       *str=c; 
02D96:  MOVLB  3
02D98:  MOVFF  3A4,FE9
02D9C:  MOVFF  3A5,FEA
02DA0:  MOVFF  3A7,FEF
....................       str++; 
02DA4:  INCF   xA4,F
02DA6:  BTFSC  FD8.2
02DA8:  INCF   xA5,F
....................    } while ((c)&&(max--)); 
02DAA:  MOVF   xA7,F
02DAC:  BZ    2DB6
02DAE:  MOVF   xA6,W
02DB0:  DECF   xA6,F
02DB2:  XORLW  00
02DB4:  BNZ   2D74
....................    *str=0; 
02DB6:  MOVFF  3A4,FE9
02DBA:  MOVFF  3A5,FEA
02DBE:  CLRF   FEF
.................... } 
02DC0:  MOVLB  0
02DC2:  RETLW  00
....................  
.................... void read_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.v[0]=read_ext_eeprom(address++); 
*
0106A:  MOVLB  3
0106C:  MOVFF  36C,03
01070:  MOVF   x6B,W
01072:  INCF   x6B,F
01074:  BTFSC  FD8.2
01076:  INCF   x6C,F
01078:  MOVWF  x73
0107A:  MOVFF  03,374
0107E:  MOVFF  03,3AB
01082:  MOVWF  xAA
01084:  MOVLB  0
01086:  RCALL  0E7E
01088:  MOVFF  01,36F
....................    temp.v[1]=read_ext_eeprom(address++); 
0108C:  MOVLB  3
0108E:  MOVFF  36C,03
01092:  MOVF   x6B,W
01094:  INCF   x6B,F
01096:  BTFSC  FD8.2
01098:  INCF   x6C,F
0109A:  MOVWF  x73
0109C:  MOVFF  03,374
010A0:  MOVFF  03,3AB
010A4:  MOVWF  xAA
010A6:  MOVLB  0
010A8:  RCALL  0E7E
010AA:  MOVFF  01,370
....................    temp.v[2]=read_ext_eeprom(address++); 
010AE:  MOVLB  3
010B0:  MOVFF  36C,03
010B4:  MOVF   x6B,W
010B6:  INCF   x6B,F
010B8:  BTFSC  FD8.2
010BA:  INCF   x6C,F
010BC:  MOVWF  x73
010BE:  MOVFF  03,374
010C2:  MOVFF  03,3AB
010C6:  MOVWF  xAA
010C8:  MOVLB  0
010CA:  RCALL  0E7E
010CC:  MOVFF  01,371
....................    temp.v[3]=read_ext_eeprom(address); 
010D0:  MOVFF  36C,3AB
010D4:  MOVFF  36B,3AA
010D8:  RCALL  0E7E
010DA:  MOVFF  01,372
....................    ip->Val=temp.Val; 
010DE:  MOVLB  3
010E0:  MOVFF  36D,FE9
010E4:  MOVFF  36E,FEA
010E8:  MOVFF  36F,FEF
010EC:  MOVFF  370,FEC
010F0:  MOVFF  371,FEC
010F4:  MOVFF  372,FEC
.................... } 
010F8:  MOVLB  0
010FA:  RETLW  00
....................  
.................... void write_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.Val=ip->Val; 
*
03FF6:  MOVLB  3
03FF8:  MOVFF  36D,FE9
03FFC:  MOVFF  36E,FEA
04000:  MOVFF  FEF,00
04004:  MOVFF  FEC,01
04008:  MOVFF  FEC,02
0400C:  MOVFF  FEC,03
04010:  MOVFF  03,372
04014:  MOVFF  02,371
04018:  MOVFF  01,370
0401C:  MOVFF  00,36F
....................    write_ext_eeprom(address++,temp.v[0]); 
04020:  MOVFF  36C,03
04024:  MOVF   x6B,W
04026:  INCF   x6B,F
04028:  BTFSC  FD8.2
0402A:  INCF   x6C,F
0402C:  MOVWF  x73
0402E:  MOVFF  03,374
04032:  MOVFF  03,3AA
04036:  MOVWF  xA9
04038:  MOVFF  36F,3AB
0403C:  MOVLB  0
0403E:  CALL   0EBC
....................    write_ext_eeprom(address++,temp.v[1]); 
04042:  MOVLB  3
04044:  MOVFF  36C,03
04048:  MOVF   x6B,W
0404A:  INCF   x6B,F
0404C:  BTFSC  FD8.2
0404E:  INCF   x6C,F
04050:  MOVWF  x73
04052:  MOVFF  03,374
04056:  MOVFF  03,3AA
0405A:  MOVWF  xA9
0405C:  MOVFF  370,3AB
04060:  MOVLB  0
04062:  CALL   0EBC
....................    write_ext_eeprom(address++,temp.v[2]); 
04066:  MOVLB  3
04068:  MOVFF  36C,03
0406C:  MOVF   x6B,W
0406E:  INCF   x6B,F
04070:  BTFSC  FD8.2
04072:  INCF   x6C,F
04074:  MOVWF  x73
04076:  MOVFF  03,374
0407A:  MOVFF  03,3AA
0407E:  MOVWF  xA9
04080:  MOVFF  371,3AB
04084:  MOVLB  0
04086:  CALL   0EBC
....................    write_ext_eeprom(address,temp.v[3]); 
0408A:  MOVFF  36C,3AA
0408E:  MOVFF  36B,3A9
04092:  MOVFF  372,3AB
04096:  CALL   0EBC
.................... } 
0409A:  GOTO   4158 (RETURN)
....................  
.................... //clears the EEPROM where ISP settings are saved to prevent others from getting your ISP configuration 
.................... void clear_ee(void) { 
....................    int16 i; 
....................    fprintf(USER,"\r\n\n\nResetting EEPROM..."); 
*
00F2C:  MOVLB  3
00F2E:  CLRF   x62
00F30:  MOVF   x62,W
00F32:  MOVLB  0
00F34:  CALL   012E
00F38:  MOVLB  3
00F3A:  INCF   x62,F
00F3C:  MOVLB  0
00F3E:  RCALL  0EB4
00F40:  MOVLW  17
00F42:  MOVLB  3
00F44:  SUBWF  x62,W
00F46:  BNZ   0F30
....................    for (i=0;i<EE_LAST;i++) { 
00F48:  CLRF   x61
00F4A:  CLRF   x60
00F4C:  MOVF   x61,W
00F4E:  SUBLW  02
00F50:  BNC   0F72
00F52:  BNZ   0F5A
00F54:  MOVF   x60,W
00F56:  SUBLW  21
00F58:  BNC   0F72
....................       write_ext_eeprom(i,0); 
00F5A:  MOVFF  361,3AA
00F5E:  MOVFF  360,3A9
00F62:  CLRF   xAB
00F64:  MOVLB  0
00F66:  RCALL  0EBC
....................    } 
00F68:  MOVLB  3
00F6A:  INCF   x60,F
00F6C:  BTFSC  FD8.2
00F6E:  INCF   x61,F
00F70:  BRA    0F4C
....................    write_ext_eeprom(EE_NIC_DHCP, 1); 
00F72:  CLRF   xAA
00F74:  MOVLW  C0
00F76:  MOVWF  xA9
00F78:  MOVLW  01
00F7A:  MOVWF  xAB
00F7C:  MOVLB  0
00F7E:  RCALL  0EBC
....................  
....................    write_ext_eeprom(EE_NIC_MAC + 0, 0x00); 
00F80:  MOVLB  3
00F82:  CLRF   xAA
00F84:  MOVLW  CD
00F86:  MOVWF  xA9
00F88:  CLRF   xAB
00F8A:  MOVLB  0
00F8C:  RCALL  0EBC
....................    write_ext_eeprom(EE_NIC_MAC + 1, 0x03); 
00F8E:  MOVLB  3
00F90:  CLRF   xAA
00F92:  MOVLW  CE
00F94:  MOVWF  xA9
00F96:  MOVLW  03
00F98:  MOVWF  xAB
00F9A:  MOVLB  0
00F9C:  RCALL  0EBC
....................    write_ext_eeprom(EE_NIC_MAC + 2, 0x04); 
00F9E:  MOVLB  3
00FA0:  CLRF   xAA
00FA2:  MOVLW  CF
00FA4:  MOVWF  xA9
00FA6:  MOVLW  04
00FA8:  MOVWF  xAB
00FAA:  MOVLB  0
00FAC:  RCALL  0EBC
....................    write_ext_eeprom(EE_NIC_MAC + 3, 0x05); 
00FAE:  MOVLB  3
00FB0:  CLRF   xAA
00FB2:  MOVLW  D0
00FB4:  MOVWF  xA9
00FB6:  MOVLW  05
00FB8:  MOVWF  xAB
00FBA:  MOVLB  0
00FBC:  RCALL  0EBC
....................    write_ext_eeprom(EE_NIC_MAC + 4, 0x06); 
00FBE:  MOVLB  3
00FC0:  CLRF   xAA
00FC2:  MOVLW  D1
00FC4:  MOVWF  xA9
00FC6:  MOVLW  06
00FC8:  MOVWF  xAB
00FCA:  MOVLB  0
00FCC:  RCALL  0EBC
....................    write_ext_eeprom(EE_NIC_MAC + 5, 0x07); 
00FCE:  MOVLB  3
00FD0:  CLRF   xAA
00FD2:  MOVLW  D2
00FD4:  MOVWF  xA9
00FD6:  MOVLW  07
00FD8:  MOVWF  xAB
00FDA:  MOVLB  0
00FDC:  RCALL  0EBC
....................  
....................    write_ext_eeprom16(EE_SMTP_PORT, 25); 
00FDE:  MOVLB  3
00FE0:  CLRF   xA3
00FE2:  MOVLW  D7
00FE4:  MOVWF  xA2
00FE6:  CLRF   xA5
00FE8:  MOVLW  19
00FEA:  MOVWF  xA4
00FEC:  MOVLB  0
00FEE:  RCALL  0EF2
....................  
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, 5000); 
00FF0:  MOVLW  02
00FF2:  MOVLB  3
00FF4:  MOVWF  xA3
00FF6:  MOVLW  1D
00FF8:  MOVWF  xA2
00FFA:  MOVLW  13
00FFC:  MOVWF  xA5
00FFE:  MOVLW  88
01000:  MOVWF  xA4
01002:  MOVLB  0
01004:  RCALL  0EF2
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, 5000); 
01006:  MOVLW  02
01008:  MOVLB  3
0100A:  MOVWF  xA3
0100C:  MOVLW  1F
0100E:  MOVWF  xA2
01010:  MOVLW  13
01012:  MOVWF  xA5
01014:  MOVLW  88
01016:  MOVWF  xA4
01018:  MOVLB  0
0101A:  RCALL  0EF2
....................  
....................    write_ext_eeprom(EE_MAGIC, 0x55); 
0101C:  MOVLW  02
0101E:  MOVLB  3
01020:  MOVWF  xAA
01022:  MOVLW  21
01024:  MOVWF  xA9
01026:  MOVLW  55
01028:  MOVWF  xAB
0102A:  MOVLB  0
0102C:  RCALL  0EBC
....................  
....................    fprintf(USER,"\r\nEEPROM Cleared.  Reseting MCU...\r\n"); 
0102E:  MOVLB  3
01030:  CLRF   x62
01032:  MOVF   x62,W
01034:  MOVLB  0
01036:  CALL   0160
0103A:  MOVLB  3
0103C:  INCF   x62,F
0103E:  MOVLB  0
01040:  RCALL  0EB4
01042:  MOVLW  24
01044:  MOVLB  3
01046:  SUBWF  x62,W
01048:  BNZ   1032
....................    reset_cpu(); 
0104A:  RESET
.................... } 
0104C:  MOVLB  0
0104E:  RETLW  00
....................  
.................... void init_eeprom_defaults(void) 
.................... { 
....................    if (read_ext_eeprom(EE_MAGIC) != 0x55) 
01050:  MOVLW  02
01052:  MOVLB  3
01054:  MOVWF  xAB
01056:  MOVLW  21
01058:  MOVWF  xAA
0105A:  MOVLB  0
0105C:  RCALL  0E7E
0105E:  MOVF   01,W
01060:  SUBLW  55
01062:  BZ    1066
....................       clear_ee(); 
01064:  RCALL  0F2C
.................... } 
01066:  GOTO   2EF2 (RETURN)
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... int16 SMTP_PORT; 
.................... char SMTP_HOST_NAME[64]; 
.................... char SMTP_TO_ADDR[64];     //To address of your e-mail 
.................... char SMTP_FROM_ADDR[64];       //From address of your e-mail 
.................... char SMTP_SUBJECT[64];                 //Subject of your e-mail 
.................... char SMTP_BODY[64];      //Body of your e-mail 
....................  
.................... void init_smtp_settings(void) { 
....................  read_ext_eeprom_string(EE_SMTP_HOSTNAME,SMTP_HOST_NAME,64); 
*
02E06:  MOVLB  3
02E08:  CLRF   xA3
02E0A:  MOVLW  D9
02E0C:  MOVWF  xA2
02E0E:  MOVLW  02
02E10:  MOVWF  xA5
02E12:  MOVLW  13
02E14:  MOVWF  xA4
02E16:  MOVLW  40
02E18:  MOVWF  xA6
02E1A:  MOVLB  0
02E1C:  RCALL  2D72
....................  SMTP_PORT=read_ext_eeprom16(EE_SMTP_PORT); 
02E1E:  MOVLB  3
02E20:  CLRF   xA3
02E22:  MOVLW  D7
02E24:  MOVWF  xA2
02E26:  MOVLB  0
02E28:  RCALL  2DC4
02E2A:  MOVFF  02,212
02E2E:  MOVFF  01,211
....................  read_ext_eeprom_string(EE_SMTP_TO,SMTP_TO_ADDR,64); 
02E32:  MOVLW  01
02E34:  MOVLB  3
02E36:  MOVWF  xA3
02E38:  MOVLW  19
02E3A:  MOVWF  xA2
02E3C:  MOVLW  02
02E3E:  MOVWF  xA5
02E40:  MOVLW  53
02E42:  MOVWF  xA4
02E44:  MOVLW  40
02E46:  MOVWF  xA6
02E48:  MOVLB  0
02E4A:  RCALL  2D72
....................  read_ext_eeprom_string(EE_SMTP_FROM,SMTP_FROM_ADDR,64); 
02E4C:  MOVLW  01
02E4E:  MOVLB  3
02E50:  MOVWF  xA3
02E52:  MOVLW  59
02E54:  MOVWF  xA2
02E56:  MOVLW  02
02E58:  MOVWF  xA5
02E5A:  MOVLW  93
02E5C:  MOVWF  xA4
02E5E:  MOVLW  40
02E60:  MOVWF  xA6
02E62:  MOVLB  0
02E64:  RCALL  2D72
....................  read_ext_eeprom_string(EE_SMTP_SUBJECT,SMTP_SUBJECT,64); 
02E66:  MOVLW  01
02E68:  MOVLB  3
02E6A:  MOVWF  xA3
02E6C:  MOVLW  99
02E6E:  MOVWF  xA2
02E70:  MOVLW  02
02E72:  MOVWF  xA5
02E74:  MOVLW  D3
02E76:  MOVWF  xA4
02E78:  MOVLW  40
02E7A:  MOVWF  xA6
02E7C:  MOVLB  0
02E7E:  RCALL  2D72
....................  read_ext_eeprom_string(EE_SMTP_BODY,SMTP_BODY,64); 
02E80:  MOVLW  01
02E82:  MOVLB  3
02E84:  MOVWF  xA3
02E86:  MOVLW  D9
02E88:  MOVWF  xA2
02E8A:  MOVLW  03
02E8C:  MOVWF  xA5
02E8E:  MOVLW  13
02E90:  MOVWF  xA4
02E92:  MOVLW  40
02E94:  MOVWF  xA6
02E96:  MOVLB  0
02E98:  RCALL  2D72
.................... } 
02E9A:  RETLW  00
.................... #endif 
....................  
.................... //Initializes hardware, stack, default IP address and MAC address. 
.................... void init(void) { 
....................    setup_wdt(WDT_OFF); 
02E9C:  BCF    FD1.0
....................    set_tris_a(0xFF); 
02E9E:  MOVLW  FF
02EA0:  MOVWF  F92
....................    set_tris_b(0xFF); 
02EA2:  MOVWF  F93
....................    set_tris_c(0xFF); 
02EA4:  MOVWF  F94
....................    set_tris_d(0xFF); 
02EA6:  MOVWF  F95
....................    set_tris_e(0xFF); 
02EA8:  BSF    F96.0
02EAA:  BSF    F96.1
02EAC:  BSF    F96.2
....................  
....................  #if STACK_USE_CCS_PICNET 
....................    set_tris_f(0xFF); 
....................    setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................  #elif STACK_USE_CCS_PICENS 
....................    setup_adc_ports(AN0); 
02EAE:  MOVF   FC1,W
02EB0:  ANDLW  C0
02EB2:  IORLW  0E
02EB4:  MOVWF  FC1
....................  #elif STACK_USE_CCS_PICEEC 
....................    setup_adc_ports(AN0_TO_AN2); 
....................  #else 
....................    #error You need to initialize your I/O ports here. 
....................  #endif 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
02EB6:  MOVF   FC0,W
02EB8:  ANDLW  C0
02EBA:  IORLW  07
02EBC:  MOVWF  FC0
02EBE:  BCF    FC0.7
02EC0:  BSF    FC2.0
....................    set_adc_channel(ADC_CHAN_0); 
02EC2:  MOVLW  00
02EC4:  MOVWF  01
02EC6:  MOVF   FC2,W
02EC8:  ANDLW  C3
02ECA:  IORWF  01,W
02ECC:  MOVWF  FC2
....................  
....................    OUTPUT_DRIVE_MACRO(PIN_C6); 
02ECE:  BCF    F94.6
....................    //OUTPUT_FLOAT_MACRO(PIN_C7); 
....................  
....................    OUTPUT_DRIVE_MACRO(USER_LED1); 
02ED0:  BCF    F92.5
....................    output_high(USER_LED1); 
02ED2:  BSF    F89.5
....................     
....................    OUTPUT_DRIVE_MACRO(USER_LED2); 
02ED4:  BCF    F93.4
....................    output_high(USER_LED2); 
02ED6:  BSF    F8A.4
....................  
....................  
....................   #if defined(USER_LED3) 
....................    OUTPUT_DRIVE_MACRO(USER_LED3); 
02ED8:  BCF    F93.5
....................    output_high(USER_LED3); 
02EDA:  BSF    F8A.5
....................   #endif 
....................  
....................   #if defined(USER_BUTTON1) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON1); 
02EDC:  BSF    F92.4
....................   #endif 
....................  
....................   #if defined(USER_BUTTON2) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON2); 
....................   #endif 
....................  
....................  #if defined(EEPROM_SELECT) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_SELECT); 
02EDE:  BCF    F93.3
....................  #endif 
....................  
....................  #if defined(EEPROM_DI) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_DI); 
02EE0:  BCF    F94.5
....................  #endif 
....................  
....................  #if defined(EEPROM_DO) 
....................   OUTPUT_FLOAT_MACRO(EEPROM_DO); 
02EE2:  BSF    F94.4
....................  #endif 
....................  
....................  #if defined(EEPROM_CLK) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_CLK); 
02EE4:  BCF    F94.3
....................  #endif 
....................  
....................  #if defined(MMC_SELECT) 
....................   OUTPUT_DRIVE_MACRO(MMC_SELECT); 
....................  #endif 
....................  
....................  
....................  
....................   #if STACK_USE_MCPENC 
....................    //Normally StackInit() will call this, but since we are sharing the same 
....................    //SPI pins for the ENC and EEPROM, we need to call it now so we can use 
....................    //the EEPROM before we do a StackInit(). 
....................    ENCSPIInit(); 
02EE6:  CALL   0DA0
....................   #endif 
....................  
....................    init_ext_eeprom(); 
02EEA:  GOTO   0E36
....................    init_eeprom_defaults(); 
02EEE:  GOTO   1050
....................  
....................    // 
....................    // Load default configuration into RAM. 
....................    // 
....................  
....................  #if STACK_USE_PPP 
....................  read_ext_eeprom_string(EE_ISP_PHONENUMBER,ppp_phonenumber,64); 
....................  read_ext_eeprom_string(EE_ISP_USERNAME,ppp_username,64); 
....................  read_ext_eeprom_string(EE_ISP_PASSWORD,ppp_password,64); 
....................  #elif STACK_USE_MAC 
....................    read_ext_eeprom_ip(EE_NIC_IP, &AppConfig.MyIPAddr); 
02EF2:  MOVLB  3
02EF4:  CLRF   x6C
02EF6:  MOVLW  C5
02EF8:  MOVWF  x6B
02EFA:  CLRF   x6E
02EFC:  MOVLW  18
02EFE:  MOVWF  x6D
02F00:  MOVLB  0
02F02:  CALL   106A
....................    read_ext_eeprom_ip(EE_NIC_NETMASK, &AppConfig.MyMask); 
02F06:  MOVLB  3
02F08:  CLRF   x6C
02F0A:  MOVLW  C9
02F0C:  MOVWF  x6B
02F0E:  CLRF   x6E
02F10:  MOVLW  22
02F12:  MOVWF  x6D
02F14:  MOVLB  0
02F16:  CALL   106A
....................    read_ext_eeprom_ip(EE_NIC_GATEWAY, &AppConfig.MyGateway); 
02F1A:  MOVLB  3
02F1C:  CLRF   x6C
02F1E:  MOVLW  C1
02F20:  MOVWF  x6B
02F22:  CLRF   x6E
02F24:  MOVLW  26
02F26:  MOVWF  x6D
02F28:  MOVLB  0
02F2A:  CALL   106A
....................   #if STACK_USE_DNS 
....................    read_ext_eeprom_ip(EE_DNS, &AppConfig.PrimaryDNSServer); 
02F2E:  MOVLB  3
02F30:  CLRF   x6C
02F32:  MOVLW  D3
02F34:  MOVWF  x6B
02F36:  CLRF   x6E
02F38:  MOVLW  2A
02F3A:  MOVWF  x6D
02F3C:  MOVLB  0
02F3E:  CALL   106A
....................   #endif 
....................  
....................    AppConfig.MyMACAddr.v[0]    = read_ext_eeprom(EE_NIC_MAC + 0); 
02F42:  MOVLB  3
02F44:  CLRF   xAB
02F46:  MOVLW  CD
02F48:  MOVWF  xAA
02F4A:  MOVLB  0
02F4C:  CALL   0E7E
02F50:  MOVFF  01,1C
....................    AppConfig.MyMACAddr.v[1]    = read_ext_eeprom(EE_NIC_MAC + 1); 
02F54:  MOVLB  3
02F56:  CLRF   xAB
02F58:  MOVLW  CE
02F5A:  MOVWF  xAA
02F5C:  MOVLB  0
02F5E:  CALL   0E7E
02F62:  MOVFF  01,1D
....................    AppConfig.MyMACAddr.v[2]    = read_ext_eeprom(EE_NIC_MAC + 2); 
02F66:  MOVLB  3
02F68:  CLRF   xAB
02F6A:  MOVLW  CF
02F6C:  MOVWF  xAA
02F6E:  MOVLB  0
02F70:  CALL   0E7E
02F74:  MOVFF  01,1E
....................    AppConfig.MyMACAddr.v[3]    = read_ext_eeprom(EE_NIC_MAC + 3); 
02F78:  MOVLB  3
02F7A:  CLRF   xAB
02F7C:  MOVLW  D0
02F7E:  MOVWF  xAA
02F80:  MOVLB  0
02F82:  CALL   0E7E
02F86:  MOVFF  01,1F
....................    AppConfig.MyMACAddr.v[4]    = read_ext_eeprom(EE_NIC_MAC + 4); 
02F8A:  MOVLB  3
02F8C:  CLRF   xAB
02F8E:  MOVLW  D1
02F90:  MOVWF  xAA
02F92:  MOVLB  0
02F94:  CALL   0E7E
02F98:  MOVFF  01,20
....................    AppConfig.MyMACAddr.v[5]    = read_ext_eeprom(EE_NIC_MAC + 5); 
02F9C:  MOVLB  3
02F9E:  CLRF   xAB
02FA0:  MOVLW  D2
02FA2:  MOVWF  xAA
02FA4:  MOVLB  0
02FA6:  CALL   0E7E
02FAA:  MOVFF  01,21
....................  
....................    #if STACK_USE_DHCP 
....................    if (!read_ext_eeprom(EE_NIC_DHCP)) 
02FAE:  MOVLB  3
02FB0:  CLRF   xAB
02FB2:  MOVLW  C0
02FB4:  MOVWF  xAA
02FB6:  MOVLB  0
02FB8:  CALL   0E7E
02FBC:  MOVF   01,F
02FBE:  BNZ   2FC4
....................       DHCPDisable(); 
02FC0:  MOVLW  08
02FC2:  MOVWF  x87
....................    #endif 
....................  #endif 
....................  
....................    StackInit(); 
02FC4:  BRA    2BE8
....................  
.................... #if STACK_USE_PICDEM_LCD 
....................    lcd_init(); 
02FC6:  BRA    2CE6
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................    init_smtp_settings(); 
02FC8:  RCALL  2E06
.................... #endif 
.................... } 
02FCA:  GOTO   9B9A (RETURN)
....................  
.................... #if STACK_USE_CCS_PICENS 
.................... void hardware_test(void) 
.................... { 
....................    int1 fail_nic=0,fail_ee=0; 
*
03CA0:  MOVLB  3
03CA2:  BCF    x60.0
03CA4:  BCF    x60.1
....................  
....................  
....................    fprintf(USER,"\r\n\n\nENC28J60 (U4) TEST: "); 
03CA6:  CLRF   x61
03CA8:  MOVF   x61,W
03CAA:  MOVLB  0
03CAC:  CALL   01A0
03CB0:  MOVLB  3
03CB2:  INCF   x61,F
03CB4:  MOVLB  0
03CB6:  CALL   0EB4
03CBA:  MOVLW  18
03CBC:  MOVLB  3
03CBE:  SUBWF  x61,W
03CC0:  BNZ   3CA8
....................    SPISelectEthernet(); 
03CC2:  BCF    F8B.1
....................    BankSel(MAADR1); 
03CC4:  MOVLW  03
03CC6:  MOVLB  4
03CC8:  MOVWF  x0E
03CCA:  MOVLW  04
03CCC:  MOVWF  x0D
03CCE:  MOVLB  0
03CD0:  CALL   11A8
....................    WriteReg(MAADR1 + 0, 0x15); 
03CD4:  MOVLW  04
03CD6:  MOVLB  4
03CD8:  MOVWF  x10
03CDA:  MOVLW  15
03CDC:  MOVWF  x11
03CDE:  MOVLB  0
03CE0:  CALL   115A
....................    WriteReg(MAADR1 + 1, 0x26); 
03CE4:  MOVLW  05
03CE6:  MOVLB  4
03CE8:  MOVWF  x10
03CEA:  MOVLW  26
03CEC:  MOVWF  x11
03CEE:  MOVLB  0
03CF0:  CALL   115A
....................    WriteReg(MAADR1 + 2, 0x37); 
03CF4:  MOVLW  06
03CF6:  MOVLB  4
03CF8:  MOVWF  x10
03CFA:  MOVLW  37
03CFC:  MOVWF  x11
03CFE:  MOVLB  0
03D00:  CALL   115A
....................    if (ReadMACReg(MAADR1 + 1).Val != 0x26) 
03D04:  MOVLW  05
03D06:  MOVLB  3
03D08:  MOVWF  x68
03D0A:  MOVLB  0
03D0C:  CALL   11DE
03D10:  MOVFF  01,361
03D14:  MOVLB  3
03D16:  MOVF   01,W
03D18:  SUBLW  26
03D1A:  BZ    3D1E
....................       fail_nic = TRUE; 
03D1C:  BSF    x60.0
....................    SPIUnselectEthernet(); 
03D1E:  BSF    F8B.1
....................    if (fail_nic) 
03D20:  BTFSS  x60.0
03D22:  BRA    3D42
....................       fprintf(USER,"FAIL"); 
03D24:  CLRF   x61
03D26:  MOVF   x61,W
03D28:  MOVLB  0
03D2A:  CALL   01D4
03D2E:  MOVLB  3
03D30:  INCF   x61,F
03D32:  MOVLB  0
03D34:  CALL   0EB4
03D38:  MOVLW  04
03D3A:  MOVLB  3
03D3C:  SUBWF  x61,W
03D3E:  BNZ   3D26
....................    else 
03D40:  BRA    3D5E
....................       fprintf(USER,"PASS"); 
03D42:  CLRF   x61
03D44:  MOVF   x61,W
03D46:  MOVLB  0
03D48:  CALL   01F4
03D4C:  MOVLB  3
03D4E:  INCF   x61,F
03D50:  MOVLB  0
03D52:  CALL   0EB4
03D56:  MOVLW  04
03D58:  MOVLB  3
03D5A:  SUBWF  x61,W
03D5C:  BNZ   3D44
....................  
....................    write_ext_eeprom(5000,0x55); 
03D5E:  MOVLW  13
03D60:  MOVWF  xAA
03D62:  MOVLW  88
03D64:  MOVWF  xA9
03D66:  MOVLW  55
03D68:  MOVWF  xAB
03D6A:  MOVLB  0
03D6C:  CALL   0EBC
....................    write_ext_eeprom(5001,0x66); 
03D70:  MOVLW  13
03D72:  MOVLB  3
03D74:  MOVWF  xAA
03D76:  MOVLW  89
03D78:  MOVWF  xA9
03D7A:  MOVLW  66
03D7C:  MOVWF  xAB
03D7E:  MOVLB  0
03D80:  CALL   0EBC
....................    write_ext_eeprom(5002,0x77); 
03D84:  MOVLW  13
03D86:  MOVLB  3
03D88:  MOVWF  xAA
03D8A:  MOVLW  8A
03D8C:  MOVWF  xA9
03D8E:  MOVLW  77
03D90:  MOVWF  xAB
03D92:  MOVLB  0
03D94:  CALL   0EBC
....................    fprintf(USER,"\r\nAT25256 (U7) TEST: "); 
03D98:  MOVLB  3
03D9A:  CLRF   x61
03D9C:  MOVF   x61,W
03D9E:  MOVLB  0
03DA0:  CALL   0214
03DA4:  MOVLB  3
03DA6:  INCF   x61,F
03DA8:  MOVLB  0
03DAA:  CALL   0EB4
03DAE:  MOVLW  15
03DB0:  MOVLB  3
03DB2:  SUBWF  x61,W
03DB4:  BNZ   3D9C
....................    if (read_ext_eeprom(5001)==0x66) 
03DB6:  MOVLW  13
03DB8:  MOVWF  xAB
03DBA:  MOVLW  89
03DBC:  MOVWF  xAA
03DBE:  MOVLB  0
03DC0:  CALL   0E7E
03DC4:  MOVF   01,W
03DC6:  SUBLW  66
03DC8:  BNZ   3DEC
....................       fprintf(USER,"PASS"); 
03DCA:  MOVLB  3
03DCC:  CLRF   x61
03DCE:  MOVF   x61,W
03DD0:  MOVLB  0
03DD2:  CALL   01F4
03DD6:  MOVLB  3
03DD8:  INCF   x61,F
03DDA:  MOVLB  0
03DDC:  CALL   0EB4
03DE0:  MOVLW  04
03DE2:  MOVLB  3
03DE4:  SUBWF  x61,W
03DE6:  BNZ   3DCE
....................    else 
03DE8:  BRA    3E0C
03DEA:  MOVLB  0
....................    { 
....................       fprintf(USER,"FAIL"); 
03DEC:  MOVLB  3
03DEE:  CLRF   x61
03DF0:  MOVF   x61,W
03DF2:  MOVLB  0
03DF4:  CALL   01D4
03DF8:  MOVLB  3
03DFA:  INCF   x61,F
03DFC:  MOVLB  0
03DFE:  CALL   0EB4
03E02:  MOVLW  04
03E04:  MOVLB  3
03E06:  SUBWF  x61,W
03E08:  BNZ   3DF0
....................       fail_ee=TRUE; 
03E0A:  BSF    x60.1
....................    } 
....................  
....................    if (fail_nic && fail_ee) 
03E0C:  BTFSS  x60.0
03E0E:  BRA    3E30
03E10:  BTFSS  x60.1
03E12:  BRA    3E30
....................       fprintf(USER,"\r\nBOTH ENC28J60 AND AT25256 FAIL, POSSIBLE 74HC08 (U5) FAILURE"); 
03E14:  CLRF   x61
03E16:  MOVF   x61,W
03E18:  MOVLB  0
03E1A:  CALL   0244
03E1E:  MOVLB  3
03E20:  INCF   x61,F
03E22:  MOVLB  0
03E24:  CALL   0EB4
03E28:  MOVLW  3E
03E2A:  MOVLB  3
03E2C:  SUBWF  x61,W
03E2E:  BNZ   3E16
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL A4 IS PRESSED"); 
03E30:  CLRF   x61
03E32:  MOVF   x61,W
03E34:  MOVLB  0
03E36:  CALL   029E
03E3A:  MOVLB  3
03E3C:  INCF   x61,F
03E3E:  MOVLB  0
03E40:  CALL   0EB4
03E44:  MOVLW  23
03E46:  MOVLB  3
03E48:  SUBWF  x61,W
03E4A:  BNZ   3E32
....................    output_high(USER_LED1); 
03E4C:  BSF    F89.5
....................    output_high(USER_LED2); 
03E4E:  BSF    F8A.4
....................    output_high(USER_LED3); 
03E50:  BSF    F8A.5
....................    while(input(PIN_A4)) 
....................    { 
03E52:  BTFSS  F80.4
03E54:  BRA    3E6A
....................       output_toggle(USER_LED1); 
03E56:  BTG    F89.5
....................       output_toggle(USER_LED2); 
03E58:  BTG    F8A.4
....................       output_toggle(USER_LED3); 
03E5A:  BTG    F8A.5
....................       delay_ms(250); 
03E5C:  MOVLW  FA
03E5E:  MOVWF  x65
03E60:  MOVLB  0
03E62:  CALL   0DF4
....................    } 
03E66:  MOVLB  3
03E68:  BRA    3E52
....................  
....................    fprintf(USER,"\r\n\nRESETING BOARD\r\n\n"); 
03E6A:  CLRF   x61
03E6C:  MOVF   x61,W
03E6E:  MOVLB  0
03E70:  CALL   02DC
03E74:  MOVLB  3
03E76:  INCF   x61,F
03E78:  MOVLB  0
03E7A:  CALL   0EB4
03E7E:  MOVLW  14
03E80:  MOVLB  3
03E82:  SUBWF  x61,W
03E84:  BNZ   3E6C
....................    reset_cpu(); 
03E86:  RESET
.................... } 
03E88:  MOVLB  0
03E8A:  GOTO   43DA (RETURN)
.................... #elif STACK_USE_CCS_PICNET 
.................... void hardware_test(void) 
.................... { 
....................    char modemStr[]="AT"; 
....................  
....................    fprintf(USER, "\r\n\n"); 
....................  
.................... #if STACK_USE_MAC 
....................    fprintf(USER, "\r\nNIC RTL8019AS (U603) TEST: "); 
....................    NICPut(CMDR, 0x61); // CMDR = ; Select Page 1 
....................    NICPut(PAR0, 0x15);  //PAR0 = 0x01 
....................    NICPut(PAR0+1, 0x26); 
....................    NICPut(PAR0+2, 0x37); 
....................    NICPut(PAR0+3, 0x48); 
....................    NICPut(PAR0+4, 0x59); 
....................    NICPut(PAR0+5, 0x6A); 
....................    if (NICGet(0x01+3) == 0x48) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nMODEM (U1 & U7) TEST: "); 
....................    if (modem_at_command(modemStr, 2000) == MODEM_OK) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
....................    fprintf(USER,"\r\n24LC256 (U103) TEST: "); 
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
....................  
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B0 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B0)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B1 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B1)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................  
....................    fprintf(USER,"\r\n\nRESETING BOARD\r\n\n"); 
....................    reset_cpu(); 
.................... } 
.................... #else   //PICEEC 
.................... void set_tris_variable(int16 fullPin, int1 new) 
.................... { 
....................    int *ptr = 0xF92; 
....................    int port,pin; 
....................  
....................    fullPin -=  (int16)PIN_A0; 
....................    port = fullPin / 8; 
....................    pin = fullPin % 8; 
....................  
....................    ptr += port; 
....................  
....................    if (new) 
....................       *ptr |= (1 << pin); 
....................    else 
....................       *ptr &= ~(1 << pin); 
.................... } 
.................... #define output_float_variable(x) set_tris_variable(x,1) 
.................... #define output_drive_variable(x) set_tris_variable(x,0) 
.................... void get_pin_string(int16 fullPin, char *str) 
.................... { 
....................    int port,pin; 
....................    fullPin -=  (int16)PIN_A0; 
....................    port = fullPin / 8; 
....................    pin = fullPin % 8; 
....................    sprintf(str, "PIN_"); 
....................    port += 'A'; 
....................    pin += '0'; 
....................    str[4]=port; 
....................    str[5]=pin; 
....................    str[6]=0; 
.................... } 
.................... int1 hardware_io_test_pin(int16 pin1, int16 pin2) 
.................... { 
....................    int fail=0; 
....................    char str[8]; 
....................  
....................    output_float_variable(pin2); 
....................    output_drive_variable(pin1); 
....................    delay_us(100); 
....................    if (input(pin2)) 
....................       fail |= 1; 
....................  
....................    output_high(pin1); 
....................    delay_us(100); 
....................    if (!input(pin2)) 
....................       fail |= 2; 
....................  
....................    output_low(pin1); 
....................  
....................    output_float_variable(pin1); 
....................    output_drive_variable(pin2); 
....................    delay_us(100); 
....................    if (input(pin1)) 
....................       fail |= 4; 
....................  
....................    output_high(pin2); 
....................    delay_us(100); 
....................    if (!input(pin1)) 
....................       fail |= 8; 
....................  
....................    output_low(pin2); 
....................  
....................    if (fail) 
....................    { 
....................       get_pin_string(pin1, str); 
....................       fprintf(USER, "\r\n%s <-> ", str); 
....................       get_pin_string(pin2, str); 
....................       fprintf(USER, "%s FAIL [%X]", str, fail); 
....................    } 
....................  
....................    return(fail != 0); 
.................... } 
....................  
.................... int1 hardware_io_test(void) 
.................... { 
....................    int fail=0; 
....................  
....................    output_a(0); 
....................    output_b(0); 
....................    output_d(0); 
....................    output_e(0); 
....................    output_g(0); 
....................  
....................    fail |= hardware_io_test_pin(PIN_D1, PIN_D0); 
....................    fail |= hardware_io_test_pin(PIN_G4, PIN_D2); 
....................    fail |= hardware_io_test_pin(PIN_E1, PIN_E0); 
....................    fail |= hardware_io_test_pin(PIN_E3, PIN_E2); 
....................    fail |= hardware_io_test_pin(PIN_E5, PIN_E4); 
....................    fail |= hardware_io_test_pin(PIN_B1, PIN_B0); 
....................    fail |= hardware_io_test_pin(PIN_B3, PIN_B2); 
....................    fail |= hardware_io_test_pin(PIN_B5, PIN_B4); 
....................    fail |= hardware_io_test_pin(PIN_A5, PIN_A4); 
....................  
....................    return(fail); 
.................... } 
....................  
.................... void hardware_test(void) 
.................... { 
....................    int1 fail_ee=0; 
....................  
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    fprintf(USER,"\r\n\n\nAT25256 (U7) TEST: "); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................    { 
....................       fprintf(USER,"FAIL"); 
....................       fail_ee=TRUE; 
....................    } 
....................  
....................    set_adc_channel(ADC_CHAN_0); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE LEFT."); 
....................    while(read_adc() > 0x08); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE RIGHT."); 
....................    while(read_adc() < 0xF8); 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL A4 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    output_high(USER_LED3); 
....................    while(input(PIN_A4)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       output_toggle(USER_LED3); 
....................       delay_ms(250); 
....................    } 
....................  
....................    fprintf(USER, "\r\nTESTING I/O HEADER (J4): "); 
....................    if (hardware_io_test()) 
....................       fprintf(USER, "\r\nI/O HEADER (J4): FAIL!!!"); 
....................    else 
....................       fprintf(USER, "PASS"); 
....................  
....................    fprintf(USER,"\r\n\nRESETING BOARD\r\n\n"); 
....................    delay_ms(15); 
....................    reset_cpu(); 
.................... } 
.................... #endif 
....................  
.................... #include "ccshelperui.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                       CCSHELPERUI.C                               //// 
.................... ////                                                                   //// 
.................... //// More Helper functions and definitions for using CCS's example     //// 
.................... //// programs   These routines are more focused on the user interface  //// 
.................... //// needed to get and save setting from the user.                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void ui_disp_ip_user(IP_ADDR *ip) { 
....................    fprintf(USER,"%U.%U.%U.%U",ip->v[0],ip->v[1],ip->v[2],ip->v[3]); 
*
030BE:  MOVLB  3
030C0:  MOVFF  361,FE9
030C4:  MOVFF  362,FEA
030C8:  MOVFF  FEF,363
030CC:  MOVLW  01
030CE:  ADDWF  x61,W
030D0:  MOVWF  FE9
030D2:  MOVLW  00
030D4:  ADDWFC x62,W
030D6:  MOVWF  FEA
030D8:  MOVFF  FEF,364
030DC:  MOVLW  02
030DE:  ADDWF  x61,W
030E0:  MOVWF  FE9
030E2:  MOVLW  00
030E4:  ADDWFC x62,W
030E6:  MOVWF  FEA
030E8:  MOVFF  FEF,365
030EC:  MOVLW  03
030EE:  ADDWF  x61,W
030F0:  MOVWF  FE9
030F2:  MOVLW  00
030F4:  ADDWFC x62,W
030F6:  MOVWF  FEA
030F8:  MOVFF  FEF,366
030FC:  MOVFF  363,36B
03100:  MOVLW  1B
03102:  MOVWF  x6C
03104:  MOVLB  0
03106:  RCALL  3040
03108:  MOVLW  2E
0310A:  CALL   0EB4
0310E:  MOVFF  364,36B
03112:  MOVLW  1B
03114:  MOVLB  3
03116:  MOVWF  x6C
03118:  MOVLB  0
0311A:  RCALL  3040
0311C:  MOVLW  2E
0311E:  CALL   0EB4
03122:  MOVFF  365,36B
03126:  MOVLW  1B
03128:  MOVLB  3
0312A:  MOVWF  x6C
0312C:  MOVLB  0
0312E:  RCALL  3040
03130:  MOVLW  2E
03132:  CALL   0EB4
03136:  MOVFF  366,36B
0313A:  MOVLW  1B
0313C:  MOVLB  3
0313E:  MOVWF  x6C
03140:  MOVLB  0
03142:  RCALL  3040
.................... } 
03144:  RETLW  00
....................  
.................... void ui_settings(void) { 
.................... #if STACK_USE_MAC 
....................    int1 disp=TRUE; 
*
031F2:  MOVLB  3
031F4:  BSF    x60.0
.................... #endif 
.................... #if STACK_USE_TELNET 
....................    int8 i; 
.................... #endif 
.................... #ifdef CCS_UDP_EXAMPLE 
....................    IP_ADDR scratchIP; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    if (ppp_is_connected()) 
....................    { 
....................       fprintf(USER,"\r\n\nIP Address: "); ui_disp_ip_user(&AppConfig.MyIPAddr); 
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
....................      #endif 
....................       fprintf(USER,"\r\nBaud Rate: %LU",connected_baudrate); 
....................    } 
....................    else { 
....................       fprintf(USER,"\r\n\nNot connected to ISP"); 
....................    } 
....................    fprintf(USER,"\r\nISP Username: %s",ppp_username); 
....................    fprintf(USER,"\r\nISP Password: %s",ppp_password); 
....................    fprintf(USER,"\r\nISP Phonenumber: %s", ppp_phonenumber); 
.................... #elif STACK_USE_MAC 
....................    fprintf(USER,"\r\n\nMAC Address: %X:%X:%X:%X:%X:%X",AppConfig.MyMACAddr.v[0],AppConfig.MyMACAddr.v[1],AppConfig.MyMACAddr.v[2],AppConfig.MyMACAddr.v[3],AppConfig.MyMACAddr.v[4],AppConfig.MyMACAddr.v[5]); 
031F6:  CLRF   x61
031F8:  MOVF   x61,W
031FA:  MOVLB  0
031FC:  CALL   030C
03200:  MOVLB  3
03202:  INCF   x61,F
03204:  MOVLB  0
03206:  CALL   0EB4
0320A:  MOVLW  10
0320C:  MOVLB  3
0320E:  SUBWF  x61,W
03210:  BNZ   31F8
03212:  MOVFF  1C,362
03216:  MOVLW  37
03218:  MOVWF  x63
0321A:  MOVLB  0
0321C:  RCALL  2FCE
0321E:  MOVLW  3A
03220:  CALL   0EB4
03224:  MOVFF  1D,362
03228:  MOVLW  37
0322A:  MOVLB  3
0322C:  MOVWF  x63
0322E:  MOVLB  0
03230:  RCALL  2FCE
03232:  MOVLW  3A
03234:  CALL   0EB4
03238:  MOVFF  1E,362
0323C:  MOVLW  37
0323E:  MOVLB  3
03240:  MOVWF  x63
03242:  MOVLB  0
03244:  RCALL  2FCE
03246:  MOVLW  3A
03248:  CALL   0EB4
0324C:  MOVFF  1F,362
03250:  MOVLW  37
03252:  MOVLB  3
03254:  MOVWF  x63
03256:  MOVLB  0
03258:  RCALL  2FCE
0325A:  MOVLW  3A
0325C:  CALL   0EB4
03260:  MOVFF  20,362
03264:  MOVLW  37
03266:  MOVLB  3
03268:  MOVWF  x63
0326A:  MOVLB  0
0326C:  RCALL  2FCE
0326E:  MOVLW  3A
03270:  CALL   0EB4
03274:  MOVFF  21,362
03278:  MOVLW  37
0327A:  MOVLB  3
0327C:  MOVWF  x63
0327E:  MOVLB  0
03280:  RCALL  2FCE
....................   #if STACK_USE_DHCP 
....................    fprintf(USER,"\r\nDHCP Enabled: "); 
03282:  MOVLB  3
03284:  CLRF   x61
03286:  MOVF   x61,W
03288:  MOVLB  0
0328A:  CALL   0348
0328E:  MOVLB  3
03290:  INCF   x61,F
03292:  MOVLB  0
03294:  CALL   0EB4
03298:  MOVLW  10
0329A:  MOVLB  3
0329C:  SUBWF  x61,W
0329E:  BNZ   3286
....................    if (read_ext_eeprom(EE_NIC_DHCP)) { 
032A0:  CLRF   xAB
032A2:  MOVLW  C0
032A4:  MOVWF  xAA
032A6:  MOVLB  0
032A8:  CALL   0E7E
032AC:  MOVF   01,F
032AE:  BZ    3334
....................       fprintf(USER,"TRUE"); 
032B0:  MOVLB  3
032B2:  CLRF   x61
032B4:  MOVF   x61,W
032B6:  MOVLB  0
032B8:  CALL   0374
032BC:  MOVLB  3
032BE:  INCF   x61,F
032C0:  MOVLB  0
032C2:  CALL   0EB4
032C6:  MOVLW  04
032C8:  MOVLB  3
032CA:  SUBWF  x61,W
032CC:  BNZ   32B4
....................       fprintf(USER,"\r\nDHCP Bound: "); 
032CE:  CLRF   x61
032D0:  MOVF   x61,W
032D2:  MOVLB  0
032D4:  CALL   0394
032D8:  MOVLB  3
032DA:  INCF   x61,F
032DC:  MOVLB  0
032DE:  CALL   0EB4
032E2:  MOVLW  0E
032E4:  MOVLB  3
032E6:  SUBWF  x61,W
032E8:  BNZ   32D0
....................       if (DHCPIsBound()) {fprintf(USER,"TRUE");} 
032EA:  MOVLB  0
032EC:  BTFSS  x88.0
032EE:  BRA    3310
032F0:  MOVLB  3
032F2:  CLRF   x61
032F4:  MOVF   x61,W
032F6:  MOVLB  0
032F8:  CALL   0374
032FC:  MOVLB  3
032FE:  INCF   x61,F
03300:  MOVLB  0
03302:  CALL   0EB4
03306:  MOVLW  04
03308:  MOVLB  3
0330A:  SUBWF  x61,W
0330C:  BNZ   32F4
....................       else {fprintf(USER,"FALSE"); disp=FALSE;} 
0330E:  BRA    3330
03310:  MOVLB  3
03312:  CLRF   x61
03314:  MOVF   x61,W
03316:  MOVLB  0
03318:  CALL   03BE
0331C:  MOVLB  3
0331E:  INCF   x61,F
03320:  MOVLB  0
03322:  CALL   0EB4
03326:  MOVLW  05
03328:  MOVLB  3
0332A:  SUBWF  x61,W
0332C:  BNZ   3314
0332E:  BCF    x60.0
....................    } 
....................    else { 
03330:  BRA    3352
03332:  MOVLB  0
....................       fprintf(USER,"FALSE"); 
03334:  MOVLB  3
03336:  CLRF   x61
03338:  MOVF   x61,W
0333A:  MOVLB  0
0333C:  CALL   03BE
03340:  MOVLB  3
03342:  INCF   x61,F
03344:  MOVLB  0
03346:  CALL   0EB4
0334A:  MOVLW  05
0334C:  MOVLB  3
0334E:  SUBWF  x61,W
03350:  BNZ   3338
....................    } 
....................   #else 
....................    disp=TRUE; 
....................   #endif 
....................    if (disp) { 
03352:  BTFSS  x60.0
03354:  BRA    33F6
....................       fprintf(USER,"\r\nIP Address: ");  ui_disp_ip_user(&AppConfig.MyIPAddr); 
03356:  CLRF   x61
03358:  MOVF   x61,W
0335A:  MOVLB  0
0335C:  CALL   03DE
03360:  MOVLB  3
03362:  INCF   x61,F
03364:  MOVLB  0
03366:  CALL   0EB4
0336A:  MOVLW  0E
0336C:  MOVLB  3
0336E:  SUBWF  x61,W
03370:  BNZ   3358
03372:  CLRF   x62
03374:  MOVLW  18
03376:  MOVWF  x61
03378:  MOVLB  0
0337A:  RCALL  30BE
....................       fprintf(USER,"\r\nGateway: ");  ui_disp_ip_user(&AppConfig.MyGateway); 
0337C:  MOVLB  3
0337E:  CLRF   x61
03380:  MOVF   x61,W
03382:  MOVLB  0
03384:  CALL   0408
03388:  MOVLB  3
0338A:  INCF   x61,F
0338C:  MOVLB  0
0338E:  CALL   0EB4
03392:  MOVLW  0B
03394:  MOVLB  3
03396:  SUBWF  x61,W
03398:  BNZ   3380
0339A:  CLRF   x62
0339C:  MOVLW  26
0339E:  MOVWF  x61
033A0:  MOVLB  0
033A2:  RCALL  30BE
....................       fprintf(USER,"\r\nNetmask: "); ui_disp_ip_user(&AppConfig.MyMask); 
033A4:  MOVLB  3
033A6:  CLRF   x61
033A8:  MOVF   x61,W
033AA:  MOVLB  0
033AC:  CALL   042E
033B0:  MOVLB  3
033B2:  INCF   x61,F
033B4:  MOVLB  0
033B6:  CALL   0EB4
033BA:  MOVLW  0B
033BC:  MOVLB  3
033BE:  SUBWF  x61,W
033C0:  BNZ   33A8
033C2:  CLRF   x62
033C4:  MOVLW  22
033C6:  MOVWF  x61
033C8:  MOVLB  0
033CA:  RCALL  30BE
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
033CC:  MOVLB  3
033CE:  CLRF   x61
033D0:  MOVF   x61,W
033D2:  MOVLB  0
033D4:  CALL   0454
033D8:  MOVLB  3
033DA:  INCF   x61,F
033DC:  MOVLB  0
033DE:  CALL   0EB4
033E2:  MOVLW  07
033E4:  MOVLB  3
033E6:  SUBWF  x61,W
033E8:  BNZ   33D0
033EA:  CLRF   x62
033EC:  MOVLW  2A
033EE:  MOVWF  x61
033F0:  MOVLB  0
033F2:  RCALL  30BE
033F4:  MOVLB  3
....................      #endif 
....................    } 
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................   fprintf(USER,"\r\nSMTP Server Hostname: %s", SMTP_HOST_NAME); 
033F6:  CLRF   x61
033F8:  MOVF   x61,W
033FA:  MOVLB  0
033FC:  CALL   0476
03400:  MOVLB  3
03402:  INCF   x61,F
03404:  MOVLB  0
03406:  CALL   0EB4
0340A:  MOVLW  18
0340C:  MOVLB  3
0340E:  SUBWF  x61,W
03410:  BNZ   33F8
03412:  MOVLW  02
03414:  MOVWF  FEA
03416:  MOVLW  13
03418:  MOVWF  FE9
0341A:  MOVLW  00
0341C:  IORWF  FEF,W
0341E:  BZ    3430
03420:  MOVF   FEF,W
03422:  BTFSS  F9E.4
03424:  BRA    3422
03426:  MOVWF  FAD
03428:  INCF   FE9,F
0342A:  BTFSC  FD8.2
0342C:  INCF   FEA,F
0342E:  BRA    341A
....................   fprintf(USER,"\r\nSMTP Server Port: %LU",SMTP_PORT); 
03430:  CLRF   x61
03432:  MOVF   x61,W
03434:  MOVLB  0
03436:  CALL   04AC
0343A:  MOVLB  3
0343C:  INCF   x61,F
0343E:  MOVLB  0
03440:  CALL   0EB4
03444:  MOVLW  14
03446:  MOVLB  3
03448:  SUBWF  x61,W
0344A:  BNZ   3432
0344C:  MOVLW  10
0344E:  MOVWF  FE9
03450:  MOVFF  212,362
03454:  MOVFF  211,361
03458:  MOVLB  0
0345A:  BRA    3146
....................   fprintf(USER,"\r\nE-Mail To: %s", SMTP_TO_ADDR); 
0345C:  MOVLB  3
0345E:  CLRF   x61
03460:  MOVF   x61,W
03462:  MOVLB  0
03464:  CALL   04DE
03468:  MOVLB  3
0346A:  INCF   x61,F
0346C:  MOVLB  0
0346E:  CALL   0EB4
03472:  MOVLW  0D
03474:  MOVLB  3
03476:  SUBWF  x61,W
03478:  BNZ   3460
0347A:  MOVLW  02
0347C:  MOVWF  FEA
0347E:  MOVLW  53
03480:  MOVWF  FE9
03482:  MOVLW  00
03484:  IORWF  FEF,W
03486:  BZ    3498
03488:  MOVF   FEF,W
0348A:  BTFSS  F9E.4
0348C:  BRA    348A
0348E:  MOVWF  FAD
03490:  INCF   FE9,F
03492:  BTFSC  FD8.2
03494:  INCF   FEA,F
03496:  BRA    3482
....................   fprintf(USER,"\r\nE-Mail From: %s", SMTP_FROM_ADDR); 
03498:  CLRF   x61
0349A:  MOVF   x61,W
0349C:  MOVLB  0
0349E:  CALL   0508
034A2:  MOVLB  3
034A4:  INCF   x61,F
034A6:  MOVLB  0
034A8:  CALL   0EB4
034AC:  MOVLW  0F
034AE:  MOVLB  3
034B0:  SUBWF  x61,W
034B2:  BNZ   349A
034B4:  MOVLW  02
034B6:  MOVWF  FEA
034B8:  MOVLW  93
034BA:  MOVWF  FE9
034BC:  MOVLW  00
034BE:  IORWF  FEF,W
034C0:  BZ    34D2
034C2:  MOVF   FEF,W
034C4:  BTFSS  F9E.4
034C6:  BRA    34C4
034C8:  MOVWF  FAD
034CA:  INCF   FE9,F
034CC:  BTFSC  FD8.2
034CE:  INCF   FEA,F
034D0:  BRA    34BC
....................   fprintf(USER,"\r\nE-Mail Subject: %s", SMTP_SUBJECT); 
034D2:  CLRF   x61
034D4:  MOVF   x61,W
034D6:  MOVLB  0
034D8:  CALL   0534
034DC:  MOVLB  3
034DE:  INCF   x61,F
034E0:  MOVLB  0
034E2:  CALL   0EB4
034E6:  MOVLW  12
034E8:  MOVLB  3
034EA:  SUBWF  x61,W
034EC:  BNZ   34D4
034EE:  MOVLW  02
034F0:  MOVWF  FEA
034F2:  MOVLW  D3
034F4:  MOVWF  FE9
034F6:  MOVLW  00
034F8:  IORWF  FEF,W
034FA:  BZ    350C
034FC:  MOVF   FEF,W
034FE:  BTFSS  F9E.4
03500:  BRA    34FE
03502:  MOVWF  FAD
03504:  INCF   FE9,F
03506:  BTFSC  FD8.2
03508:  INCF   FEA,F
0350A:  BRA    34F6
....................   fprintf(USER,"\r\nE-Mail Body: %s", SMTP_BODY); 
0350C:  CLRF   x61
0350E:  MOVF   x61,W
03510:  MOVLB  0
03512:  CALL   0564
03516:  MOVLB  3
03518:  INCF   x61,F
0351A:  MOVLB  0
0351C:  CALL   0EB4
03520:  MOVLW  0F
03522:  MOVLB  3
03524:  SUBWF  x61,W
03526:  BNZ   350E
03528:  MOVLW  03
0352A:  MOVWF  FEA
0352C:  MOVLW  13
0352E:  MOVWF  FE9
03530:  MOVLW  00
03532:  IORWF  FEF,W
03534:  BZ    3546
03536:  MOVF   FEF,W
03538:  BTFSS  F9E.4
0353A:  BRA    3538
0353C:  MOVWF  FAD
0353E:  INCF   FE9,F
03540:  BTFSC  FD8.2
03542:  INCF   FEA,F
03544:  BRA    3530
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
....................    read_ext_eeprom_ip(EE_UDP_DEST_IP, &scratchIP); 
....................    fprintf(USER,"\r\nUDP Destination IP: ");  ui_disp_ip_user(&scratchIP); 
....................    fprintf(USER,"\r\nUDP Destination Port: %LU", read_ext_eeprom16(EE_UDP_DEST_PORT)); 
....................    fprintf(USER,"\r\nUDP Source Port: %LU", read_ext_eeprom16(EE_UDP_SRC_PORT)); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    for (i=0;i<TELNET_MAX_CONNECTIONS;i++) { 
....................       fprintf(USER,"\r\nTelnet %U: ",i); 
....................       if (TelnetIsOpen(i)) { 
....................          fprintf(USER,"OPEN ST=%X S=%U IP=",TCB[telnet_active_socket[i]].smState,telnet_active_socket[i]); 
....................          ui_disp_ip_user(&TCB[telnet_active_socket[i]].remote.IPAddr); 
....................          fprintf(USER," RP=%LU",TCB[telnet_active_socket[i]].remotePort); 
....................       } 
....................       else { 
....................          fprintf(USER,"LISTENING ST=%X",TCB[telnet_active_socket[i]].smState); 
....................       } 
....................    } 
.................... #endif 
.................... } 
03546:  MOVLB  0
03548:  RETLW  00
....................  
.................... void fget_string(char* s, int max) { 
....................    int len=0; 
*
03600:  MOVLB  3
03602:  CLRF   xB1
....................    char c; 
....................  
....................    --max; 
03604:  DECF   xB0,F
....................  
....................    while ((c=*s)!=0) 
....................    { 
03606:  MOVFF  3AF,03
0360A:  MOVFF  3AE,FE9
0360E:  MOVFF  3AF,FEA
03612:  MOVFF  FEF,3B2
03616:  MOVF   xB2,F
03618:  BZ    362E
....................       fputc(c, USER); 
0361A:  MOVF   xB2,W
0361C:  MOVLB  0
0361E:  CALL   0EB4
....................       len++; 
03622:  MOVLB  3
03624:  INCF   xB1,F
....................       s++; 
03626:  INCF   xAE,F
03628:  BTFSC  FD8.2
0362A:  INCF   xAF,F
....................    } 
0362C:  BRA    3606
....................  
....................    do { 
....................      c=fgetc(USER); 
0362E:  BTFSS  F9E.5
03630:  BRA    362E
03632:  MOVFF  FAE,3B2
....................      if(c==8) {  // Backspace 
03636:  MOVF   xB2,W
03638:  SUBLW  08
0363A:  BNZ   3666
....................         if(len>0) { 
0363C:  MOVF   xB1,F
0363E:  BZ    3664
....................           len--; 
03640:  DECF   xB1,F
....................           s--; 
03642:  MOVF   xAE,W
03644:  BTFSC  FD8.2
03646:  DECF   xAF,F
03648:  DECF   xAE,F
....................           fputc(c,USER); 
0364A:  MOVF   xB2,W
0364C:  MOVLB  0
0364E:  CALL   0EB4
....................           fputc(' ',USER); 
03652:  MOVLW  20
03654:  CALL   0EB4
....................           fputc(c,USER); 
03658:  MOVLB  3
0365A:  MOVF   xB2,W
0365C:  MOVLB  0
0365E:  CALL   0EB4
03662:  MOVLB  3
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
03664:  BRA    369A
03666:  MOVF   xB2,W
03668:  SUBLW  1F
0366A:  BC    369A
0366C:  MOVF   xB2,W
0366E:  SUBLW  7E
03670:  BNC   369A
....................        if(len<max) { 
03672:  MOVF   xB0,W
03674:  SUBWF  xB1,W
03676:  BC    369A
....................          *s++ = c; 
03678:  MOVFF  3AF,03
0367C:  MOVF   xAE,W
0367E:  INCF   xAE,F
03680:  BTFSC  FD8.2
03682:  INCF   xAF,F
03684:  MOVWF  FE9
03686:  MOVFF  03,FEA
0368A:  MOVFF  3B2,FEF
....................          len++; 
0368E:  INCF   xB1,F
....................          fputc(c,USER); 
03690:  MOVF   xB2,W
03692:  MOVLB  0
03694:  CALL   0EB4
03698:  MOVLB  3
....................        } 
....................    } while(c!=13); 
0369A:  MOVF   xB2,W
0369C:  SUBLW  0D
0369E:  BNZ   362E
....................    *s = 0; 
036A0:  MOVFF  3AE,FE9
036A4:  MOVFF  3AF,FEA
036A8:  CLRF   FEF
.................... } 
036AA:  MOVLB  0
036AC:  RETLW  00
....................  
.................... int fget_int(int8 initial) { 
....................   char s[4]; 
....................   signed int i; 
....................  
....................   sprintf(s, "%U", initial); 
*
03FAE:  MOVLW  03
03FB0:  MOVLB  3
03FB2:  MOVWF  x54
03FB4:  MOVLW  6F
03FB6:  MOVWF  x53
03FB8:  MOVFF  36E,374
03FBC:  MOVLW  1B
03FBE:  MOVWF  x75
03FC0:  MOVLB  0
03FC2:  BRA    3F26
....................  
....................   fget_string(s, 4); 
03FC4:  MOVLW  03
03FC6:  MOVLB  3
03FC8:  MOVWF  xAF
03FCA:  MOVLW  6F
03FCC:  MOVWF  xAE
03FCE:  MOVLW  04
03FD0:  MOVWF  xB0
03FD2:  MOVLB  0
03FD4:  CALL   3600
....................  
....................   i=atol(s); 
03FD8:  MOVLW  03
03FDA:  MOVLB  3
03FDC:  MOVWF  xAF
03FDE:  MOVLW  6F
03FE0:  MOVWF  xAE
03FE2:  MOVLB  0
03FE4:  RCALL  3808
03FE6:  MOVFF  01,373
....................   return(i); 
03FEA:  MOVLB  3
03FEC:  MOVFF  373,01
.................... } 
03FF0:  MOVLB  0
03FF2:  GOTO   4126 (RETURN)
....................  
.................... int16 fget_long(int16 initial) { 
....................    char s[6]; 
....................    int16 i; 
....................  
....................    sprintf(s, "%LU", initial); 
*
039F8:  MOVLW  03
039FA:  MOVLB  3
039FC:  MOVWF  x54
039FE:  MOVLW  A6
03A00:  MOVWF  x53
03A02:  MOVLW  10
03A04:  MOVWF  FE9
03A06:  MOVFF  3A5,3AF
03A0A:  MOVFF  3A4,3AE
03A0E:  MOVLB  0
03A10:  BRA    3728
....................  
....................    fget_string(s, 6); 
03A12:  MOVLW  03
03A14:  MOVLB  3
03A16:  MOVWF  xAF
03A18:  MOVLW  A6
03A1A:  MOVWF  xAE
03A1C:  MOVLW  06
03A1E:  MOVWF  xB0
03A20:  MOVLB  0
03A22:  RCALL  3600
....................  
....................    i=atol(s); 
03A24:  MOVLW  03
03A26:  MOVLB  3
03A28:  MOVWF  xAF
03A2A:  MOVLW  A6
03A2C:  MOVWF  xAE
03A2E:  MOVLB  0
03A30:  RCALL  3808
03A32:  MOVFF  02,3AD
03A36:  MOVFF  01,3AC
....................    return(i); 
03A3A:  MOVLB  3
03A3C:  MOVFF  3AC,01
03A40:  MOVFF  3AD,02
.................... } 
03A44:  MOVLB  0
03A46:  GOTO   3AE2 (RETURN)
....................  
.................... BYTE fgethex(int initial) { 
....................    char hex[5]; 
....................    int8 ret; 
....................  
....................    hex[0]='0'; 
*
03ED6:  MOVLW  30
03ED8:  MOVLB  3
03EDA:  MOVWF  x66
....................    hex[1]='x'; 
03EDC:  MOVLW  78
03EDE:  MOVWF  x67
....................  
....................    sprintf(&hex[2], "%X", initial); 
03EE0:  MOVLW  03
03EE2:  MOVWF  x54
03EE4:  MOVLW  68
03EE6:  MOVWF  x53
03EE8:  MOVFF  365,36C
03EEC:  MOVLW  37
03EEE:  MOVWF  x6D
03EF0:  MOVLB  0
03EF2:  BRA    3E8E
....................  
....................    fget_string(&hex[2],3); 
03EF4:  MOVLW  03
03EF6:  MOVLB  3
03EF8:  MOVWF  xAF
03EFA:  MOVLW  68
03EFC:  MOVWF  xAE
03EFE:  MOVLW  03
03F00:  MOVWF  xB0
03F02:  MOVLB  0
03F04:  CALL   3600
....................    ret=atol(hex); 
03F08:  MOVLW  03
03F0A:  MOVLB  3
03F0C:  MOVWF  xAF
03F0E:  MOVLW  66
03F10:  MOVWF  xAE
03F12:  MOVLB  0
03F14:  RCALL  3808
03F16:  MOVFF  01,36B
....................    return(ret); 
03F1A:  MOVLB  3
03F1C:  MOVFF  36B,01
.................... } 
03F20:  MOVLB  0
03F22:  GOTO   41D2 (RETURN)
....................  
.................... void ui_ip_to_ee(int16 address) { 
....................    IP_ADDR ip; 
....................    int i; 
....................    read_ext_eeprom_ip(address, &ip); 
*
0409E:  MOVFF  365,36C
040A2:  MOVFF  364,36B
040A6:  MOVLW  03
040A8:  MOVLB  3
040AA:  MOVWF  x6E
040AC:  MOVLW  66
040AE:  MOVWF  x6D
040B0:  MOVLB  0
040B2:  CALL   106A
....................    for (i=0;i<4;i++) { 
040B6:  MOVLB  3
040B8:  CLRF   x6A
040BA:  MOVF   x6A,W
040BC:  SUBLW  03
040BE:  BNC   4144
....................       fprintf(USER, "  BYTE%U: ",i); 
040C0:  CLRF   x6B
040C2:  MOVF   x6B,W
040C4:  MOVLB  0
040C6:  CALL   0590
040CA:  MOVLB  3
040CC:  INCF   x6B,F
040CE:  MOVLB  0
040D0:  CALL   0EB4
040D4:  MOVLW  06
040D6:  MOVLB  3
040D8:  SUBWF  x6B,W
040DA:  BNZ   40C2
040DC:  MOVFF  36A,36B
040E0:  MOVLW  1B
040E2:  MOVWF  x6C
040E4:  MOVLB  0
040E6:  CALL   3040
040EA:  MOVLW  3A
040EC:  CALL   0EB4
040F0:  MOVLW  20
040F2:  CALL   0EB4
....................       ip.v[i]=fget_int(ip.v[i]); 
040F6:  CLRF   03
040F8:  MOVLB  3
040FA:  MOVF   x6A,W
040FC:  ADDLW  66
040FE:  MOVWF  01
04100:  MOVLW  03
04102:  ADDWFC 03,F
04104:  MOVFF  01,36B
04108:  MOVFF  03,36C
0410C:  CLRF   03
0410E:  MOVF   x6A,W
04110:  ADDLW  66
04112:  MOVWF  FE9
04114:  MOVLW  03
04116:  ADDWFC 03,W
04118:  MOVWF  FEA
0411A:  MOVFF  FEF,36D
0411E:  MOVFF  36D,36E
04122:  MOVLB  0
04124:  BRA    3FAE
04126:  MOVFF  36C,FEA
0412A:  MOVFF  36B,FE9
0412E:  MOVFF  01,FEF
....................       fprintf(USER,"\r\n"); 
04132:  MOVLW  0D
04134:  CALL   0EB4
04138:  MOVLW  0A
0413A:  CALL   0EB4
....................    } 
0413E:  MOVLB  3
04140:  INCF   x6A,F
04142:  BRA    40BA
....................    write_ext_eeprom_ip(address, &ip); 
04144:  MOVFF  365,36C
04148:  MOVFF  364,36B
0414C:  MOVLW  03
0414E:  MOVWF  x6E
04150:  MOVLW  66
04152:  MOVWF  x6D
04154:  MOVLB  0
04156:  BRA    3FF6
.................... } 
04158:  RETLW  00
....................  
.................... #if STACK_USE_PPP 
.................... void ui_setup(void) { 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nISP USERNAME: "); 
....................    read_ext_eeprom_string(EE_ISP_USERNAME, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_USERNAME, str); 
....................  
....................    fprintf(USER,"\r\nISP PASSWORD: "); 
....................    read_ext_eeprom_string(EE_ISP_PASSWORD, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PASSWORD,str); 
....................  
....................    fprintf(USER,"\r\nISP PHONENUMBER: "); 
....................    read_ext_eeprom_string(EE_ISP_PHONENUMBER, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PHONENUMBER,str); 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
....................  
....................    reset_cpu(); 
.................... } 
.................... #elif STACK_USE_MAC 
.................... void ui_setup(void) { 
....................    char dhcp; 
....................    int8 i; 
....................    int16 addy; 
....................  
....................    fprintf(USER,"\r\n\nMAC ADDRESS:"); 
0415A:  MOVLB  3
0415C:  CLRF   x64
0415E:  MOVF   x64,W
04160:  MOVLB  0
04162:  CALL   05B6
04166:  MOVLB  3
04168:  INCF   x64,F
0416A:  MOVLB  0
0416C:  CALL   0EB4
04170:  MOVLW  0F
04172:  MOVLB  3
04174:  SUBWF  x64,W
04176:  BNZ   415E
....................    addy=EE_NIC_MAC; 
04178:  CLRF   x63
0417A:  MOVLW  CD
0417C:  MOVWF  x62
....................    for(i=0;i<6;i++) { 
0417E:  CLRF   x61
04180:  MOVF   x61,W
04182:  SUBLW  05
04184:  BNC   4200
....................      fprintf(USER, "\r\n  BYTE%U: ",i); 
04186:  CLRF   x64
04188:  MOVF   x64,W
0418A:  MOVLB  0
0418C:  CALL   05E0
04190:  MOVLB  3
04192:  INCF   x64,F
04194:  MOVLB  0
04196:  CALL   0EB4
0419A:  MOVLW  08
0419C:  MOVLB  3
0419E:  SUBWF  x64,W
041A0:  BNZ   4188
041A2:  MOVFF  361,36B
041A6:  MOVLW  1B
041A8:  MOVWF  x6C
041AA:  MOVLB  0
041AC:  CALL   3040
041B0:  MOVLW  3A
041B2:  CALL   0EB4
041B6:  MOVLW  20
041B8:  CALL   0EB4
....................      dhcp=fgethex(read_ext_eeprom(addy)); 
041BC:  MOVFF  363,3AB
041C0:  MOVFF  362,3AA
041C4:  CALL   0E7E
041C8:  MOVFF  01,364
041CC:  MOVFF  01,365
041D0:  BRA    3ED6
041D2:  MOVFF  01,360
....................      write_ext_eeprom(addy++,dhcp); 
041D6:  MOVLB  3
041D8:  MOVFF  363,03
041DC:  MOVF   x62,W
041DE:  INCF   x62,F
041E0:  BTFSC  FD8.2
041E2:  INCF   x63,F
041E4:  MOVWF  x64
041E6:  MOVFF  03,365
041EA:  MOVFF  03,3AA
041EE:  MOVWF  xA9
041F0:  MOVFF  360,3AB
041F4:  MOVLB  0
041F6:  CALL   0EBC
....................    } 
041FA:  MOVLB  3
041FC:  INCF   x61,F
041FE:  BRA    4180
....................  
....................  
....................    fprintf(USER,"\r\n\nUSE DHCP? (Y/N): "); 
04200:  CLRF   x64
04202:  MOVF   x64,W
04204:  MOVLB  0
04206:  CALL   0608
0420A:  MOVLB  3
0420C:  INCF   x64,F
0420E:  MOVLB  0
04210:  CALL   0EB4
04214:  MOVLW  14
04216:  MOVLB  3
04218:  SUBWF  x64,W
0421A:  BNZ   4202
....................    do { 
....................       dhcp=fgetc(USER); 
0421C:  BTFSS  F9E.5
0421E:  BRA    421C
04220:  MOVFF  FAE,360
....................       dhcp=toupper(dhcp); 
04224:  MOVF   x60,W
04226:  SUBLW  60
04228:  BC    4236
0422A:  MOVF   x60,W
0422C:  SUBLW  7A
0422E:  BNC   4236
04230:  MOVF   x60,W
04232:  ANDLW  DF
04234:  BRA    4238
04236:  MOVF   x60,W
04238:  MOVWF  x60
....................    } while ((dhcp!='Y')&&(dhcp!='N')); 
0423A:  MOVF   x60,W
0423C:  SUBLW  59
0423E:  BZ    4246
04240:  MOVF   x60,W
04242:  SUBLW  4E
04244:  BNZ   421C
....................    fputc(dhcp,USER); 
04246:  MOVF   x60,W
04248:  MOVLB  0
0424A:  CALL   0EB4
....................  
....................    if (dhcp=='N') { 
0424E:  MOVLB  3
04250:  MOVF   x60,W
04252:  SUBLW  4E
04254:  BNZ   4308
....................       write_ext_eeprom(EE_NIC_DHCP,0); 
04256:  CLRF   xAA
04258:  MOVLW  C0
0425A:  MOVWF  xA9
0425C:  CLRF   xAB
0425E:  MOVLB  0
04260:  CALL   0EBC
....................  
....................       fprintf(USER,"\r\n\nIP ADDRESS:\r\n"); 
04264:  MOVLB  3
04266:  CLRF   x64
04268:  MOVF   x64,W
0426A:  MOVLB  0
0426C:  CALL   0638
04270:  MOVLB  3
04272:  INCF   x64,F
04274:  MOVLB  0
04276:  CALL   0EB4
0427A:  MOVLW  10
0427C:  MOVLB  3
0427E:  SUBWF  x64,W
04280:  BNZ   4268
....................       ui_ip_to_ee(EE_NIC_IP); 
04282:  CLRF   x65
04284:  MOVLW  C5
04286:  MOVWF  x64
04288:  MOVLB  0
0428A:  RCALL  409E
....................  
....................       fprintf(USER,"\r\nGATEWAY:\r\n"); 
0428C:  MOVLB  3
0428E:  CLRF   x64
04290:  MOVF   x64,W
04292:  MOVLB  0
04294:  CALL   0664
04298:  MOVLB  3
0429A:  INCF   x64,F
0429C:  MOVLB  0
0429E:  CALL   0EB4
042A2:  MOVLW  0C
042A4:  MOVLB  3
042A6:  SUBWF  x64,W
042A8:  BNZ   4290
....................       ui_ip_to_ee(EE_NIC_GATEWAY); 
042AA:  CLRF   x65
042AC:  MOVLW  C1
042AE:  MOVWF  x64
042B0:  MOVLB  0
042B2:  RCALL  409E
....................  
....................       fprintf(USER,"\r\nNETMASK:\r\n"); 
042B4:  MOVLB  3
042B6:  CLRF   x64
042B8:  MOVF   x64,W
042BA:  MOVLB  0
042BC:  CALL   068C
042C0:  MOVLB  3
042C2:  INCF   x64,F
042C4:  MOVLB  0
042C6:  CALL   0EB4
042CA:  MOVLW  0C
042CC:  MOVLB  3
042CE:  SUBWF  x64,W
042D0:  BNZ   42B8
....................       ui_ip_to_ee(EE_NIC_NETMASK); 
042D2:  CLRF   x65
042D4:  MOVLW  C9
042D6:  MOVWF  x64
042D8:  MOVLB  0
042DA:  RCALL  409E
....................  
....................      #if STACK_USE_DNS 
....................       fprintf(USER, "\r\nDNS:\r\n"); 
042DC:  MOVLB  3
042DE:  CLRF   x64
042E0:  MOVF   x64,W
042E2:  MOVLB  0
042E4:  CALL   06B4
042E8:  MOVLB  3
042EA:  INCF   x64,F
042EC:  MOVLB  0
042EE:  CALL   0EB4
042F2:  MOVLW  08
042F4:  MOVLB  3
042F6:  SUBWF  x64,W
042F8:  BNZ   42E0
....................       ui_ip_to_ee(EE_DNS); 
042FA:  CLRF   x65
042FC:  MOVLW  D3
042FE:  MOVWF  x64
04300:  MOVLB  0
04302:  RCALL  409E
....................      #endif 
....................    } 
....................    else { 
04304:  BRA    4318
04306:  MOVLB  3
....................       write_ext_eeprom(EE_NIC_DHCP,1); 
04308:  CLRF   xAA
0430A:  MOVLW  C0
0430C:  MOVWF  xA9
0430E:  MOVLW  01
04310:  MOVWF  xAB
04312:  MOVLB  0
04314:  CALL   0EBC
....................    } 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
04318:  MOVLB  3
0431A:  CLRF   x64
0431C:  MOVF   x64,W
0431E:  MOVLB  0
04320:  CALL   06D8
04324:  MOVLB  3
04326:  INCF   x64,F
04328:  MOVLB  0
0432A:  CALL   0EB4
0432E:  MOVLW  21
04330:  MOVLB  3
04332:  SUBWF  x64,W
04334:  BNZ   431C
....................  
....................    reset_cpu(); 
04336:  RESET
.................... } 
04338:  MOVLB  0
0433A:  GOTO   43DA (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... void ui_mail_settings(void) { 
....................    int16 port; 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nSMTP HOST NAME: "); 
*
03A4A:  MOVLB  3
03A4C:  CLRF   xA2
03A4E:  MOVF   xA2,W
03A50:  MOVLB  0
03A52:  CALL   0714
03A56:  MOVLB  3
03A58:  INCF   xA2,F
03A5A:  MOVLB  0
03A5C:  CALL   0EB4
03A60:  MOVLW  13
03A62:  MOVLB  3
03A64:  SUBWF  xA2,W
03A66:  BNZ   3A4E
....................    read_ext_eeprom_string(EE_SMTP_HOSTNAME, str, sizeof(str)-1); 
03A68:  CLRF   xA3
03A6A:  MOVLW  D9
03A6C:  MOVWF  xA2
03A6E:  MOVLW  03
03A70:  MOVWF  xA5
03A72:  MOVLW  62
03A74:  MOVWF  xA4
03A76:  MOVLW  3F
03A78:  MOVWF  xA6
03A7A:  MOVLB  0
03A7C:  CALL   2D72
....................    fget_string(str,64); 
03A80:  MOVLW  03
03A82:  MOVLB  3
03A84:  MOVWF  xAF
03A86:  MOVLW  62
03A88:  MOVWF  xAE
03A8A:  MOVLW  40
03A8C:  MOVWF  xB0
03A8E:  MOVLB  0
03A90:  RCALL  3600
....................    write_ext_eeprom_string(EE_SMTP_HOSTNAME, str); 
03A92:  MOVLB  3
03A94:  CLRF   xA3
03A96:  MOVLW  D9
03A98:  MOVWF  xA2
03A9A:  MOVLW  03
03A9C:  MOVWF  xA5
03A9E:  MOVLW  62
03AA0:  MOVWF  xA4
03AA2:  MOVLB  0
03AA4:  RCALL  36AE
....................  
....................    fprintf(USER,"\r\nSMTP PORT (USUALLY 25): "); 
03AA6:  MOVLB  3
03AA8:  CLRF   xA2
03AAA:  MOVF   xA2,W
03AAC:  MOVLB  0
03AAE:  CALL   0742
03AB2:  MOVLB  3
03AB4:  INCF   xA2,F
03AB6:  MOVLB  0
03AB8:  CALL   0EB4
03ABC:  MOVLW  1A
03ABE:  MOVLB  3
03AC0:  SUBWF  xA2,W
03AC2:  BNZ   3AAA
....................    port=fget_long(read_ext_eeprom16(EE_SMTP_PORT)); 
03AC4:  CLRF   xA3
03AC6:  MOVLW  D7
03AC8:  MOVWF  xA2
03ACA:  MOVLB  0
03ACC:  CALL   2DC4
03AD0:  MOVFF  02,3A3
03AD4:  MOVFF  01,3A2
03AD8:  MOVFF  02,3A5
03ADC:  MOVFF  01,3A4
03AE0:  BRA    39F8
03AE2:  MOVFF  02,361
03AE6:  MOVFF  01,360
....................    write_ext_eeprom16(EE_SMTP_PORT, port); 
03AEA:  MOVLB  3
03AEC:  CLRF   xA3
03AEE:  MOVLW  D7
03AF0:  MOVWF  xA2
03AF2:  MOVFF  361,3A5
03AF6:  MOVFF  360,3A4
03AFA:  MOVLB  0
03AFC:  CALL   0EF2
....................    fprintf(USER,"\r\n"); 
03B00:  MOVLW  0D
03B02:  CALL   0EB4
03B06:  MOVLW  0A
03B08:  CALL   0EB4
....................  
....................    fprintf(USER,"\r\nTo: "); 
03B0C:  MOVLB  3
03B0E:  CLRF   xA2
03B10:  MOVF   xA2,W
03B12:  MOVLB  0
03B14:  CALL   0778
03B18:  MOVLB  3
03B1A:  INCF   xA2,F
03B1C:  MOVLB  0
03B1E:  CALL   0EB4
03B22:  MOVLW  06
03B24:  MOVLB  3
03B26:  SUBWF  xA2,W
03B28:  BNZ   3B10
....................    read_ext_eeprom_string(EE_SMTP_TO, str, sizeof(str)-1); 
03B2A:  MOVLW  01
03B2C:  MOVWF  xA3
03B2E:  MOVLW  19
03B30:  MOVWF  xA2
03B32:  MOVLW  03
03B34:  MOVWF  xA5
03B36:  MOVLW  62
03B38:  MOVWF  xA4
03B3A:  MOVLW  3F
03B3C:  MOVWF  xA6
03B3E:  MOVLB  0
03B40:  CALL   2D72
....................    fget_string(str,64); 
03B44:  MOVLW  03
03B46:  MOVLB  3
03B48:  MOVWF  xAF
03B4A:  MOVLW  62
03B4C:  MOVWF  xAE
03B4E:  MOVLW  40
03B50:  MOVWF  xB0
03B52:  MOVLB  0
03B54:  RCALL  3600
....................    write_ext_eeprom_string(EE_SMTP_TO,str); 
03B56:  MOVLW  01
03B58:  MOVLB  3
03B5A:  MOVWF  xA3
03B5C:  MOVLW  19
03B5E:  MOVWF  xA2
03B60:  MOVLW  03
03B62:  MOVWF  xA5
03B64:  MOVLW  62
03B66:  MOVWF  xA4
03B68:  MOVLB  0
03B6A:  RCALL  36AE
....................  
....................    fprintf(USER,"\r\nFrom: "); 
03B6C:  MOVLB  3
03B6E:  CLRF   xA2
03B70:  MOVF   xA2,W
03B72:  MOVLB  0
03B74:  CALL   079A
03B78:  MOVLB  3
03B7A:  INCF   xA2,F
03B7C:  MOVLB  0
03B7E:  CALL   0EB4
03B82:  MOVLW  08
03B84:  MOVLB  3
03B86:  SUBWF  xA2,W
03B88:  BNZ   3B70
....................    read_ext_eeprom_string(EE_SMTP_FROM, str, sizeof(str)-1); 
03B8A:  MOVLW  01
03B8C:  MOVWF  xA3
03B8E:  MOVLW  59
03B90:  MOVWF  xA2
03B92:  MOVLW  03
03B94:  MOVWF  xA5
03B96:  MOVLW  62
03B98:  MOVWF  xA4
03B9A:  MOVLW  3F
03B9C:  MOVWF  xA6
03B9E:  MOVLB  0
03BA0:  CALL   2D72
....................    fget_string(str,64); 
03BA4:  MOVLW  03
03BA6:  MOVLB  3
03BA8:  MOVWF  xAF
03BAA:  MOVLW  62
03BAC:  MOVWF  xAE
03BAE:  MOVLW  40
03BB0:  MOVWF  xB0
03BB2:  MOVLB  0
03BB4:  RCALL  3600
....................    write_ext_eeprom_string(EE_SMTP_FROM,str); 
03BB6:  MOVLW  01
03BB8:  MOVLB  3
03BBA:  MOVWF  xA3
03BBC:  MOVLW  59
03BBE:  MOVWF  xA2
03BC0:  MOVLW  03
03BC2:  MOVWF  xA5
03BC4:  MOVLW  62
03BC6:  MOVWF  xA4
03BC8:  MOVLB  0
03BCA:  RCALL  36AE
....................  
....................    fprintf(USER,"\r\nSubject: "); 
03BCC:  MOVLB  3
03BCE:  CLRF   xA2
03BD0:  MOVF   xA2,W
03BD2:  MOVLB  0
03BD4:  CALL   07BE
03BD8:  MOVLB  3
03BDA:  INCF   xA2,F
03BDC:  MOVLB  0
03BDE:  CALL   0EB4
03BE2:  MOVLW  0B
03BE4:  MOVLB  3
03BE6:  SUBWF  xA2,W
03BE8:  BNZ   3BD0
....................    read_ext_eeprom_string(EE_SMTP_SUBJECT, str, sizeof(str)-1); 
03BEA:  MOVLW  01
03BEC:  MOVWF  xA3
03BEE:  MOVLW  99
03BF0:  MOVWF  xA2
03BF2:  MOVLW  03
03BF4:  MOVWF  xA5
03BF6:  MOVLW  62
03BF8:  MOVWF  xA4
03BFA:  MOVLW  3F
03BFC:  MOVWF  xA6
03BFE:  MOVLB  0
03C00:  CALL   2D72
....................    fget_string(str,64); 
03C04:  MOVLW  03
03C06:  MOVLB  3
03C08:  MOVWF  xAF
03C0A:  MOVLW  62
03C0C:  MOVWF  xAE
03C0E:  MOVLW  40
03C10:  MOVWF  xB0
03C12:  MOVLB  0
03C14:  RCALL  3600
....................    write_ext_eeprom_string(EE_SMTP_SUBJECT,str); 
03C16:  MOVLW  01
03C18:  MOVLB  3
03C1A:  MOVWF  xA3
03C1C:  MOVLW  99
03C1E:  MOVWF  xA2
03C20:  MOVLW  03
03C22:  MOVWF  xA5
03C24:  MOVLW  62
03C26:  MOVWF  xA4
03C28:  MOVLB  0
03C2A:  RCALL  36AE
....................  
....................    fprintf(USER,"\r\nBody: "); 
03C2C:  MOVLB  3
03C2E:  CLRF   xA2
03C30:  MOVF   xA2,W
03C32:  MOVLB  0
03C34:  CALL   07E4
03C38:  MOVLB  3
03C3A:  INCF   xA2,F
03C3C:  MOVLB  0
03C3E:  CALL   0EB4
03C42:  MOVLW  08
03C44:  MOVLB  3
03C46:  SUBWF  xA2,W
03C48:  BNZ   3C30
....................    read_ext_eeprom_string(EE_SMTP_BODY, str, sizeof(str)-1); 
03C4A:  MOVLW  01
03C4C:  MOVWF  xA3
03C4E:  MOVLW  D9
03C50:  MOVWF  xA2
03C52:  MOVLW  03
03C54:  MOVWF  xA5
03C56:  MOVLW  62
03C58:  MOVWF  xA4
03C5A:  MOVLW  3F
03C5C:  MOVWF  xA6
03C5E:  MOVLB  0
03C60:  CALL   2D72
....................    fget_string(str,64); 
03C64:  MOVLW  03
03C66:  MOVLB  3
03C68:  MOVWF  xAF
03C6A:  MOVLW  62
03C6C:  MOVWF  xAE
03C6E:  MOVLW  40
03C70:  MOVWF  xB0
03C72:  MOVLB  0
03C74:  RCALL  3600
....................    write_ext_eeprom_string(EE_SMTP_BODY,str); 
03C76:  MOVLW  01
03C78:  MOVLB  3
03C7A:  MOVWF  xA3
03C7C:  MOVLW  D9
03C7E:  MOVWF  xA2
03C80:  MOVLW  03
03C82:  MOVWF  xA5
03C84:  MOVLW  62
03C86:  MOVWF  xA4
03C88:  MOVLB  0
03C8A:  RCALL  36AE
....................  
....................    init_smtp_settings(); 
03C8C:  CALL   2E06
.................... } 
03C90:  GOTO   43DA (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
.................... void ui_udp_settings(void) 
.................... { 
....................    int16 port; 
....................  
....................    fprintf(USER,"\r\n\nUDP Destination IP:\r\n"); 
....................    ui_ip_to_ee(EE_UDP_DEST_IP); 
....................  
....................    fprintf(USER,"\r\nUDP Destination Port (I will transmit to this port): "); 
....................    port=fget_long(read_ext_eeprom16(EE_UDP_DEST_PORT)); 
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\nUDP Source Port (I will listen to this port): "); 
....................    port=fget_long(read_ext_eeprom16(EE_UDP_SRC_PORT)); 
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
....................  
....................    reset_cpu(); 
.................... } 
.................... #endif 
....................  
.................... void ui_menu(void) { 
....................    fprintf(USER,"\r\n\nD) Display Settings"); 
*
0354A:  MOVLB  3
0354C:  CLRF   x60
0354E:  MOVF   x60,W
03550:  MOVLB  0
03552:  CALL   0808
03556:  MOVLB  3
03558:  INCF   x60,F
0355A:  MOVLB  0
0355C:  CALL   0EB4
03560:  MOVLW  16
03562:  MOVLB  3
03564:  SUBWF  x60,W
03566:  BNZ   354E
....................    #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nC) Connect Modem / PPP"); 
....................    fprintf(USER,"\r\nH) Hangup Modem / PPP"); 
....................    #endif 
....................    fprintf(USER,"\r\nS) Configure TCP/IP (Will Reset Board)"); 
03568:  CLRF   x60
0356A:  MOVF   x60,W
0356C:  MOVLB  0
0356E:  CALL   083A
03572:  MOVLB  3
03574:  INCF   x60,F
03576:  MOVLB  0
03578:  CALL   0EB4
0357C:  MOVLW  28
0357E:  MOVLB  3
03580:  SUBWF  x60,W
03582:  BNZ   356A
....................   #if STACK_USE_CCS_PICENS 
....................    fprintf(USER,"\r\nT) Test Hardware (Will Reset Board)"); 
03584:  CLRF   x60
03586:  MOVF   x60,W
03588:  MOVLB  0
0358A:  CALL   087E
0358E:  MOVLB  3
03590:  INCF   x60,F
03592:  MOVLB  0
03594:  CALL   0EB4
03598:  MOVLW  25
0359A:  MOVLB  3
0359C:  SUBWF  x60,W
0359E:  BNZ   3586
....................   #endif 
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................    fprintf(USER,"\r\nM) Configure SMTP"); 
035A0:  CLRF   x60
035A2:  MOVF   x60,W
035A4:  MOVLB  0
035A6:  CALL   08BE
035AA:  MOVLB  3
035AC:  INCF   x60,F
035AE:  MOVLB  0
035B0:  CALL   0EB4
035B4:  MOVLW  13
035B6:  MOVLB  3
035B8:  SUBWF  x60,W
035BA:  BNZ   35A2
....................    fprintf(USER,"\r\nE) Send E-Mail"); 
035BC:  CLRF   x60
035BE:  MOVF   x60,W
035C0:  MOVLB  0
035C2:  CALL   08EC
035C6:  MOVLB  3
035C8:  INCF   x60,F
035CA:  MOVLB  0
035CC:  CALL   0EB4
035D0:  MOVLW  10
035D2:  MOVLB  3
035D4:  SUBWF  x60,W
035D6:  BNZ   35BE
....................    #endif 
....................    #ifdef CCS_UDP_EXAMPLE 
....................    fprintf(USER,"\r\nU) Configure UDP"); 
....................    #endif 
....................    fprintf(USER,"\r\nZ) Clear EEPROM (Caution!)"); 
035D8:  CLRF   x60
035DA:  MOVF   x60,W
035DC:  MOVLB  0
035DE:  CALL   0918
035E2:  MOVLB  3
035E4:  INCF   x60,F
035E6:  MOVLB  0
035E8:  CALL   0EB4
035EC:  MOVLW  1C
035EE:  MOVLB  3
035F0:  SUBWF  x60,W
035F2:  BNZ   35DA
.................... } 
035F4:  MOVLB  0
035F6:  RETLW  00
....................  
.................... void ui_handle(void) 
.................... { 
....................    char c; 
....................    c=fgetc(USER); 
*
0433E:  BTFSS  F9E.5
04340:  BRA    433E
04342:  MOVFF  FAE,35F
04346:  MOVLB  3
....................    c=toupper(c); 
04348:  MOVF   x5F,W
0434A:  SUBLW  60
0434C:  BC    435A
0434E:  MOVF   x5F,W
04350:  SUBLW  7A
04352:  BNC   435A
04354:  MOVF   x5F,W
04356:  ANDLW  DF
04358:  BRA    435C
0435A:  MOVF   x5F,W
0435C:  MOVWF  x5F
....................    switch(c) { 
0435E:  MOVF   x5F,W
04360:  XORLW  4D
04362:  MOVLB  0
04364:  BZ    437C
04366:  XORLW  08
04368:  BZ    4382
0436A:  XORLW  11
0436C:  BZ    43A6
0436E:  XORLW  10
04370:  BZ    43AA
04372:  XORLW  17
04374:  BZ    43B0
04376:  XORLW  09
04378:  BZ    43B4
0437A:  BRA    43DA
....................       #if STACK_USE_PPP 
....................       case 'H':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nHanging up\r\n"); 
....................                      ppp_init(); //ppp_init() will reset the PPP and the MODEM forcing a hangup 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nNot Connected\r\n"); 
....................                   } 
....................                   break; 
....................  
....................       case 'C':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nAlready connected!\r\n"); 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nConnecting\r\n"); 
....................                      picdem_ppp_connect(); 
....................                   } 
....................                   break; 
....................       #endif 
....................  
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................       case 'M':   ui_mail_settings(); 
0437C:  GOTO   3A4A
....................                   break; 
04380:  BRA    43DA
....................  
....................       case 'E':   my_smtp_send(); 
04382:  BRA    3C94
....................                   fprintf(USER, "\r\n\nSending E-Mail.  Watch LCD for status.\r\n\n"); 
04384:  MOVLB  3
04386:  CLRF   x60
04388:  MOVF   x60,W
0438A:  MOVLB  0
0438C:  CALL   0950
04390:  MOVLB  3
04392:  INCF   x60,F
04394:  MOVLB  0
04396:  CALL   0EB4
0439A:  MOVLW  2C
0439C:  MOVLB  3
0439E:  SUBWF  x60,W
043A0:  BNZ   4388
....................                   break; 
043A2:  MOVLB  0
043A4:  BRA    43DA
....................    #endif 
....................  
....................    #ifdef CCS_UDP_EXAMPLE 
....................       case 'U':   ui_udp_settings(); 
....................                   break; 
....................    #endif 
....................  
....................  
....................       case 'T':   hardware_test(); 
043A6:  BRA    3CA0
....................                   break; 
043A8:  BRA    43DA
....................  
....................       case 'D':   ui_settings(); 
043AA:  CALL   31F2
....................                   break; 
043AE:  BRA    43DA
....................  
....................       case 'S':   ui_setup(); 
043B0:  BRA    415A
....................                   break; 
043B2:  BRA    43DA
....................  
....................       case 'Z':   clear_ee(); 
043B4:  CALL   0F2C
....................                   fprintf(USER,"\r\nEEPROM Cleared\r\n"); 
043B8:  MOVLB  3
043BA:  CLRF   x60
043BC:  MOVF   x60,W
043BE:  MOVLB  0
043C0:  CALL   0998
043C4:  MOVLB  3
043C6:  INCF   x60,F
043C8:  MOVLB  0
043CA:  CALL   0EB4
043CE:  MOVLW  12
043D0:  MOVLB  3
043D2:  SUBWF  x60,W
043D4:  BNZ   43BC
....................                   break; 
043D6:  MOVLB  0
043D8:  BRA    43DA
....................    } 
....................    ui_menu(); 
043DA:  CALL   354A
.................... } 
043DE:  GOTO   9BB2 (RETURN)
....................  
....................  
.................... int8 emails_sent=0; 
....................  
.................... enum { 
....................    MYSMTP_STATE_IDLE=0, MYSMTP_STATE_BUTTON_DEBOUNCE=1, 
....................    MYSMTP_STATE_CONNECT=2, MYSMTP_STATE_GET_DNS=3, 
....................    MYSMTP_STATE_CONNECT_NOW=4, MYSMTP_STATE_SEND=5, 
....................    MYSMTP_STATE_SEND_WAIT=6 
.................... } mysmtp_state=0; 
....................  
.................... void LCDTask(void) { 
....................    static TICKTYPE lastTick; 
....................    TICKTYPE currTick; 
....................    static enum {LCD_Display=0, LCD_Wait=1} state=0; 
....................  
....................    currTick=TickGet(); 
*
096A8:  CALL   514A
096AC:  MOVFF  02,360
096B0:  MOVFF  01,35F
....................  
....................    switch(state) { 
096B4:  MOVLW  00
096B6:  BTFSC  58.2
096B8:  MOVLW  01
096BA:  XORLW  00
096BC:  BZ    96C6
096BE:  XORLW  01
096C0:  BTFSC  FD8.2
096C2:  BRA    98D8
096C4:  BRA    9932
....................       case LCD_Display: 
....................             lcd_putc('\f'); 
096C6:  MOVLW  0C
096C8:  MOVLB  3
096CA:  MOVWF  x64
096CC:  MOVLB  0
096CE:  RCALL  95C4
....................            #if STACK_USE_MAC 
....................             if (!MACIsLinked()) 
096D0:  CALL   4520
096D4:  MOVF   01,F
096D6:  BNZ   96FC
....................                printf(lcd_putc,"NO ETHERNET LINK"); 
096D8:  MOVLB  3
096DA:  CLRF   x61
096DC:  MOVF   x61,W
096DE:  MOVLB  0
096E0:  CALL   09C6
096E4:  MOVLB  3
096E6:  INCF   x61,F
096E8:  MOVWF  00
096EA:  MOVWF  x64
096EC:  MOVLB  0
096EE:  RCALL  95C4
096F0:  MOVLW  10
096F2:  MOVLB  3
096F4:  SUBWF  x61,W
096F6:  BNZ   96DC
....................             #if STACK_USE_DHCP 
....................             else if ( (!DHCPIsBound() && read_ext_eeprom(EE_NIC_DHCP) ) || !read_ext_eeprom(EE_NIC_DHCP) ) 
096F8:  BRA    9864
096FA:  MOVLB  0
096FC:  BTFSC  x88.0
096FE:  BRA    9712
09700:  MOVLB  3
09702:  CLRF   xAB
09704:  MOVLW  C0
09706:  MOVWF  xAA
09708:  MOVLB  0
0970A:  CALL   0E7E
0970E:  MOVF   01,F
09710:  BNZ   9724
09712:  MOVLB  3
09714:  CLRF   xAB
09716:  MOVLW  C0
09718:  MOVWF  xAA
0971A:  MOVLB  0
0971C:  CALL   0E7E
09720:  MOVF   01,F
09722:  BNZ   9748
....................                printf(lcd_putc,"DHCP NOT BOUND"); 
09724:  MOVLB  3
09726:  CLRF   x61
09728:  MOVF   x61,W
0972A:  MOVLB  0
0972C:  CALL   09F2
09730:  MOVLB  3
09732:  INCF   x61,F
09734:  MOVWF  00
09736:  MOVWF  x64
09738:  MOVLB  0
0973A:  RCALL  95C4
0973C:  MOVLW  0E
0973E:  MOVLB  3
09740:  SUBWF  x61,W
09742:  BNZ   9728
....................             #endif 
....................            #elif STACK_USE_PPP 
....................             if (ppp_is_connecting()) { 
....................                printf(lcd_putc,"PPP CONNECTING"); 
....................             } 
....................             else if (!ppp_is_connected()) { 
....................                printf(lcd_putc,"NOT CONNECTED"); 
....................             } 
....................            #endif 
....................             else 
09744:  BRA    9864
09746:  MOVLB  0
....................             { 
....................                if ((mysmtp_state==MYSMTP_STATE_CONNECT_NOW)||(mysmtp_state==MYSMTP_STATE_GET_DNS)) 
09748:  MOVLB  3
0974A:  MOVF   x56,W
0974C:  SUBLW  04
0974E:  BZ    9756
09750:  MOVF   x56,W
09752:  SUBLW  03
09754:  BNZ   9776
....................                { 
....................                   printf(lcd_putc,"Resolving DNS"); 
09756:  CLRF   x61
09758:  MOVF   x61,W
0975A:  MOVLB  0
0975C:  CALL   0A1C
09760:  MOVLB  3
09762:  INCF   x61,F
09764:  MOVWF  00
09766:  MOVWF  x64
09768:  MOVLB  0
0976A:  RCALL  95C4
0976C:  MOVLW  0D
0976E:  MOVLB  3
09770:  SUBWF  x61,W
09772:  BNZ   9758
....................                } 
....................                else 
09774:  BRA    9864
....................                { 
....................                   switch (smtp_state) 
....................                   { 
09776:  MOVLB  1
09778:  MOVF   x6B,W
0977A:  ADDLW  EE
0977C:  BTFSC  FD8.0
0977E:  BRA    9862
09780:  ADDLW  12
09782:  MOVLB  0
09784:  GOTO   9936
....................                      case SMTP_STATE_WAITING: 
....................                         printf(lcd_putc,"SMTP Idle"); 
09788:  MOVLB  3
0978A:  CLRF   x61
0978C:  MOVF   x61,W
0978E:  MOVLB  0
09790:  CALL   0A44
09794:  MOVLB  3
09796:  INCF   x61,F
09798:  MOVWF  00
0979A:  MOVWF  x64
0979C:  MOVLB  0
0979E:  RCALL  95C4
097A0:  MOVLW  09
097A2:  MOVLB  3
097A4:  SUBWF  x61,W
097A6:  BNZ   978C
....................                         break; 
097A8:  MOVLB  1
097AA:  BRA    9862
....................  
....................                      case SMTP_STATE_ARP_REQ: 
....................                      case SMTP_STATE_ARP_WAIT: 
....................                      case SMTP_STATE_CONNECT: 
....................                      case SMTP_STATE_CONNECT_WAIT: 
....................                         printf(lcd_putc,"Connecting"); 
097AC:  MOVLB  3
097AE:  CLRF   x61
097B0:  MOVF   x61,W
097B2:  MOVLB  0
097B4:  CALL   0A68
097B8:  MOVLB  3
097BA:  INCF   x61,F
097BC:  MOVWF  00
097BE:  MOVWF  x64
097C0:  MOVLB  0
097C2:  RCALL  95C4
097C4:  MOVLW  0A
097C6:  MOVLB  3
097C8:  SUBWF  x61,W
097CA:  BNZ   97B0
....................                         break; 
097CC:  MOVLB  1
097CE:  BRA    9862
....................  
....................                      case SMTP_STATE_EHLO: 
....................                      case SMTP_STATE_MAIL_FROM: 
....................                      case SMTP_STATE_RCPT_TO: 
....................                      case SMTP_STATE_DATA_START: 
....................                      case SMTP_STATE_DO_CMD: 
....................                         printf(lcd_putc,"Sending SMTP Cmd"); 
097D0:  MOVLB  3
097D2:  CLRF   x61
097D4:  MOVF   x61,W
097D6:  MOVLB  0
097D8:  CALL   0A8E
097DC:  MOVLB  3
097DE:  INCF   x61,F
097E0:  MOVWF  00
097E2:  MOVWF  x64
097E4:  MOVLB  0
097E6:  RCALL  95C4
097E8:  MOVLW  10
097EA:  MOVLB  3
097EC:  SUBWF  x61,W
097EE:  BNZ   97D4
....................                         break; 
097F0:  MOVLB  1
097F2:  BRA    9862
....................  
....................                      case SMTP_STATE_DO_CMD_GET_RESP: 
....................                         printf(lcd_putc,"Read SMTP Response"); 
097F4:  MOVLB  3
097F6:  CLRF   x61
097F8:  MOVF   x61,W
097FA:  MOVLB  0
097FC:  CALL   0ABA
09800:  MOVLB  3
09802:  INCF   x61,F
09804:  MOVWF  00
09806:  MOVWF  x64
09808:  MOVLB  0
0980A:  RCALL  95C4
0980C:  MOVLW  12
0980E:  MOVLB  3
09810:  SUBWF  x61,W
09812:  BNZ   97F8
....................                         break; 
09814:  MOVLB  1
09816:  BRA    9862
....................  
....................                      case SMTP_STATE_PUT_HEADER: 
....................                      case SMTP_STATE_PUT_BODY: 
....................                         printf(lcd_putc,"Sending body/headers"); 
09818:  MOVLB  3
0981A:  CLRF   x61
0981C:  MOVF   x61,W
0981E:  MOVLB  0
09820:  CALL   0AE8
09824:  MOVLB  3
09826:  INCF   x61,F
09828:  MOVWF  00
0982A:  MOVWF  x64
0982C:  MOVLB  0
0982E:  RCALL  95C4
09830:  MOVLW  14
09832:  MOVLB  3
09834:  SUBWF  x61,W
09836:  BNZ   981C
....................                         break; 
09838:  MOVLB  1
0983A:  BRA    9862
....................  
....................                      case SMTP_STATE_FINISH_EMAIL: 
....................                      case SMTP_STATE_FINISH_EMAIL_WAIT: 
....................                      case SMTP_STATE_CLOSE: 
....................                      case SMTP_STATE_FORCE_CLOSE: 
....................                         printf(lcd_putc, "Closing"); 
0983C:  MOVLB  3
0983E:  CLRF   x61
09840:  MOVF   x61,W
09842:  MOVLB  0
09844:  CALL   0B18
09848:  MOVLB  3
0984A:  INCF   x61,F
0984C:  MOVWF  00
0984E:  MOVWF  x64
09850:  MOVLB  0
09852:  RCALL  95C4
09854:  MOVLW  07
09856:  MOVLB  3
09858:  SUBWF  x61,W
0985A:  BNZ   9840
....................                         break; 
0985C:  MOVLB  1
0985E:  BRA    9862
09860:  MOVLB  1
09862:  MOVLB  3
....................                   } 
....................                } 
....................             } 
....................             if (SMTPLastError()) 
09864:  MOVLB  0
09866:  RCALL  91C6
09868:  MOVF   01,F
0986A:  BZ    98A0
....................             { 
....................                //see SMTP_EC in smtp.h for a list of errors 
....................                printf(lcd_putc,"\nERR: %u", SMTPLastError()); 
0986C:  RCALL  91C6
0986E:  MOVFF  01,361
09872:  MOVLB  3
09874:  CLRF   x62
09876:  MOVF   x62,W
09878:  MOVLB  0
0987A:  CALL   0B3A
0987E:  MOVLB  3
09880:  INCF   x62,F
09882:  MOVWF  00
09884:  MOVWF  x64
09886:  MOVLB  0
09888:  RCALL  95C4
0988A:  MOVLW  06
0988C:  MOVLB  3
0988E:  SUBWF  x62,W
09890:  BNZ   9876
09892:  MOVFF  361,362
09896:  MOVLW  1B
09898:  MOVWF  x63
0989A:  MOVLB  0
0989C:  RCALL  9628
....................             } 
....................             else 
0989E:  BRA    98CC
....................             { 
....................                printf(lcd_putc,"\nEmails Sent: %U", emails_sent); 
098A0:  MOVLB  3
098A2:  CLRF   x61
098A4:  MOVF   x61,W
098A6:  MOVLB  0
098A8:  CALL   0B5E
098AC:  MOVLB  3
098AE:  INCF   x61,F
098B0:  MOVWF  00
098B2:  MOVWF  x64
098B4:  MOVLB  0
098B6:  RCALL  95C4
098B8:  MOVLW  0E
098BA:  MOVLB  3
098BC:  SUBWF  x61,W
098BE:  BNZ   98A4
098C0:  MOVFF  355,362
098C4:  MOVLW  1B
098C6:  MOVWF  x63
098C8:  MOVLB  0
098CA:  RCALL  9628
....................             } 
....................          lastTick=currTick; 
098CC:  MOVFF  360,358
098D0:  MOVFF  35F,357
....................          state=LCD_Wait; 
098D4:  BSF    58.2
....................          break; 
098D6:  BRA    9932
....................  
....................       case LCD_Wait: 
....................          if (TickGetDiff(currTick,lastTick) > (TICKS_PER_SECOND/4)) 
098D8:  MOVLB  3
098DA:  MOVF   x60,W
098DC:  SUBWF  x58,W
098DE:  BNC   98E8
098E0:  BNZ   98EC
098E2:  MOVF   x57,W
098E4:  SUBWF  x5F,W
098E6:  BNC   98EC
098E8:  MOVLW  00
098EA:  BRA    98EE
098EC:  MOVLW  01
098EE:  CLRF   03
098F0:  IORWF  03,W
098F2:  BZ    991A
098F4:  MOVLW  FF
098F6:  BSF    FD8.0
098F8:  SUBFWB x57,W
098FA:  MOVWF  x61
098FC:  MOVLW  FF
098FE:  SUBFWB x58,W
09900:  MOVWF  x62
09902:  MOVF   x5F,W
09904:  ADDWF  x61,F
09906:  MOVF   x60,W
09908:  ADDWFC x62,F
0990A:  MOVLW  01
0990C:  ADDWF  x61,W
0990E:  MOVWF  01
09910:  MOVLW  00
09912:  ADDWFC x62,W
09914:  MOVWF  03
09916:  MOVF   01,W
09918:  BRA    9928
0991A:  MOVF   x57,W
0991C:  SUBWF  x5F,W
0991E:  MOVWF  00
09920:  MOVF   x58,W
09922:  SUBWFB x60,W
09924:  MOVWF  03
09926:  MOVF   00,W
09928:  SUBLW  02
0992A:  BC    992E
....................             state=LCD_Display; 
0992C:  BCF    58.2
....................          break; 
0992E:  MOVLB  0
09930:  BRA    9932
....................    } 
.................... } 
09932:  GOTO   9BBC (RETURN)
....................  
.................... void my_smtp_send(void) 
.................... { 
....................    mysmtp_state=MYSMTP_STATE_CONNECT; 
*
03C94:  MOVLW  02
03C96:  MOVLB  3
03C98:  MOVWF  x56
.................... } 
03C9A:  MOVLB  0
03C9C:  GOTO   4384 (RETURN)
....................  
.................... void MySMTPTask(void) { 
....................    static TICKTYPE lastTick; 
....................    TICKTYPE currTick; 
....................    static IP_ADDR SMTP_ADDR; 
....................  
....................    currTick=TickGet(); 
*
0924C:  CALL   514A
09250:  MOVFF  02,360
09254:  MOVFF  01,35F
....................  
....................    switch(mysmtp_state) { 
09258:  MOVLB  3
0925A:  MOVF   x56,W
0925C:  ADDLW  F9
0925E:  BTFSC  FD8.0
09260:  BRA    9562
09262:  ADDLW  07
09264:  MOVLB  0
09266:  GOTO   9568
....................       case MYSMTP_STATE_IDLE: 
....................          if (!input(USER_BUTTON1)) { 
0926A:  BTFSC  F80.4
0926C:  BRA    927C
....................             lastTick=currTick; 
0926E:  MOVFF  360,35A
09272:  MOVFF  35F,359
....................             mysmtp_state=MYSMTP_STATE_BUTTON_DEBOUNCE; 
09276:  MOVLW  01
09278:  MOVLB  3
0927A:  MOVWF  x56
....................          } 
....................          break; 
0927C:  MOVLB  3
0927E:  BRA    9562
....................  
....................       case MYSMTP_STATE_BUTTON_DEBOUNCE: 
....................          if (TickGetDiff(currTick,lastTick) > (TICKS_PER_SECOND/4)) { 
09280:  MOVLB  3
09282:  MOVF   x60,W
09284:  SUBWF  x5A,W
09286:  BNC   9290
09288:  BNZ   9294
0928A:  MOVF   x59,W
0928C:  SUBWF  x5F,W
0928E:  BNC   9294
09290:  MOVLW  00
09292:  BRA    9296
09294:  MOVLW  01
09296:  CLRF   03
09298:  IORWF  03,W
0929A:  BZ    92C2
0929C:  MOVLW  FF
0929E:  BSF    FD8.0
092A0:  SUBFWB x59,W
092A2:  MOVWF  x61
092A4:  MOVLW  FF
092A6:  SUBFWB x5A,W
092A8:  MOVWF  x62
092AA:  MOVF   x5F,W
092AC:  ADDWF  x61,F
092AE:  MOVF   x60,W
092B0:  ADDWFC x62,F
092B2:  MOVLW  01
092B4:  ADDWF  x61,W
092B6:  MOVWF  01
092B8:  MOVLW  00
092BA:  ADDWFC x62,W
092BC:  MOVWF  03
092BE:  MOVF   01,W
092C0:  BRA    92D0
092C2:  MOVF   x59,W
092C4:  SUBWF  x5F,W
092C6:  MOVWF  00
092C8:  MOVF   x5A,W
092CA:  SUBWFB x60,W
092CC:  MOVWF  03
092CE:  MOVF   00,W
092D0:  SUBLW  02
092D2:  BC    92E0
....................             if (!input(USER_BUTTON1)) 
092D4:  BTFSC  F80.4
092D6:  BRA    92DE
....................                mysmtp_state=MYSMTP_STATE_CONNECT; 
092D8:  MOVLW  02
092DA:  MOVWF  x56
....................             else 
092DC:  BRA    92E0
....................                mysmtp_state=MYSMTP_STATE_IDLE; 
092DE:  CLRF   x56
....................          } 
....................          break; 
092E0:  BRA    9562
....................  
....................       case MYSMTP_STATE_CONNECT: 
....................          fprintf(USER,"\r\n\nFinding IP address for %s", SMTP_HOST_NAME); 
092E2:  MOVLB  3
092E4:  CLRF   x61
092E6:  MOVF   x61,W
092E8:  MOVLB  0
092EA:  CALL   0B8A
092EE:  MOVLB  3
092F0:  INCF   x61,F
092F2:  MOVLB  0
092F4:  CALL   0EB4
092F8:  MOVLW  1A
092FA:  MOVLB  3
092FC:  SUBWF  x61,W
092FE:  BNZ   92E6
09300:  MOVLW  02
09302:  MOVWF  FEA
09304:  MOVLW  13
09306:  MOVWF  FE9
09308:  MOVLW  00
0930A:  IORWF  FEF,W
0930C:  BZ    931E
0930E:  MOVF   FEF,W
09310:  BTFSS  F9E.4
09312:  BRA    9310
09314:  MOVWF  FAD
09316:  INCF   FE9,F
09318:  BTFSC  FD8.2
0931A:  INCF   FEA,F
0931C:  BRA    9308
....................          DNSResolve(SMTP_HOST_NAME); 
0931E:  MOVLW  02
09320:  MOVWF  x62
09322:  MOVLW  13
09324:  MOVWF  x61
09326:  MOVLB  0
09328:  GOTO   8A82
....................          lastTick = currTick; 
0932C:  MOVFF  360,35A
09330:  MOVFF  35F,359
....................          mysmtp_state = MYSMTP_STATE_GET_DNS; 
09334:  MOVLW  03
09336:  MOVLB  3
09338:  MOVWF  x56
....................          break; 
0933A:  BRA    9562
....................  
....................       case MYSMTP_STATE_GET_DNS: 
....................          if (DNSIsResolved(&SMTP_ADDR)) 
0933C:  MOVLW  03
0933E:  MOVLB  3
09340:  MOVWF  x62
09342:  MOVLW  5B
09344:  MOVWF  x61
09346:  MOVLB  0
09348:  BRA    8BCE
0934A:  MOVF   01,F
0934C:  BZ    9382
....................          { 
....................             fprintf(USER,"\r\nIP address is resolved to "); 
0934E:  MOVLB  3
09350:  CLRF   x61
09352:  MOVF   x61,W
09354:  MOVLB  0
09356:  CALL   0BC2
0935A:  MOVLB  3
0935C:  INCF   x61,F
0935E:  MOVLB  0
09360:  CALL   0EB4
09364:  MOVLW  1C
09366:  MOVLB  3
09368:  SUBWF  x61,W
0936A:  BNZ   9352
....................             ui_disp_ip_user(&SMTP_ADDR); 
0936C:  MOVLW  03
0936E:  MOVWF  x62
09370:  MOVLW  5B
09372:  MOVWF  x61
09374:  MOVLB  0
09376:  CALL   30BE
....................             mysmtp_state = MYSMTP_STATE_CONNECT_NOW; 
0937A:  MOVLW  04
0937C:  MOVLB  3
0937E:  MOVWF  x56
....................          } 
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 30)) 
09380:  BRA    93C4
09382:  MOVLB  3
09384:  MOVF   x60,W
09386:  SUBWF  x5A,W
09388:  BNC   9392
0938A:  BNZ   9396
0938C:  MOVF   x59,W
0938E:  SUBWF  x5F,W
09390:  BNC   9396
09392:  MOVLW  00
09394:  BRA    9398
09396:  MOVLW  01
09398:  CLRF   03
0939A:  IORWF  03,W
0939C:  BZ    93C4
0939E:  MOVLW  FF
093A0:  BSF    FD8.0
093A2:  SUBFWB x59,W
093A4:  MOVWF  x61
093A6:  MOVLW  FF
093A8:  SUBFWB x5A,W
093AA:  MOVWF  x62
093AC:  MOVF   x5F,W
093AE:  ADDWF  x61,F
093B0:  MOVF   x60,W
093B2:  ADDWFC x62,F
093B4:  MOVLW  01
093B6:  ADDWF  x61,W
093B8:  MOVWF  01
093BA:  MOVLW  00
093BC:  ADDWFC x62,W
093BE:  MOVWF  03
093C0:  MOVF   01,W
093C2:  BRA    93C4
....................          { 
....................             fprintf(USER, "\r\nDNS failure %X.", smDNS); 
....................             mysmtp_state = MYSMTP_STATE_IDLE; 
....................          } 
....................          break; 
093C4:  BRA    9562
....................  
....................       case MYSMTP_STATE_CONNECT_NOW: 
....................          if (SMTPConnect(&SMTP_ADDR, SMTP_PORT, SMTP_FROM_ADDR, SMTP_TO_ADDR, SMTP_SUBJECT)) 
093C6:  MOVLW  03
093C8:  MOVLB  3
093CA:  MOVWF  x62
093CC:  MOVLW  5B
093CE:  MOVWF  x61
093D0:  MOVFF  212,364
093D4:  MOVFF  211,363
093D8:  MOVLW  02
093DA:  MOVWF  x66
093DC:  MOVLW  93
093DE:  MOVWF  x65
093E0:  MOVLW  02
093E2:  MOVWF  x68
093E4:  MOVLW  53
093E6:  MOVWF  x67
093E8:  MOVLW  02
093EA:  MOVWF  x6A
093EC:  MOVLW  D3
093EE:  MOVWF  x69
093F0:  MOVLB  0
093F2:  BRA    916A
093F4:  MOVF   01,F
093F6:  BZ    941E
....................          { 
....................             printf("\r\nOpening socket with SMTP server..."); 
093F8:  MOVLB  3
093FA:  CLRF   x61
093FC:  MOVF   x61,W
093FE:  MOVLB  0
09400:  CALL   0BFA
09404:  MOVLB  3
09406:  INCF   x61,F
09408:  MOVLB  0
0940A:  CALL   0EB4
0940E:  MOVLW  24
09410:  MOVLB  3
09412:  SUBWF  x61,W
09414:  BNZ   93FC
....................             mysmtp_state=MYSMTP_STATE_SEND; 
09416:  MOVLW  05
09418:  MOVWF  x56
....................          } 
....................          else 
0941A:  BRA    943E
0941C:  MOVLB  0
....................          { 
....................             printf("\r\nSMTP engine is busy!  Try again in a few moments."); 
0941E:  MOVLB  3
09420:  CLRF   x61
09422:  MOVF   x61,W
09424:  MOVLB  0
09426:  CALL   0C3A
0942A:  MOVLB  3
0942C:  INCF   x61,F
0942E:  MOVLB  0
09430:  CALL   0EB4
09434:  MOVLW  33
09436:  MOVLB  3
09438:  SUBWF  x61,W
0943A:  BNZ   9422
....................             mysmtp_state=MYSMTP_STATE_IDLE; 
0943C:  CLRF   x56
....................          } 
....................          break; 
0943E:  BRA    9562
....................  
....................       case MYSMTP_STATE_SEND: 
....................          if (SMTPLastError()) { 
09440:  RCALL  91C6
09442:  MOVF   01,F
09444:  BZ    9480
....................             printf("\r\nSMTP Error %X", SMTPLastError()); 
09446:  RCALL  91C6
09448:  MOVFF  01,361
0944C:  MOVLB  3
0944E:  CLRF   x62
09450:  MOVF   x62,W
09452:  MOVLB  0
09454:  CALL   0C88
09458:  MOVLB  3
0945A:  INCF   x62,F
0945C:  MOVLB  0
0945E:  CALL   0EB4
09462:  MOVLW  0D
09464:  MOVLB  3
09466:  SUBWF  x62,W
09468:  BNZ   9450
0946A:  MOVFF  361,362
0946E:  MOVLW  37
09470:  MOVWF  x63
09472:  MOVLB  0
09474:  CALL   2FCE
....................             mysmtp_state=MYSMTP_STATE_IDLE; 
09478:  MOVLB  3
0947A:  CLRF   x56
....................          } 
....................          else if (SMTPIsPutReady()) { 
0947C:  BRA    94DE
0947E:  MOVLB  0
09480:  RCALL  91D0
09482:  MOVF   01,F
09484:  BZ    94DE
....................             printf("\r\nSMTP Connection accepted, now sending body of email."); 
09486:  MOVLB  3
09488:  CLRF   x61
0948A:  MOVF   x61,W
0948C:  MOVLB  0
0948E:  CALL   0CB2
09492:  MOVLB  3
09494:  INCF   x61,F
09496:  MOVLB  0
09498:  CALL   0EB4
0949C:  MOVLW  36
0949E:  MOVLB  3
094A0:  SUBWF  x61,W
094A2:  BNZ   948A
....................             printf(SMTPPut, "%s", SMTP_BODY); 
094A4:  MOVLW  03
094A6:  MOVWF  FEA
094A8:  MOVLW  13
094AA:  MOVWF  FE9
094AC:  MOVLW  00
094AE:  IORWF  FEF,W
094B0:  BZ    94D4
094B2:  MOVFF  FEA,362
094B6:  MOVFF  FE9,361
094BA:  MOVFF  FEF,363
094BE:  MOVLB  0
094C0:  BRA    91F6
094C2:  MOVFF  362,FEA
094C6:  MOVFF  361,FE9
094CA:  INCF   FE9,F
094CC:  BTFSC  FD8.2
094CE:  INCF   FEA,F
094D0:  MOVLB  3
094D2:  BRA    94AC
....................             SMTPDisconnect(); 
094D4:  MOVLB  0
094D6:  BRA    9218
....................             mysmtp_state=MYSMTP_STATE_SEND_WAIT; 
094D8:  MOVLW  06
094DA:  MOVLB  3
094DC:  MOVWF  x56
....................          } 
....................          break; 
094DE:  MOVLB  3
094E0:  BRA    9562
....................  
....................       case MYSMTP_STATE_SEND_WAIT: 
....................          if (SMTPIsFree()) 
094E2:  BRA    9236
094E4:  MOVF   01,F
094E6:  BZ    955C
....................          { 
....................             if (!SMTPLastError()) 
094E8:  RCALL  91C6
094EA:  MOVF   01,F
094EC:  BNZ   9512
....................             { 
....................                emails_sent++; 
094EE:  MOVLB  3
094F0:  INCF   x55,F
....................                printf("\r\nE-mail accepted by SMTP server!"); 
094F2:  CLRF   x61
094F4:  MOVF   x61,W
094F6:  MOVLB  0
094F8:  CALL   0D04
094FC:  MOVLB  3
094FE:  INCF   x61,F
09500:  MOVLB  0
09502:  CALL   0EB4
09506:  MOVLW  21
09508:  MOVLB  3
0950A:  SUBWF  x61,W
0950C:  BNZ   94F4
....................             } 
....................             else 
0950E:  BRA    9544
09510:  MOVLB  0
....................                printf("\r\nE-Mail rejected by SMTP server! %X", SMTPLastError()); 
09512:  RCALL  91C6
09514:  MOVFF  01,361
09518:  MOVLB  3
0951A:  CLRF   x62
0951C:  MOVF   x62,W
0951E:  MOVLB  0
09520:  CALL   0D40
09524:  MOVLB  3
09526:  INCF   x62,F
09528:  MOVLB  0
0952A:  CALL   0EB4
0952E:  MOVLW  22
09530:  MOVLB  3
09532:  SUBWF  x62,W
09534:  BNZ   951C
09536:  MOVFF  361,362
0953A:  MOVLW  37
0953C:  MOVWF  x63
0953E:  MOVLB  0
09540:  CALL   2FCE
....................             printf("\r\n\n"); 
09544:  MOVLW  0D
09546:  MOVLB  0
09548:  CALL   0EB4
0954C:  MOVLW  0A
0954E:  CALL   0EB4
09552:  MOVLW  0A
09554:  CALL   0EB4
....................             mysmtp_state=MYSMTP_STATE_IDLE; 
09558:  MOVLB  3
0955A:  CLRF   x56
....................          } 
....................          break; 
0955C:  MOVLB  3
0955E:  BRA    9562
09560:  MOVLB  3
....................    } 
.................... } 
09562:  MOVLB  0
09564:  GOTO   9BBA (RETURN)
....................  
.................... void splash(void) 
.................... { 
....................    ui_settings(); 
*
035F8:  RCALL  31F2
....................    ui_menu(); 
035FA:  RCALL  354A
.................... } 
035FC:  GOTO   9B9E (RETURN)
....................  
....................  
.................... void main(void) { 
*
0997E:  CLRF   FF8
09980:  BCF    FD0.7
09982:  BSF    08.7
09984:  CLRF   FEA
09986:  CLRF   FE9
09988:  BSF    FB8.3
0998A:  MOVLW  11
0998C:  MOVWF  FAF
0998E:  MOVLW  04
09990:  MOVWF  FB0
09992:  MOVLW  A6
09994:  MOVWF  FAC
09996:  MOVLW  90
09998:  MOVWF  FAB
0999A:  BSF    FB8.3
0999C:  MOVLW  11
0999E:  MOVWF  FAF
099A0:  MOVLW  04
099A2:  MOVWF  FB0
099A4:  MOVLW  A6
099A6:  MOVWF  FAC
099A8:  MOVLW  90
099AA:  MOVWF  FAB
099AC:  MOVF   FC1,W
099AE:  ANDLW  C0
099B0:  IORLW  0F
099B2:  MOVWF  FC1
099B4:  MOVLW  07
099B6:  MOVWF  FB4
099B8:  CLRF   49
099BA:  CLRF   4A
099BC:  CLRF   50
099BE:  CLRF   51
099C0:  CLRF   52
099C2:  CLRF   53
099C4:  CLRF   x87
099C6:  CLRF   x88
099C8:  CLRF   x89
099CA:  CLRF   x8A
099CC:  CLRF   x8B
099CE:  CLRF   x8C
099D0:  MOVLW  04
099D2:  MOVWF  x8D
099D4:  MOVLW  FF
099D6:  MOVLB  1
099D8:  MOVWF  x44
099DA:  CLRF   x45
099DC:  CLRF   x46
099DE:  CLRF   x47
099E0:  CLRF   x48
099E2:  CLRF   x49
099E4:  CLRF   x4A
099E6:  CLRF   x4B
099E8:  CLRF   x4C
099EA:  CLRF   x4D
099EC:  CLRF   x4E
099EE:  CLRF   x4F
099F0:  CLRF   x50
099F2:  CLRF   x51
099F4:  CLRF   x52
099F6:  CLRF   x53
099F8:  CLRF   x54
099FA:  CLRF   x55
099FC:  CLRF   x56
099FE:  CLRF   x57
09A00:  CLRF   x58
09A02:  CLRF   x59
09A04:  CLRF   x5A
09A06:  CLRF   x5B
09A08:  CLRF   x5C
09A0A:  CLRF   x5D
09A0C:  CLRF   x5E
09A0E:  CLRF   x5F
09A10:  CLRF   x60
09A12:  BCF    58.1
09A14:  CLRF   x61
09A16:  CLRF   x62
09A18:  CLRF   x63
09A1A:  CLRF   x64
09A1C:  CLRF   x65
09A1E:  CLRF   x66
09A20:  CLRF   x67
09A22:  CLRF   x68
09A24:  CLRF   x69
09A26:  CLRF   x6A
09A28:  MOVLW  FE
09A2A:  MOVWF  x6C
09A2C:  CLRF   x7D
09A2E:  CLRF   x80
09A30:  CLRF   x81
09A32:  CLRF   x82
09A34:  CLRF   x83
09A36:  MOVLW  65
09A38:  MOVWF  x84
09A3A:  MOVLW  68
09A3C:  MOVWF  x85
09A3E:  MOVLW  6C
09A40:  MOVWF  x86
09A42:  MOVLW  6F
09A44:  MOVWF  x87
09A46:  MOVLW  20
09A48:  MOVWF  x88
09A4A:  MOVLW  6D
09A4C:  MOVWF  x89
09A4E:  MOVLW  65
09A50:  MOVWF  x8A
09A52:  CLRF   x8B
09A54:  MOVLW  64
09A56:  MOVWF  x8C
09A58:  MOVLW  61
09A5A:  MOVWF  x8D
09A5C:  MOVLW  74
09A5E:  MOVWF  x8E
09A60:  MOVLW  61
09A62:  MOVWF  x8F
09A64:  CLRF   x90
09A66:  MOVLW  6D
09A68:  MOVWF  x91
09A6A:  MOVLW  61
09A6C:  MOVWF  x92
09A6E:  MOVLW  69
09A70:  MOVWF  x93
09A72:  MOVLW  6C
09A74:  MOVWF  x94
09A76:  MOVLW  20
09A78:  MOVWF  x95
09A7A:  MOVLW  66
09A7C:  MOVWF  x96
09A7E:  MOVLW  72
09A80:  MOVWF  x97
09A82:  MOVLW  6F
09A84:  MOVWF  x98
09A86:  MOVLW  6D
09A88:  MOVWF  x99
09A8A:  MOVLW  3A
09A8C:  MOVWF  x9A
09A8E:  MOVLW  20
09A90:  MOVWF  x9B
09A92:  CLRF   x9C
09A94:  MOVLW  72
09A96:  MOVWF  x9D
09A98:  MOVLW  63
09A9A:  MOVWF  x9E
09A9C:  MOVLW  70
09A9E:  MOVWF  x9F
09AA0:  MOVLW  74
09AA2:  MOVWF  xA0
09AA4:  MOVLW  20
09AA6:  MOVWF  xA1
09AA8:  MOVLW  74
09AAA:  MOVWF  xA2
09AAC:  MOVLW  6F
09AAE:  MOVWF  xA3
09AB0:  MOVLW  3A
09AB2:  MOVWF  xA4
09AB4:  MOVLW  20
09AB6:  MOVWF  xA5
09AB8:  CLRF   xA6
09ABA:  CLRF   xA7
09ABC:  CLRF   xA8
09ABE:  CLRF   xA9
09AC0:  CLRF   xAA
09AC2:  CLRF   xAB
09AC4:  CLRF   xAC
09AC6:  CLRF   xB0
09AC8:  CLRF   xB1
09ACA:  MOVLW  05
09ACC:  MOVWF  xB2
09ACE:  CLRF   xB3
09AD0:  CLRF   xB4
09AD2:  CLRF   xB5
09AD4:  CLRF   xB6
09AD6:  CLRF   xB7
09AD8:  CLRF   xB8
09ADA:  CLRF   xB9
09ADC:  CLRF   xBA
09ADE:  CLRF   xBB
09AE0:  CLRF   xBC
09AE2:  CLRF   xBD
09AE4:  CLRF   xBE
09AE6:  CLRF   xBF
09AE8:  CLRF   xC0
09AEA:  CLRF   xCB
09AEC:  CLRF   xCC
09AEE:  CLRF   xCD
09AF0:  CLRF   xCE
09AF2:  CLRF   xCF
09AF4:  CLRF   xD0
09AF6:  CLRF   xD1
09AF8:  CLRF   xD2
09AFA:  CLRF   xD3
09AFC:  CLRF   xD4
09AFE:  CLRF   xD5
09B00:  CLRF   xD6
09B02:  CLRF   xD7
09B04:  CLRF   xD8
09B06:  CLRF   xD9
09B08:  CLRF   xDA
09B0A:  CLRF   xDB
09B0C:  CLRF   xDC
09B0E:  CLRF   xDD
09B10:  CLRF   xDE
09B12:  CLRF   xDF
09B14:  CLRF   xE0
09B16:  CLRF   xE1
09B18:  CLRF   xE2
09B1A:  CLRF   xE3
09B1C:  CLRF   xE4
09B1E:  CLRF   xE5
09B20:  CLRF   xE6
09B22:  CLRF   xE7
09B24:  CLRF   xE8
09B26:  CLRF   xE9
09B28:  CLRF   xEA
09B2A:  CLRF   xEB
09B2C:  CLRF   xEC
09B2E:  CLRF   xED
09B30:  CLRF   xEE
09B32:  CLRF   xEF
09B34:  CLRF   xF0
09B36:  CLRF   xF1
09B38:  CLRF   xF2
09B3A:  CLRF   xF3
09B3C:  CLRF   xF4
09B3E:  CLRF   xF5
09B40:  CLRF   xF6
09B42:  CLRF   xF7
09B44:  CLRF   xF8
09B46:  CLRF   xF9
09B48:  CLRF   xFA
09B4A:  CLRF   xFB
09B4C:  CLRF   xFC
09B4E:  CLRF   xFD
09B50:  CLRF   xFE
09B52:  CLRF   xFF
09B54:  MOVLB  2
09B56:  CLRF   x00
09B58:  CLRF   x01
09B5A:  CLRF   x02
09B5C:  CLRF   x03
09B5E:  CLRF   x04
09B60:  CLRF   x05
09B62:  CLRF   x06
09B64:  CLRF   x07
09B66:  CLRF   x08
09B68:  CLRF   x09
09B6A:  CLRF   x0A
09B6C:  CLRF   x0B
09B6E:  CLRF   x0C
09B70:  CLRF   x0D
09B72:  CLRF   x0E
09B74:  CLRF   x0F
09B76:  CLRF   x10
09B78:  MOVLB  3
09B7A:  CLRF   x53
09B7C:  CLRF   x54
09B7E:  CLRF   x55
09B80:  CLRF   x56
09B82:  CLRF   x57
09B84:  CLRF   x58
09B86:  BCF    58.2
09B88:  CLRF   x59
09B8A:  CLRF   x5A
09B8C:  CLRF   x5B
09B8E:  CLRF   x5C
09B90:  CLRF   x5D
09B92:  CLRF   x5E
....................    init(); 
09B94:  MOVLB  0
09B96:  GOTO   2E9C
....................    splash(); 
09B9A:  GOTO   35F8
....................  
....................    while(TRUE) { 
....................       restart_wdt(); 
09B9E:  CLRWDT
....................  
....................       //every second: refresh current IP, blink LED 
....................       if (second_counter>=1) { 
09BA0:  MOVF   52,W
09BA2:  SUBLW  00
09BA4:  BC    9BAA
....................          output_toggle(USER_LED1); 
09BA6:  BTG    F89.5
....................          second_counter=0; 
09BA8:  CLRF   52
....................       } 
....................  
....................       if (kbhit(USER)) 
09BAA:  BTFSS  F9E.5
09BAC:  BRA    9BB2
....................          ui_handle(); 
09BAE:  GOTO   433E
....................  
....................       #if STACK_USE_PPP 
....................       if (ppp_is_connected()) 
....................       { 
....................       #endif 
....................          StackTask(); 
09BB2:  GOTO   8826
....................          MySMTPTask(); 
09BB6:  GOTO   924C
....................       #if STACK_USE_PPP 
....................       } 
....................       #endif 
....................       LCDTask(); 
09BBA:  BRA    96A8
....................    } 
09BBC:  BRA    9B9E
.................... } 
09BBE:  SLEEP 

Configuration Fuses:
   Word  1: 0600   H4 NOIESO NOFCMEN
   Word  2: 1E18   NOBROWNOUT NOWDT BORV21 PUT WDT32768
   Word  3: 8100   CCP2C1 NOPBADEN NOLPT1OSC MCLR
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: A000   WRT NOWRTD NOWRTC WRTB
   Word  7: 400F   NOEBTR NOEBTRB
